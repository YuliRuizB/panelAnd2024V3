import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
class NgxCsvParser {
    constructor() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ',',
            encoding: 'utf8'
        };
    }
    parse(csvFile, config) {
        config = {
            ...this.defaultCSVParserConfig,
            ...config
        };
        const ngxCSVParserObserver = new Observable((observer) => {
            try {
                let csvRecords = null;
                if (this.isCSVFile(csvFile)) {
                    const reader = new FileReader();
                    reader.readAsText(csvFile, config.encoding);
                    reader.onload = () => {
                        const csvData = reader.result.trim();
                        if (csvData) {
                            const csvRecordsArray = this.csvStringToArray(csvData, config.delimiter);
                            const headersRow = this.getHeaderArray(csvRecordsArray);
                            csvRecords =
                                this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                            observer.next(csvRecords);
                        }
                        else {
                            observer.next([]);
                        }
                        observer.complete();
                    };
                    reader.onerror = () => {
                        this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    }
    csvStringToArray(csvDataString, delimiter) {
        const regexPattern = new RegExp(`(\\${delimiter}|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\${delimiter}\"\\r\\n]*))`, 'gi');
        let matchedPatternArray = regexPattern.exec(csvDataString);
        const resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length &&
                matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            const cleanValue = matchedPatternArray[2]
                ? matchedPatternArray[2].replace(new RegExp('[\\\\"](.)', 'g'), '$1')
                : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    }
    getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {
        const dataArr = [];
        const headersArray = csvRecordsArray[0];
        const startingRowToParseData = config.header ? 1 : 0;
        for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            const data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                const csvRecord = {};
                for (let j = 0; j < data.length; j++) {
                    if (data[j] === undefined || data[j] === null) {
                        csvRecord[headersArray[j]] = '';
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    }
    isCSVFile(file) {
        return file.name.toLowerCase().endsWith('.csv');
    }
    getHeaderArray(csvRecordsArr) {
        const headers = csvRecordsArr[0];
        const headerArray = [];
        for (const header of headers) {
            headerArray.push(header);
        }
        return headerArray;
    }
    notCSVFileErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    }
    unknownCSVParserErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    }
    badCSVDataFormatErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    }
    errorBuilder(type, message, code) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, providedIn: 'root' }); }
}
export { NgxCsvParser };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1jc3YtcGFyc2VyL3NyYy9saWIvbmd4LWNzdi1wYXJzZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQVksTUFBTSxNQUFNLENBQUM7QUFDNUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUNBQXlDLENBQUM7O0FBRzVFLE1BR2EsWUFBWTtJQUh6QjtRQUlZLDJCQUFzQixHQUFvQjtZQUM5QyxNQUFNLEVBQUUsSUFBSTtZQUNaLFNBQVMsRUFBRSxHQUFHO1lBQ2QsUUFBUSxFQUFFLE1BQU07U0FDbkIsQ0FBQztLQW9LTDtJQWxLRyxLQUFLLENBQ0QsT0FBYSxFQUNiLE1BQXVCO1FBRXZCLE1BQU0sR0FBRztZQUNMLEdBQUcsSUFBSSxDQUFDLHNCQUFzQjtZQUM5QixHQUFHLE1BQU07U0FDWixDQUFDO1FBRUYsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLFVBQVUsQ0FDdkMsQ0FBQyxRQUFrRCxFQUFFLEVBQUU7WUFDbkQsSUFBSTtnQkFDQSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUM7Z0JBRXRCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUUsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUU1QyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRTt3QkFDakIsTUFBTSxPQUFPLEdBQUksTUFBTSxDQUFDLE1BQWlCLENBQUMsSUFBSSxFQUFFLENBQUM7d0JBQ2pELElBQUksT0FBTyxFQUFFOzRCQUNULE1BQU0sZUFB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LFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsNEJBQTRCLENBQUMsUUFBdUI7UUFDaEQsTUFBTSxpQkFBaUIsR0FBc0IsSUFBSSxDQUFDLFlBQVksQ0FDMUQsZUFBZSxFQUNmLDBFQUEwRSxFQUMxRSxHQUFHLENBQ04sQ0FBQztRQUNGLFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsNEJBQTRCLENBQUMsUUFBdUI7UUFDaEQsTUFBTSxpQkFBaUIsR0FBc0IsSUFBSSxDQUFDLFlBQVksQ0FDMUQscUJBQXFCLEVBQ3JCLDJCQUEyQixFQUMzQixDQUFDLENBQ0osQ0FBQztRQUNGLFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsWUFBWSxDQUFDLElBQVksRUFBRSxPQUFZLEVBQUUsSUFBUztRQUM5QyxNQUFNLGlCQUFpQixHQUFzQixJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDckUsaUJBQWlCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM5QixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3BDLGlCQUFpQixDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDOUIsT0FBTyxpQkFBaUIsQ0FBQztJQUM3QixDQUFDOzhHQXhLUSxZQUFZO2tIQUFaLFlBQVksY0FGVCxNQUFNOztTQUVULFlBQVk7MkZBQVosWUFBWTtrQkFIeEIsVUFBVTttQkFBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5neENTVlBhcnNlckVycm9yIH0gZnJvbSAnLi9fbW9kZWwvbmd4LWNzdi1wYXJzZXItZXJyb3IuaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgQ1NWUGFyc2VyQ29uZmlnIH0gZnJvbSAnLi9fbW9kZWwvbmd4LWNzdi1wYXJzZXItY29uZmlnLmludGVyZmFjZSc7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5neENzdlBhcnNlciB7XHJcbiAgICBwcml2YXRlIGRlZmF1bHRDU1ZQYXJzZXJDb25maWc6IENTVlBhcnNlckNvbmZpZyA9IHtcclxuICAgICAgICBoZWFkZXI6IHRydWUsXHJcbiAgICAgICAgZGVsaW1pdGVyOiAnLCcsXHJcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xyXG4gICAgfTtcclxuXHJcbiAgICBwYXJzZShcclxuICAgICAgICBjc3ZGaWxlOiBGaWxlLFxyXG4gICAgICAgIGNvbmZpZzogQ1NWUGFyc2VyQ29uZmlnXHJcbiAgICApOiBPYnNlcnZhYmxlPEFycmF5PGFueT4gfCBOZ3hDU1ZQYXJzZXJFcnJvcj4ge1xyXG4gICAgICAgIGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0Q1NWUGFyc2VyQ29uZmlnLFxyXG4gICAgICAgICAgICAuLi5jb25maWdcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBuZ3hDU1ZQYXJzZXJPYnNlcnZlciA9IG5ldyBPYnNlcnZhYmxlKFxyXG4gICAgICAgICAgICAob2JzZXJ2ZXI6IE9ic2VydmVyPEFycmF5PGFueT4gfCBOZ3hDU1ZQYXJzZXJFcnJvcj4pID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNzdlJlY29yZHMgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NTVkZpbGUoY3N2RmlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoY3N2RmlsZSwgY29uZmlnLmVuY29kaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3ZEYXRhID0gKHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3N2RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzdlJlY29yZHNBcnJheSA9IHRoaXMuY3N2U3RyaW5nVG9BcnJheShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3N2RGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRlbGltaXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNSb3cgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEhlYWRlckFycmF5KGNzdlJlY29yZHNBcnJheSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZHMgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldERhdGFSZWNvcmRzQXJyYXlGcm9tQ1NWRmlsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZHNBcnJheSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNSb3cubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoY3N2UmVjb3Jkcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWRDU1ZEYXRhRm9ybWF0RXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdENTVkZpbGVFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmtub3duQ1NWUGFyc2VyRXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZ3hDU1ZQYXJzZXJPYnNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBjc3ZTdHJpbmdUb0FycmF5KGNzdkRhdGFTdHJpbmc6IHN0cmluZywgZGVsaW1pdGVyOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCByZWdleFBhdHRlcm4gPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICBgKFxcXFwke2RlbGltaXRlcn18XFxcXHI/XFxcXG58XFxcXHJ8XikoPzpcXFwiKCg/OlxcXFxcXFxcLnxcXFwiXFxcInxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChbXlxcXFwke2RlbGltaXRlcn1cXFwiXFxcXHJcXFxcbl0qKSlgLFxyXG4gICAgICAgICAgICAnZ2knXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFBhdHRlcm5BcnJheSA9IHJlZ2V4UGF0dGVybi5leGVjKGNzdkRhdGFTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdENTViA9IFtbXV07XHJcbiAgICAgICAgd2hpbGUgKG1hdGNoZWRQYXR0ZXJuQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhdHRlcm5BcnJheVsxXS5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQXJyYXlbMV0gIT09IGRlbGltaXRlclxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdENTVi5wdXNoKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjbGVhblZhbHVlID0gbWF0Y2hlZFBhdHRlcm5BcnJheVsyXVxyXG4gICAgICAgICAgICAgICAgPyBtYXRjaGVkUGF0dGVybkFycmF5WzJdLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCdbXFxcXFxcXFxcIl0oLiknLCAnZycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgJyQxJ1xyXG4gICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICA6IG1hdGNoZWRQYXR0ZXJuQXJyYXlbM107XHJcbiAgICAgICAgICAgIHJlc3VsdENTVltyZXN1bHRDU1YubGVuZ3RoIC0gMV0ucHVzaChjbGVhblZhbHVlKTtcclxuICAgICAgICAgICAgbWF0Y2hlZFBhdHRlcm5BcnJheSA9IHJlZ2V4UGF0dGVybi5leGVjKGNzdkRhdGFTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Q1NWO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGFSZWNvcmRzQXJyYXlGcm9tQ1NWRmlsZShcclxuICAgICAgICBjc3ZSZWNvcmRzQXJyYXk6IGFueSxcclxuICAgICAgICBoZWFkZXJMZW5ndGg6IGFueSxcclxuICAgICAgICBjb25maWc6IGFueVxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YUFyciA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnNBcnJheSA9IGNzdlJlY29yZHNBcnJheVswXTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdSb3dUb1BhcnNlRGF0YSA9IGNvbmZpZy5oZWFkZXIgPyAxIDogMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0aW5nUm93VG9QYXJzZURhdGE7IGkgPCBjc3ZSZWNvcmRzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNzdlJlY29yZHNBcnJheVtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gaGVhZGVyTGVuZ3RoICYmIGNvbmZpZy5oZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNzdlJlY29yZCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2pdID09PSB1bmRlZmluZWQgfHwgZGF0YVtqXSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRbaGVhZGVyc0FycmF5W2pdXSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZFtoZWFkZXJzQXJyYXlbal1dID0gZGF0YVtqXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0YUFyci5wdXNoKGNzdlJlY29yZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhQXJyLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGFBcnI7XHJcbiAgICB9XHJcblxyXG4gICAgaXNDU1ZGaWxlKGZpbGU6IGFueSkge1xyXG4gICAgICAgIHJldHVybiBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmNzdicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhlYWRlckFycmF5KGNzdlJlY29yZHNBcnI6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBjc3ZSZWNvcmRzQXJyWzBdO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xyXG4gICAgICAgICAgICBoZWFkZXJBcnJheS5wdXNoKGhlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBub3RDU1ZGaWxlRXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgbmdjQ1NWUGFyc2VyRXJyb3I6IE5neENTVlBhcnNlckVycm9yID0gdGhpcy5lcnJvckJ1aWxkZXIoXHJcbiAgICAgICAgICAgICdOT1RfQV9DU1ZfRklMRScsXHJcbiAgICAgICAgICAgICdTZWxlY3RlZCBmaWxlIGlzIG5vdCBhIGNzdiBGaWxlIFR5cGUuJyxcclxuICAgICAgICAgICAgMlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHVua25vd25DU1ZQYXJzZXJFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPSB0aGlzLmVycm9yQnVpbGRlcihcclxuICAgICAgICAgICAgJ1VOS05PV05fRVJST1InLFxyXG4gICAgICAgICAgICAnVW5rbm93biBlcnJvci4gUGxlYXNlIHJlZmVyIHRvIG9mZmljaWFsIGRvY3VtZW50YXRpb24gZm9yIGxpYnJhcnkgdXNhZ2UuJyxcclxuICAgICAgICAgICAgNDA0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBvYnNlcnZlci5lcnJvcihuZ2NDU1ZQYXJzZXJFcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgYmFkQ1NWRGF0YUZvcm1hdEVycm9ySGFuZGxlcihvYnNlcnZlcjogT2JzZXJ2ZXI8YW55Pikge1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IHRoaXMuZXJyb3JCdWlsZGVyKFxyXG4gICAgICAgICAgICAnQkFEX0NTVl9EQVRBX0ZPUk1BVCcsXHJcbiAgICAgICAgICAgICdVbmFibGUgdG8gcGFyc2UgQ1NWIEZpbGUuJyxcclxuICAgICAgICAgICAgMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGVycm9yQnVpbGRlcih0eXBlOiBzdHJpbmcsIG1lc3NhZ2U6IGFueSwgY29kZTogYW55KTogTmd4Q1NWUGFyc2VyRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IG5ldyBOZ3hDU1ZQYXJzZXJFcnJvcigpO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHJldHVybiBuZ2NDU1ZQYXJzZXJFcnJvcjtcclxuICAgIH1cclxufVxyXG4iXX0=