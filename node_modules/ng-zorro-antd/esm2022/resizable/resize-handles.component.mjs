/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NgForOf } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { NzResizeHandleComponent } from './resize-handle.component';
import * as i0 from "@angular/core";
export const DEFAULT_RESIZE_DIRECTION = [
    'bottomRight',
    'topRight',
    'bottomLeft',
    'topLeft',
    'bottom',
    'right',
    'top',
    'left'
];
function normalizeResizeHandleOptions(value) {
    return value.map(val => {
        if (typeof val === 'string') {
            return {
                direction: val,
                cursorType: 'window'
            };
        }
        return val;
    });
}
export class NzResizeHandlesComponent {
    constructor() {
        this.nzDirections = DEFAULT_RESIZE_DIRECTION;
        this.resizeHandleOptions = normalizeResizeHandleOptions(this.nzDirections);
    }
    ngOnChanges(changes) {
        if (changes.nzDirections) {
            this.resizeHandleOptions = normalizeResizeHandleOptions(changes.nzDirections.currentValue);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NzResizeHandlesComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.1", type: NzResizeHandlesComponent, isStandalone: true, selector: "nz-resize-handles", inputs: { nzDirections: "nzDirections" }, exportAs: ["nzResizeHandles"], usesOnChanges: true, ngImport: i0, template: `
    <nz-resize-handle
      *ngFor="let option of resizeHandleOptions"
      [nzDirection]="option.direction"
      [nzCursorType]="option.cursorType"
    ></nz-resize-handle>
  `, isInline: true, dependencies: [{ kind: "component", type: NzResizeHandleComponent, selector: "nz-resize-handle, [nz-resize-handle]", inputs: ["nzDirection", "nzCursorType"], outputs: ["nzMouseDown"], exportAs: ["nzResizeHandle"] }, { kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: NzResizeHandlesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-resize-handles',
                    exportAs: 'nzResizeHandles',
                    template: `
    <nz-resize-handle
      *ngFor="let option of resizeHandleOptions"
      [nzDirection]="option.direction"
      [nzCursorType]="option.cursorType"
    ></nz-resize-handle>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    imports: [NzResizeHandleComponent, NgForOf],
                    standalone: true
                }]
        }], propDecorators: { nzDirections: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLWhhbmRsZXMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy9yZXNpemFibGUvcmVzaXplLWhhbmRsZXMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxQyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFFcEcsT0FBTyxFQUFtQyx1QkFBdUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDOztBQUVyRyxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBd0I7SUFDM0QsYUFBYTtJQUNiLFVBQVU7SUFDVixZQUFZO0lBQ1osU0FBUztJQUNULFFBQVE7SUFDUixPQUFPO0lBQ1AsS0FBSztJQUNMLE1BQU07Q0FDUCxDQUFDO0FBT0YsU0FBUyw0QkFBNEIsQ0FBQyxLQUFzRDtJQUMxRixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDckIsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUM1QixPQUFPO2dCQUNMLFNBQVMsRUFBRSxHQUFHO2dCQUNkLFVBQVUsRUFBRSxRQUFRO2FBQ3JCLENBQUM7UUFDSixDQUFDO1FBRUQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFnQkQsTUFBTSxPQUFPLHdCQUF3QjtJQWRyQztRQWVXLGlCQUFZLEdBQW9ELHdCQUF3QixDQUFDO1FBRWxHLHdCQUFtQixHQUFHLDRCQUE0QixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztLQU92RTtJQUxDLFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsNEJBQTRCLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM3RixDQUFDO0lBQ0gsQ0FBQzs4R0FUVSx3QkFBd0I7a0dBQXhCLHdCQUF3QiwyS0FYekI7Ozs7OztHQU1ULDREQUVTLHVCQUF1QixrTEFBRSxPQUFPOzsyRkFHL0Isd0JBQXdCO2tCQWRwQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFFBQVEsRUFBRTs7Ozs7O0dBTVQ7b0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLE9BQU8sRUFBRSxDQUFDLHVCQUF1QixFQUFFLE9BQU8sQ0FBQztvQkFDM0MsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzhCQUVVLFlBQVk7c0JBQXBCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBOZ0Zvck9mIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTnpDdXJzb3JUeXBlLCBOelJlc2l6ZURpcmVjdGlvbiwgTnpSZXNpemVIYW5kbGVDb21wb25lbnQgfSBmcm9tICcuL3Jlc2l6ZS1oYW5kbGUuY29tcG9uZW50JztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVTSVpFX0RJUkVDVElPTjogTnpSZXNpemVEaXJlY3Rpb25bXSA9IFtcbiAgJ2JvdHRvbVJpZ2h0JyxcbiAgJ3RvcFJpZ2h0JyxcbiAgJ2JvdHRvbUxlZnQnLFxuICAndG9wTGVmdCcsXG4gICdib3R0b20nLFxuICAncmlnaHQnLFxuICAndG9wJyxcbiAgJ2xlZnQnXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE56UmVzaXplSGFuZGxlT3B0aW9uIHtcbiAgZGlyZWN0aW9uOiBOelJlc2l6ZURpcmVjdGlvbjtcbiAgY3Vyc29yVHlwZTogTnpDdXJzb3JUeXBlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZXNpemVIYW5kbGVPcHRpb25zKHZhbHVlOiBBcnJheTxOelJlc2l6ZURpcmVjdGlvbiB8IE56UmVzaXplSGFuZGxlT3B0aW9uPik6IE56UmVzaXplSGFuZGxlT3B0aW9uW10ge1xuICByZXR1cm4gdmFsdWUubWFwKHZhbCA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXJlY3Rpb246IHZhbCxcbiAgICAgICAgY3Vyc29yVHlwZTogJ3dpbmRvdydcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ256LXJlc2l6ZS1oYW5kbGVzJyxcbiAgZXhwb3J0QXM6ICduelJlc2l6ZUhhbmRsZXMnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuei1yZXNpemUtaGFuZGxlXG4gICAgICAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHJlc2l6ZUhhbmRsZU9wdGlvbnNcIlxuICAgICAgW256RGlyZWN0aW9uXT1cIm9wdGlvbi5kaXJlY3Rpb25cIlxuICAgICAgW256Q3Vyc29yVHlwZV09XCJvcHRpb24uY3Vyc29yVHlwZVwiXG4gICAgPjwvbnotcmVzaXplLWhhbmRsZT5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGltcG9ydHM6IFtOelJlc2l6ZUhhbmRsZUNvbXBvbmVudCwgTmdGb3JPZl0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgTnpSZXNpemVIYW5kbGVzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbnpEaXJlY3Rpb25zOiBBcnJheTxOelJlc2l6ZURpcmVjdGlvbiB8IE56UmVzaXplSGFuZGxlT3B0aW9uPiA9IERFRkFVTFRfUkVTSVpFX0RJUkVDVElPTjtcblxuICByZXNpemVIYW5kbGVPcHRpb25zID0gbm9ybWFsaXplUmVzaXplSGFuZGxlT3B0aW9ucyh0aGlzLm56RGlyZWN0aW9ucyk7XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLm56RGlyZWN0aW9ucykge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVPcHRpb25zID0gbm9ybWFsaXplUmVzaXplSGFuZGxlT3B0aW9ucyhjaGFuZ2VzLm56RGlyZWN0aW9ucy5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgfVxufVxuIl19