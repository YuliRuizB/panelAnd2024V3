{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/fire/fesm2022/angular-fire-compat-firestore.mjs"],
  "sourcesContent": ["import { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i3 from '@angular/fire/app-check';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS as SETTINGS$1, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport { Observable, asyncScheduler, from, of } from 'rxjs';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter } from 'rxjs/operators';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport firebase from 'firebase/compat/app';\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n  return new Observable(subscriber => {\n    let unsubscribe;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({\n          includeMetadataChanges: true\n        }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({\n        includeMetadataChanges: true\n      }, subscriber);\n    }\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(startWith(undefined), pairwise(), map(snapshots => {\n    const [priorPayload, payload] = snapshots;\n    if (!payload.exists) {\n      return {\n        payload,\n        type: 'removed'\n      };\n    }\n    if (!priorPayload?.exists) {\n      return {\n        payload,\n        type: 'added'\n      };\n    }\n    return {\n      payload,\n      type: 'modified'\n    };\n  }));\n}\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(payload => ({\n    payload,\n    type: 'query'\n  })));\n}\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nclass AngularFirestoreDocument {\n  ref;\n  afs;\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(ref, afs) {\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   */\n  set(data, options) {\n    return this.ref.set(data, options);\n  }\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n  update(data) {\n    return this.ref.update(data);\n  }\n  /**\n   * Delete a document.\n   */\n  delete() {\n    return this.ref.delete();\n  }\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n  collection(path, queryFn) {\n    const collectionRef = this.ref.collection(path);\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges() {\n    const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(keepUnstableUntilFirst);\n  }\n  valueChanges(options = {}) {\n    return this.snapshotChanges().pipe(map(({\n      payload\n    }) => options.idField ? {\n      ...payload.data(),\n      ...{\n        [options.idField]: payload.id\n      }\n    } : payload.data()));\n  }\n  /**\n   * Retrieve the document once.\n   */\n  get(options) {\n    return from(this.ref.get(options)).pipe(keepUnstableUntilFirst);\n  }\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(startWith(undefined), pairwise(), map(actionTuple => {\n    const [priorAction, action] = actionTuple;\n    const docChanges = action.payload.docChanges();\n    const actions = docChanges.map(change => ({\n      type: change.type,\n      payload: change\n    }));\n    // the metadata has changed from the prior emission\n    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n      // go through all the docs in payload and figure out which ones changed\n      action.payload.docs.forEach((currentDoc, currentIndex) => {\n        const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n        const priorDoc = priorAction?.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n          // document doesn't appear to have changed, don't log another action\n        } else {\n          // since the actions are processed in order just push onto the array\n          actions.push({\n            type: 'modified',\n            payload: {\n              oldIndex: currentIndex,\n              newIndex: currentIndex,\n              type: 'modified',\n              doc: currentDoc\n            }\n          });\n        }\n      });\n    }\n    return actions;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nfunction sortedChanges(query, events, scheduler) {\n  return docChanges(query, scheduler).pipe(scan((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), distinctUntilChanged(),\n  // cut down on unneed change cycles\n  map(changes => changes.map(c => ({\n    type: c.type,\n    payload: c\n  }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nfunction combineChanges(current, changes, events) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount, ...args) {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\nfunction validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollection {\n  ref;\n  query;\n  afs;\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(ref, query, afs) {\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events) {\n    let source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n    if (events && events.length > 0) {\n      source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));\n    }\n    return source.pipe(\n    // We want to filter out empty arrays, but always emit at first, so the developer knows\n    // that the collection has been resolve; even if it's empty\n    startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([, current]) => current), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n  valueChanges(options = {}) {\n    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return {\n          ...a.data(),\n          ...{\n            [options.idField]: a.id\n          }\n        };\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data) {\n    return this.ref.add(data);\n  }\n  /**\n   * Create a reference to a single document in a collection.\n   */\n  doc(path) {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n  }\n}\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollectionGroup {\n  query;\n  afs;\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(query, afs) {\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events) {\n    if (!events || events.length === 0) {\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(keepUnstableUntilFirst);\n    }\n    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)), filter(changes => changes.length > 0), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n  valueChanges(options = {}) {\n    const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$.pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return {\n          [options.idField]: a.id,\n          ...a.data()\n        };\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n}\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\nconst USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nfunction associateQuery(collectionRef, queryFn = ref => ref) {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return {\n    query,\n    ref\n  };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\nclass AngularFirestore {\n  schedulers;\n  firestore;\n  persistenceEnabled$;\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(options, name, shouldEnablePersistence, settings,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings,\n  // can't use firebase.auth.AuthSettings here\n  tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n    this.schedulers = schedulers;\n    const app = ɵfirebaseAppFactory(options, zone, name);\n    const useEmulator = _useEmulator;\n    if (auth) {\n      ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n    }\n    [this.firestore, this.persistenceEnabled$] = ɵcacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n      const firestore = zone.runOutsideAngular(() => app.firestore());\n      if (settings) {\n        firestore.settings(settings);\n      }\n      if (useEmulator) {\n        firestore.useEmulator(...useEmulator);\n      }\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n        const enablePersistence = () => {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n          } catch (e) {\n            if (typeof console !== 'undefined') {\n              console.warn(e);\n            }\n            return of(false);\n          }\n        };\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n    }, [settings, useEmulator, shouldEnablePersistence]);\n  }\n  collection(pathOrRef, queryFn) {\n    let collectionRef;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreCollection(refInZone, query, this);\n  }\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n  collectionGroup(collectionId, queryGroupFn) {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n  }\n  doc(pathOrRef) {\n    let ref;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreDocument(refInZone, this);\n  }\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n  static ɵfac = function AngularFirestore_Factory(t) {\n    return new (t || AngularFirestore)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(ENABLE_PERSISTENCE, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(PERSISTENCE_SETTINGS, 8), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AngularFireAuth, 8), i0.ɵɵinject(USE_EMULATOR$1, 8), i0.ɵɵinject(SETTINGS$1, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i3.AppCheckInstances, 8));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFirestore,\n    factory: AngularFirestore.ɵfac,\n    providedIn: 'any'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFirestore, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [FIREBASE_OPTIONS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [FIREBASE_APP_NAME]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ENABLE_PERSISTENCE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [SETTINGS]\n    }]\n  }, {\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i1.ɵAngularFireSchedulers\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [PERSISTENCE_SETTINGS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_EMULATOR]\n    }]\n  }, {\n    type: i2.AngularFireAuth,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_EMULATOR$1]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [SETTINGS$1]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [TENANT_ID]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [LANGUAGE_CODE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_DEVICE_LANGUAGE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [PERSISTENCE]\n    }]\n  }, {\n    type: i3.AppCheckInstances,\n    decorators: [{\n      type: Optional\n    }]\n  }], null);\n})();\nclass AngularFirestoreModule {\n  constructor() {\n    firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n  }\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings) {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [{\n        provide: ENABLE_PERSISTENCE,\n        useValue: true\n      }, {\n        provide: PERSISTENCE_SETTINGS,\n        useValue: persistenceSettings\n      }]\n    };\n  }\n  static ɵfac = function AngularFirestoreModule_Factory(t) {\n    return new (t || AngularFirestoreModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFirestoreModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFirestore]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFirestoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [AngularFirestore]\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };\n"],
  "mappings": "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",
  "names": ["docChanges", "SETTINGS", "USE_EMULATOR"]
}
