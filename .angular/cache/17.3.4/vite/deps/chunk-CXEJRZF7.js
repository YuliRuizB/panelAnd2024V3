import {
  CounterDisposer,
  DEGREES,
  Dictionary,
  DictionaryDisposer,
  DictionaryTemplate,
  Disposer,
  EventDispatcher,
  HALFPI,
  MultiDisposer,
  MutableValueDisposer,
  PI,
  Percent,
  RADIANS,
  TargetedEventDispatcher,
  any,
  cache,
  castString,
  clone,
  concat,
  contains,
  copy,
  copyAllProperties,
  cos,
  each,
  each2,
  each3,
  eachContinue,
  eachContinue2,
  eachContinue3,
  eachOrdered,
  eachReverse,
  fitToRange,
  flatten,
  fromArray,
  getDistance,
  getMidPoint,
  getScale,
  getSortedIndex,
  getValue,
  getValueDefault,
  hasKey,
  hasValue,
  indexOf,
  indexed,
  insertIndex,
  is,
  isArray,
  isDate,
  isInRectangle,
  isNaN as isNaN2,
  isNumber,
  isObject,
  isString,
  keepIf,
  map,
  map2,
  max,
  merge,
  min,
  move,
  nextFrame,
  percent,
  pushAll,
  raf,
  readFrame,
  registry,
  remove,
  removeIndex,
  repeat,
  replace,
  round,
  sin,
  toArray,
  toArray2,
  toBoolean,
  toNumber,
  toNumberOrPercent,
  toNumberRange,
  toText,
  triggerIdle,
  writeFrame
} from "./chunk-SYGNN4YS.js";
import {
  __awaiter,
  __extends,
  __generator,
  __spread,
  __values
} from "./chunk-SM3G46PA.js";
import {
  __export
} from "./chunk-Y6Q6HMFU.js";

// node_modules/@amcharts/amcharts4/.internal/core/utils/List.js
var IndexedIterable = (
  /** @class */
  function() {
    function IndexedIterable2(array, start, end) {
      this._array = array;
      this._start = start;
      this._end = end;
    }
    IndexedIterable2.prototype.iterator = function() {
      var _this = this;
      return function(push) {
        if (_this._start !== _this._end) {
          if (_this._start < _this._end) {
            for (var i = _this._start; i < _this._end; ++i) {
              if (!push(_this._array[i])) {
                break;
              }
            }
          } else {
            for (var i = _this._start - 1; i >= _this._end; --i) {
              if (!push(_this._array[i])) {
                break;
              }
            }
          }
        }
      };
    };
    IndexedIterable2.prototype.backwards = function() {
      return new IndexedIterable2(this._array, this._end, this._start);
    };
    IndexedIterable2.prototype.range = function(start, end) {
      if (start <= end) {
        if (this._start === this._end) {
          return this;
        } else if (this._start < this._end) {
          var diff = end - start;
          start = Math.max(this._start + start, this._start);
          end = Math.min(start + diff, this._end);
          return new IndexedIterable2(this._array, start, end);
        } else {
          var diff = end - start;
          start = Math.max(this._start - start, this._end);
          end = Math.max(start - diff, this._end);
          return new IndexedIterable2(this._array, start, end);
        }
      } else {
        throw new Error("Start index must be lower than end index");
      }
    };
    return IndexedIterable2;
  }()
);
var ListGrouper = (
  /** @class */
  function(_super) {
    __extends(ListGrouper2, _super);
    function ListGrouper2(list, getKey, sort) {
      var _this = _super.call(this, [
        list.events.on("inserted", function(x) {
          var value = x.newValue;
          var key = _this._getKey(value);
          var index = 0;
          eachContinue3(list.iterator(), function(x2) {
            if (x2 === value) {
              return false;
            } else if (_this._getKey(x2) === key) {
              ++index;
            }
            return true;
          });
          _this._insert(value, key, index);
        }, void 0, false),
        list.events.on("removed", function(x) {
          _this._remove(x.oldValue);
        }, void 0, false)
      ]) || this;
      _this._keys = [];
      _this._groups = {};
      _this._getKey = getKey;
      _this._sort = sort;
      each3(list.iterator(), function(x) {
        _this._insert(x, getKey(x));
      });
      return _this;
    }
    ListGrouper2.prototype._insert = function(x, key, index) {
      if (this._groups[key] == null) {
        this._groups[key] = [];
        var _a = getSortedIndex(this._keys, this._sort, key), found = _a.found, index_1 = _a.index;
        if (found) {
          throw new Error("Key already exists: " + key);
        } else {
          insertIndex(this._keys, index_1, key);
        }
      }
      if (index == null) {
        this._groups[key].push(x);
      } else {
        insertIndex(this._groups[key], index, x);
      }
    };
    ListGrouper2.prototype._remove = function(x) {
      var key = this._getKey(x);
      var values = this._groups[key];
      if (values != null) {
        remove(values, x);
        if (values.length === 0) {
          delete this._groups[key];
          var _a = getSortedIndex(this._keys, this._sort, key), found = _a.found, index = _a.index;
          if (found) {
            removeIndex(this._keys, index);
          } else {
            throw new Error("Key doesn't exist: " + key);
          }
        }
      }
    };
    ListGrouper2.prototype.iterator = function() {
      var _this = this;
      return flatten(map2(fromArray(this._keys), function(key) {
        return fromArray(_this._groups[key]);
      }));
    };
    return ListGrouper2;
  }(MultiDisposer)
);
var ListDisposer = (
  /** @class */
  function(_super) {
    __extends(ListDisposer2, _super);
    function ListDisposer2(list, disposeOnRemove) {
      if (disposeOnRemove === void 0) {
        disposeOnRemove = true;
      }
      var _this = this;
      if (disposeOnRemove) {
        var disposer_1 = list.events.on("removed", function(x) {
          x.oldValue.dispose();
        }, void 0, false);
        _this = _super.call(this, function() {
          disposer_1.dispose();
          each3(list.iterator(), function(x) {
            x.dispose();
          });
        }) || this;
      } else {
        _this = _super.call(this, function() {
          each3(list.iterator(), function(x) {
            x.dispose();
          });
        }) || this;
      }
      return _this;
    }
    return ListDisposer2;
  }(Disposer)
);
function checkBounds(index, len) {
  if (!(index >= 0 && index < len)) {
    throw new Error("Index out of bounds: " + index);
  }
}
var List = (
  /** @class */
  function() {
    function List2(initial) {
      if (initial === void 0) {
        initial = [];
      }
      this.events = new EventDispatcher();
      this._values = initial;
    }
    Object.defineProperty(List2.prototype, "values", {
      /**
       * An array of values in the list.
       *
       * Do not use this property to add values. Rather use dedicated methods, like
       * `push()`, `removeIndex()`, etc.
       *
       * @readonly
       * @return List values
       */
      get: function() {
        return this._values;
      },
      enumerable: true,
      configurable: true
    });
    List2.prototype.contains = function(value) {
      return this._values.indexOf(value) !== -1;
    };
    List2.prototype.removeValue = function(value) {
      var i = 0;
      var length = this._values.length;
      while (i < length) {
        if (this._values[i] === value) {
          this.removeIndex(i);
          --length;
        } else {
          ++i;
        }
      }
    };
    List2.prototype.indexOf = function(value) {
      return indexOf(this._values, value);
    };
    Object.defineProperty(List2.prototype, "length", {
      /**
       * Number of items in list.
       *
       * @readonly
       * @return Number of items
       */
      get: function() {
        return this._values.length;
      },
      enumerable: true,
      configurable: true
    });
    List2.prototype.hasIndex = function(index) {
      return index >= 0 && index < this._values.length;
    };
    List2.prototype.getIndex = function(index) {
      return this._values[index];
    };
    List2.prototype.setIndex = function(index, value) {
      checkBounds(index, this._values.length);
      var oldValue = this._values[index];
      if (oldValue !== value) {
        this._values[index] = value;
        if (this.events.isEnabled("setIndex")) {
          this.events.dispatchImmediately("setIndex", {
            type: "setIndex",
            target: this,
            index,
            oldValue,
            newValue: value
          });
        }
        if (this.events.isEnabled("removed")) {
          this.events.dispatchImmediately("removed", {
            type: "removed",
            target: this,
            oldValue
          });
        }
        if (this.events.isEnabled("inserted")) {
          this.events.dispatchImmediately("inserted", {
            type: "inserted",
            target: this,
            newValue: value
          });
        }
      }
      return oldValue;
    };
    List2.prototype.insertIndex = function(index, value) {
      checkBounds(index, this._values.length + 1);
      insertIndex(this._values, index, value);
      if (this.events.isEnabled("insertIndex")) {
        this.events.dispatchImmediately("insertIndex", {
          type: "insertIndex",
          target: this,
          index,
          newValue: value
        });
      }
      if (this.events.isEnabled("inserted")) {
        this.events.dispatchImmediately("inserted", {
          type: "inserted",
          target: this,
          newValue: value
        });
      }
    };
    List2.prototype._sortQuicksort = function(low, high, order2) {
      if (low < high) {
        var p = this._sortPartition(low, high, order2);
        this._sortQuicksort(low, p, order2);
        this._sortQuicksort(p + 1, high, order2);
      }
    };
    List2.prototype._sortPartition = function(low, high, order2) {
      var values = this._values;
      var pivot = values[low];
      var i = low - 1;
      var j = high + 1;
      for (; ; ) {
        do {
          ++i;
        } while (order2(values[i], pivot) < 0);
        do {
          --j;
        } while (order2(values[j], pivot) > 0);
        if (i >= j) {
          return j;
        } else {
          this.swap(i, j);
        }
      }
    };
    List2.prototype.sort = function(order2) {
      this._sortQuicksort(0, this._values.length - 1, order2);
    };
    List2.prototype.swap = function(a, b) {
      var len = this._values.length;
      checkBounds(a, len);
      checkBounds(b, len);
      if (a !== b) {
        var value_a = this._values[a];
        var value_b = this._values[b];
        this._values[a] = value_b;
        if (this.events.isEnabled("setIndex")) {
          this.events.dispatchImmediately("setIndex", {
            type: "setIndex",
            target: this,
            index: a,
            oldValue: value_a,
            newValue: value_b
          });
        }
        this._values[b] = value_a;
        if (this.events.isEnabled("setIndex")) {
          this.events.dispatchImmediately("setIndex", {
            type: "setIndex",
            target: this,
            index: b,
            oldValue: value_b,
            newValue: value_a
          });
        }
      }
    };
    List2.prototype.removeIndex = function(index) {
      checkBounds(index, this._values.length);
      var oldValue = this._values[index];
      removeIndex(this._values, index);
      if (this.events.isEnabled("removeIndex")) {
        this.events.dispatchImmediately("removeIndex", {
          type: "removeIndex",
          target: this,
          index,
          oldValue
        });
      }
      if (this.events.isEnabled("removed")) {
        this.events.dispatchImmediately("removed", {
          type: "removed",
          target: this,
          oldValue
        });
      }
      return oldValue;
    };
    List2.prototype.moveValue = function(value, toIndex) {
      var index = this.indexOf(value);
      if (index !== -1) {
        var oldValue = this._values[index];
        removeIndex(this._values, index);
        if (this.events.isEnabled("removeIndex")) {
          this.events.dispatchImmediately("removeIndex", {
            type: "removeIndex",
            target: this,
            index,
            oldValue
          });
        }
      }
      if (toIndex == null) {
        toIndex = this._values.length;
        this._values.push(value);
      } else {
        insertIndex(this._values, toIndex, value);
      }
      if (this.events.isEnabled("insertIndex")) {
        this.events.dispatchImmediately("insertIndex", {
          type: "insertIndex",
          target: this,
          index: toIndex,
          newValue: value
        });
      }
      if (index === -1) {
        if (this.events.isEnabled("inserted")) {
          this.events.dispatchImmediately("inserted", {
            type: "inserted",
            target: this,
            newValue: value
          });
        }
      }
    };
    List2.prototype.push = function(value) {
      var index = this._values.push(value) - 1;
      if (this.events.isEnabled("insertIndex")) {
        this.events.dispatchImmediately("insertIndex", {
          type: "insertIndex",
          target: this,
          index,
          newValue: value
        });
      }
      if (this.events.isEnabled("inserted")) {
        this.events.dispatchImmediately("inserted", {
          type: "inserted",
          target: this,
          newValue: value
        });
      }
      return value;
    };
    List2.prototype.unshift = function(value) {
      this.insertIndex(0, value);
    };
    List2.prototype.pushAll = function(values) {
      var _this = this;
      each(values, function(value) {
        _this.push(value);
      });
    };
    List2.prototype.copyFrom = function(source) {
      this.pushAll(source._values);
    };
    List2.prototype.pop = function() {
      var index = this._values.length - 1;
      return index < 0 ? void 0 : this.removeIndex(this._values.length - 1);
    };
    List2.prototype.shift = function() {
      return this._values.length ? this.removeIndex(0) : void 0;
    };
    List2.prototype.setAll = function(newArray) {
      var _this = this;
      var oldArray = copy(this._values);
      this._values.length = 0;
      each(newArray, function(value) {
        _this._values.push(value);
      });
      if (this.events.isEnabled("setAll")) {
        this.events.dispatchImmediately("setAll", {
          type: "setAll",
          target: this,
          oldArray,
          newArray: this._values
          // TODO make a copy ?
        });
      }
      if (this.events.isEnabled("removed")) {
        each(oldArray, function(x) {
          _this.events.dispatchImmediately("removed", {
            type: "removed",
            target: _this,
            oldValue: x
          });
        });
      }
      if (this.events.isEnabled("inserted")) {
        each(this._values, function(x) {
          _this.events.dispatchImmediately("inserted", {
            type: "inserted",
            target: _this,
            newValue: x
          });
        });
      }
    };
    List2.prototype.clear = function() {
      this.setAll([]);
    };
    List2.prototype.iterator = function() {
      return fromArray(this._values);
    };
    List2.prototype[Symbol.iterator] = function() {
      var length, i;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            length = this._values.length;
            i = 0;
            _a.label = 1;
          case 1:
            if (!(i < length))
              return [3, 4];
            return [4, this._values[i]];
          case 2:
            _a.sent();
            _a.label = 3;
          case 3:
            ++i;
            return [3, 1];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    List2.prototype.each = function(f) {
      each(this._values, f);
    };
    List2.prototype.range = function(start, end) {
      if (start <= end) {
        var diff = end - start;
        start = Math.max(start, 0);
        end = Math.min(start + diff, this._values.length);
        return new IndexedIterable(this._values, start, end);
      } else {
        throw new Error("Start index must be lower than end index");
      }
    };
    List2.prototype.backwards = function() {
      return new IndexedIterable(this._values, this._values.length, 0);
    };
    return List2;
  }()
);
var ListTemplate = (
  /** @class */
  function(_super) {
    __extends(ListTemplate2, _super);
    function ListTemplate2(t) {
      var _this = _super.call(this) || this;
      _this.template = t;
      return _this;
    }
    Object.defineProperty(ListTemplate2.prototype, "template", {
      /**
       * @return Template object
       */
      get: function() {
        return this._template;
      },
      /**
       * A "template" object to copy all properties from when creating new list
       * items.
       *
       * @param v  Template object
       */
      set: function(v) {
        v.isTemplate = true;
        this._template = v;
      },
      enumerable: true,
      configurable: true
    });
    ListTemplate2.prototype.copyFrom = function(source) {
      var _this = this;
      each3(source.iterator(), function(value) {
        _this.push(value.clone());
      });
    };
    ListTemplate2.prototype.create = function(make) {
      var clone2 = make != null ? new make() : this.template.clone();
      this.push(clone2);
      return clone2;
    };
    ListTemplate2.prototype.clone = function() {
      var out = new ListTemplate2(this.template);
      var values = this.values;
      var length = values.length;
      for (var i = 0; i < length; ++i) {
        out.push(values[i].clone());
      }
      return out;
    };
    return ListTemplate2;
  }(List)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/SortedList.js
var OrderedList = (
  /** @class */
  function() {
    function OrderedList2(initial) {
      this._values = [];
      this.events = new EventDispatcher();
      if (initial != null) {
        this.setAll(initial);
      }
    }
    Object.defineProperty(OrderedList2.prototype, "values", {
      /**
       * All items of the list.
       *
       * Do not modify the list directly. Rather use `insert()` and `remove()`
       * methods.
       *
       * @return List values
       */
      get: function() {
        return this._values;
      },
      enumerable: true,
      configurable: true
    });
    OrderedList2.prototype._insert = function(value) {
      this._values.push(value);
      return this._values.length - 1;
    };
    Object.defineProperty(OrderedList2.prototype, "length", {
      /**
       * Number of items in the list.
       *
       * @readonly
       * @return Length
       */
      get: function() {
        return this._values.length;
      },
      enumerable: true,
      configurable: true
    });
    OrderedList2.prototype.indexOf = function(value) {
      return indexOf(this._values, value);
    };
    OrderedList2.prototype.contains = function(value) {
      return this.indexOf(value) !== -1;
    };
    OrderedList2.prototype.getIndex = function(index) {
      return this._values[index];
    };
    Object.defineProperty(OrderedList2.prototype, "first", {
      /**
       * First item in the list.
       *
       * @return Item
       */
      get: function() {
        return this._values[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(OrderedList2.prototype, "last", {
      /**
       * Last item in the list.
       *
       * @return Item
       */
      get: function() {
        return this._values[this._values.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    OrderedList2.prototype.insert = function(value) {
      var index = this._insert(value);
      if (this.events.isEnabled("inserted")) {
        this.events.dispatchImmediately("inserted", {
          type: "inserted",
          target: this,
          index,
          newValue: value
        });
      }
    };
    OrderedList2.prototype.remove = function(value) {
      var index = this.indexOf(value);
      if (index !== -1) {
        var oldValue = this._values[index];
        removeIndex(this._values, index);
        if (this.events.isEnabled("removed")) {
          this.events.dispatchImmediately("removed", {
            type: "removed",
            target: this,
            index,
            oldValue
          });
        }
      }
    };
    OrderedList2.prototype.setAll = function(newArray) {
      var _this = this;
      eachReverse(this._values, function(x, i) {
        _this._values.pop();
        if (_this.events.isEnabled("removed")) {
          _this.events.dispatchImmediately("removed", {
            type: "removed",
            target: _this,
            index: i,
            oldValue: x
          });
        }
      });
      each(newArray, function(value) {
        _this.insert(value);
      });
    };
    OrderedList2.prototype.clear = function() {
      this.setAll([]);
    };
    OrderedList2.prototype.slice = function(start, end) {
      var out = new OrderedList2();
      out._values = this._values.slice(start, end);
      return out;
    };
    OrderedList2.prototype.findClosestIndex = function(value, fn, direction) {
      if (direction === void 0) {
        direction = "any";
      }
      var closestIndex = -1;
      var closestValue;
      var closestDifference;
      var i = 0;
      eachContinue3(this.iterator(), function(element) {
        var item = fn(element);
        if (direction === "any") {
          if (item === value) {
            closestIndex = i;
            return false;
          }
          var difference = Math.abs(value - item);
          if (!hasValue(closestDifference) || closestDifference > difference) {
            closestIndex = i;
            closestValue = item;
            closestDifference = difference;
          }
        } else if (direction === "left" && item < value) {
          if (!hasValue(closestValue) || closestValue < item) {
            closestIndex = i;
            closestValue = item;
          }
        } else if (direction === "right" && item >= value) {
          if (!hasValue(closestValue) || closestValue >= item) {
            closestIndex = i;
            closestValue = item;
          }
        }
        ++i;
        return true;
      });
      if (closestIndex === -1) {
        if (direction === "left") {
          closestIndex = 0;
        } else if (direction === "right") {
          closestIndex = this.length - 1;
        }
      }
      return closestIndex;
    };
    OrderedList2.prototype.iterator = function() {
      return fromArray(this._values);
    };
    OrderedList2.prototype[Symbol.iterator] = function() {
      var length, i;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            length = this._values.length;
            i = 0;
            _a.label = 1;
          case 1:
            if (!(i < length))
              return [3, 4];
            return [4, this._values[i]];
          case 2:
            _a.sent();
            _a.label = 3;
          case 3:
            ++i;
            return [3, 1];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    OrderedList2.prototype.each = function(f) {
      each(this._values, f);
    };
    return OrderedList2;
  }()
);
var SortedList = (
  /** @class */
  function(_super) {
    __extends(SortedList2, _super);
    function SortedList2(sort) {
      var _this = _super.call(this) || this;
      _this._ordering = sort;
      return _this;
    }
    SortedList2.prototype._insert = function(value) {
      var index = getSortedIndex(this._values, this._ordering, value).index;
      insertIndex(this._values, index, value);
      return index;
    };
    SortedList2.prototype.indexOf = function(value) {
      var _a = getSortedIndex(this._values, this._ordering, value), found = _a.found, index = _a.index;
      if (found) {
        return index;
      } else {
        return -1;
      }
    };
    SortedList2.prototype.update = function(value) {
      var index = indexOf(this._values, value);
      if (index !== -1) {
        var last = this._values.length - 1;
        if (!((index === 0 || this._ordering(this._values[index - 1], value) < 0) && (index === last || this._ordering(value, this._values[index + 1]) < 0))) {
          removeIndex(this._values, index);
          this._insert(value);
        }
      }
    };
    return SortedList2;
  }(OrderedList)
);
var OrderedListTemplate = (
  /** @class */
  function(_super) {
    __extends(OrderedListTemplate2, _super);
    function OrderedListTemplate2(t) {
      var _this = _super.call(this) || this;
      _this.template = t;
      return _this;
    }
    Object.defineProperty(OrderedListTemplate2.prototype, "template", {
      /**
       * @return Template object
       */
      get: function() {
        return this._template;
      },
      /**
       * A "template" object to copy all properties from when creating new list
       * items.
       *
       * @param v  Template object
       */
      set: function(v) {
        v.isTemplate = true;
        this._template = v;
      },
      enumerable: true,
      configurable: true
    });
    OrderedListTemplate2.prototype.copyFrom = function(source) {
      var _this = this;
      each3(source.iterator(), function(value) {
        _this.insert(value.clone());
      });
    };
    OrderedListTemplate2.prototype.slice = function(start, end) {
      var out = new OrderedListTemplate2(this.template);
      out._values = this._values.slice(start, end);
      return out;
    };
    OrderedListTemplate2.prototype.create = function(make) {
      var clone2 = make != null ? new make() : this.template.clone();
      this.insert(clone2);
      return clone2;
    };
    return OrderedListTemplate2;
  }(OrderedList)
);
var SortedListTemplate = (
  /** @class */
  function(_super) {
    __extends(SortedListTemplate2, _super);
    function SortedListTemplate2(t, sort) {
      var _this = _super.call(this, sort) || this;
      _this.template = t;
      return _this;
    }
    Object.defineProperty(SortedListTemplate2.prototype, "template", {
      /**
       * @return Template object
       */
      get: function() {
        return this._template;
      },
      /**
       * A "template" object to copy all properties from when creating new list
       * items.
       *
       * @param v  Template object
       */
      set: function(v) {
        v.isTemplate = true;
        this._template = v;
      },
      enumerable: true,
      configurable: true
    });
    SortedListTemplate2.prototype.copyFrom = function(source) {
      var _this = this;
      each3(source.iterator(), function(value) {
        _this.insert(value.clone());
      });
    };
    SortedListTemplate2.prototype.create = function(make) {
      var clone2 = make != null ? new make() : this.template.clone();
      this.insert(clone2);
      return clone2;
    };
    return SortedListTemplate2;
  }(SortedList)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Number.js
var Number_exports = {};
__export(Number_exports, {
  order: () => order
});
function order(a, b) {
  if (a === b) {
    return 0;
  } else if (a < b) {
    return -1;
  } else {
    return 1;
  }
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/Order.js
function reverse(a) {
  switch (a) {
    case 0:
      return 0;
    case -1:
      return 1;
    case 1:
      return -1;
  }
}
function or(a, b) {
  if (a === 0) {
    return b;
  } else {
    return a;
  }
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/Adapter.js
var GlobalAdapter = (
  /** @class */
  function() {
    function GlobalAdapter2() {
      this._callbackId = 0;
      this._callbacks = new SortedList(function(left, right) {
        return or(order(left.priority, right.priority), order(left.id, right.id));
      });
    }
    GlobalAdapter2.prototype.addAll = function(type, key, callback, priority, scope) {
      if (priority === void 0) {
        priority = 0;
      }
      this._callbacks.insert({
        id: ++this._callbackId,
        key,
        callback,
        priority,
        scope,
        type
      });
    };
    GlobalAdapter2.prototype.isEnabled = function(type, key) {
      return any(this._callbacks.values, function(x) {
        return x.key === key && type instanceof x.type;
      });
    };
    GlobalAdapter2.prototype.applyAll = function(type, key, value) {
      var callbacks = this._callbacks.values;
      var length = callbacks.length;
      if (length == 0) {
        return value;
      }
      for (var i = 0; i < length; ++i) {
        var item = callbacks[i];
        if (item.key === key && type instanceof item.type) {
          value = item.callback.call(item.scope, value, type, key);
        }
      }
      return value;
    };
    return GlobalAdapter2;
  }()
);
var globalAdapter = new GlobalAdapter();
var Adapter = (
  /** @class */
  function() {
    function Adapter2(c) {
      this._callbackId = 0;
      this._callbacks = new SortedList(function(left, right) {
        return or(order(left.priority, right.priority), order(left.id, right.id));
      });
      this._disabled = {};
      this.object = c;
      this.events = this._callbacks.events;
    }
    Adapter2.prototype.add = function(key, callback, priority, scope) {
      if (priority === void 0) {
        priority = 0;
      }
      this._callbacks.insert({
        id: ++this._callbackId,
        key,
        callback,
        priority,
        scope
      });
    };
    Adapter2.prototype.has = function(key, callback, priority, scope) {
      if (priority === void 0) {
        priority = 0;
      }
      return contains(this._callbacks.iterator(), function(item) {
        return item.key === key && item.callback === callback && item.priority === priority && item.scope === scope;
      });
    };
    Adapter2.prototype.remove = function(key, priority) {
      var _this = this;
      each(toArray2(this._callbacks.iterator()), function(item) {
        if (item.key === key && (!isNumber(priority) || priority === item.priority)) {
          _this._callbacks.remove(item);
        }
      });
    };
    Adapter2.prototype.enableKey = function(key) {
      delete this._disabled[key];
    };
    Adapter2.prototype.disableKey = function(key, amount) {
      if (amount === void 0) {
        amount = Infinity;
      }
      this._disabled[key] = amount;
    };
    Adapter2.prototype._hasListenersByType = function(key) {
      return any(this._callbacks.values, function(x) {
        return x.key === key;
      });
    };
    Adapter2.prototype.isEnabled = function(key) {
      return this._disabled[key] == null && (this._hasListenersByType(key) || globalAdapter.isEnabled(this.object, key));
    };
    Adapter2.prototype._shouldDispatch = function(key) {
      var count = this._disabled[key];
      if (!isNumber(count)) {
        return true;
      } else {
        if (count <= 1) {
          delete this._disabled[key];
        } else {
          --this._disabled[key];
        }
        return false;
      }
    };
    Adapter2.prototype.apply = function(key, value) {
      if (this._shouldDispatch(key)) {
        var callbacks = this._callbacks.values;
        var length_1 = callbacks.length;
        if (length_1 > 0) {
          for (var i = 0; i < length_1; ++i) {
            var item = callbacks[i];
            if (item.key === key) {
              value = item.callback.call(item.scope, value, this.object, key);
            }
          }
        }
        value = globalAdapter.applyAll(this.object, key, value);
        return value;
      } else {
        return value;
      }
    };
    Adapter2.prototype.keys = function() {
      return toArray2(map2(this._callbacks.iterator(), function(x) {
        return x.key;
      }));
    };
    Adapter2.prototype.copyFrom = function(source) {
      var _this = this;
      each3(source._callbacks.iterator(), function(x) {
        _this.add(x.key, x.callback, x.priority, x.scope);
      });
      each2(source._disabled, function(key, val) {
        _this._disabled[key] = val;
      });
    };
    Adapter2.prototype.clear = function() {
      this._callbacks.clear();
    };
    return Adapter2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Colors.js
var Colors_exports = {};
__export(Colors_exports, {
  brighten: () => brighten,
  getBrightnessStep: () => getBrightnessStep,
  getLightnessStep: () => getLightnessStep,
  hexToRgb: () => hexToRgb,
  hexToRgbWithAlpha: () => hexToRgbWithAlpha,
  hslToRgb: () => hslToRgb,
  hsvToRgb: () => hsvToRgb,
  interpolate: () => interpolate,
  isLight: () => isLight,
  lighten: () => lighten,
  pad2: () => pad2,
  rgb: () => rgb,
  rgbToHex: () => rgbToHex,
  rgbToHsl: () => rgbToHsl,
  rgbToHsv: () => rgbToHsv,
  rgbToRGBA: () => rgbToRGBA,
  rgbaToRgb: () => rgbaToRgb,
  saturate: () => saturate
});
var namedColors = {
  aliceblue: { r: 240, g: 248, b: 255 },
  antiquewhite: { r: 250, g: 235, b: 215 },
  aqua: { r: 0, g: 255, b: 255 },
  aquamarine: { r: 127, g: 255, b: 212 },
  azure: { r: 240, g: 255, b: 255 },
  beige: { r: 245, g: 245, b: 220 },
  bisque: { r: 255, g: 228, b: 196 },
  black: { r: 0, g: 0, b: 0 },
  blanchedalmond: { r: 255, g: 235, b: 205 },
  blue: { r: 0, g: 0, b: 255 },
  blueviolet: { r: 138, g: 43, b: 226 },
  brown: { r: 165, g: 42, b: 42 },
  burlywood: { r: 222, g: 184, b: 135 },
  cadetblue: { r: 95, g: 158, b: 160 },
  chartreuse: { r: 127, g: 255, b: 0 },
  chocolate: { r: 210, g: 105, b: 30 },
  coral: { r: 255, g: 127, b: 80 },
  cornflowerblue: { r: 100, g: 149, b: 237 },
  cornsilk: { r: 255, g: 248, b: 220 },
  crimson: { r: 220, g: 20, b: 60 },
  cyan: { r: 0, g: 255, b: 255 },
  darkblue: { r: 0, g: 0, b: 139 },
  darkcyan: { r: 0, g: 139, b: 139 },
  darkgoldenrod: { r: 184, g: 134, b: 11 },
  darkgray: { r: 169, g: 169, b: 169 },
  darkgrey: { r: 169, g: 169, b: 169 },
  darkgreen: { r: 0, g: 100, b: 0 },
  darkkhaki: { r: 189, g: 183, b: 107 },
  darkmagenta: { r: 139, g: 0, b: 139 },
  darkolivegreen: { r: 85, g: 107, b: 47 },
  darkorange: { r: 255, g: 140, b: 0 },
  darkorchid: { r: 153, g: 50, b: 204 },
  darkred: { r: 139, g: 0, b: 0 },
  darksalmon: { r: 233, g: 150, b: 122 },
  darkseagreen: { r: 143, g: 188, b: 143 },
  darkslateblue: { r: 72, g: 61, b: 139 },
  darkslategray: { r: 47, g: 79, b: 79 },
  darkslategrey: { r: 47, g: 79, b: 79 },
  darkturquoise: { r: 0, g: 206, b: 209 },
  darkviolet: { r: 148, g: 0, b: 211 },
  deeppink: { r: 255, g: 20, b: 147 },
  deepskyblue: { r: 0, g: 191, b: 255 },
  dimgray: { r: 105, g: 105, b: 105 },
  dimgrey: { r: 105, g: 105, b: 105 },
  dodgerblue: { r: 30, g: 144, b: 255 },
  firebrick: { r: 178, g: 34, b: 34 },
  floralwhite: { r: 255, g: 250, b: 240 },
  forestgreen: { r: 34, g: 139, b: 34 },
  fuchsia: { r: 255, g: 0, b: 255 },
  gainsboro: { r: 220, g: 220, b: 220 },
  ghostwhite: { r: 248, g: 248, b: 255 },
  gold: { r: 255, g: 215, b: 0 },
  goldenrod: { r: 218, g: 165, b: 32 },
  gray: { r: 128, g: 128, b: 128 },
  grey: { r: 128, g: 128, b: 128 },
  green: { r: 0, g: 128, b: 0 },
  greenyellow: { r: 173, g: 255, b: 47 },
  honeydew: { r: 240, g: 255, b: 240 },
  hotpink: { r: 255, g: 105, b: 180 },
  indianred: { r: 205, g: 92, b: 92 },
  indigo: { r: 75, g: 0, b: 130 },
  ivory: { r: 255, g: 255, b: 240 },
  khaki: { r: 240, g: 230, b: 140 },
  lavender: { r: 230, g: 230, b: 250 },
  lavenderblush: { r: 255, g: 240, b: 245 },
  lawngreen: { r: 124, g: 252, b: 0 },
  lemonchiffon: { r: 255, g: 250, b: 205 },
  lightblue: { r: 173, g: 216, b: 230 },
  lightcoral: { r: 240, g: 128, b: 128 },
  lightcyan: { r: 224, g: 255, b: 255 },
  lightgoldenrodyellow: { r: 250, g: 250, b: 210 },
  lightgray: { r: 211, g: 211, b: 211 },
  lightgrey: { r: 211, g: 211, b: 211 },
  lightgreen: { r: 144, g: 238, b: 144 },
  lightpink: { r: 255, g: 182, b: 193 },
  lightsalmon: { r: 255, g: 160, b: 122 },
  lightseagreen: { r: 32, g: 178, b: 170 },
  lightskyblue: { r: 135, g: 206, b: 250 },
  lightslategray: { r: 119, g: 136, b: 153 },
  lightslategrey: { r: 119, g: 136, b: 153 },
  lightsteelblue: { r: 176, g: 196, b: 222 },
  lightyellow: { r: 255, g: 255, b: 224 },
  lime: { r: 0, g: 255, b: 0 },
  limegreen: { r: 50, g: 205, b: 50 },
  linen: { r: 250, g: 240, b: 230 },
  magenta: { r: 255, g: 0, b: 255 },
  maroon: { r: 128, g: 0, b: 0 },
  mediumaquamarine: { r: 102, g: 205, b: 170 },
  mediumblue: { r: 0, g: 0, b: 205 },
  mediumorchid: { r: 186, g: 85, b: 211 },
  mediumpurple: { r: 147, g: 112, b: 219 },
  mediumseagreen: { r: 60, g: 179, b: 113 },
  mediumslateblue: { r: 123, g: 104, b: 238 },
  mediumspringgreen: { r: 0, g: 250, b: 154 },
  mediumturquoise: { r: 72, g: 209, b: 204 },
  mediumvioletred: { r: 199, g: 21, b: 133 },
  midnightblue: { r: 25, g: 25, b: 112 },
  mintcream: { r: 245, g: 255, b: 250 },
  mistyrose: { r: 255, g: 228, b: 225 },
  moccasin: { r: 255, g: 228, b: 181 },
  navajowhite: { r: 255, g: 222, b: 173 },
  navy: { r: 0, g: 0, b: 128 },
  oldlace: { r: 253, g: 245, b: 230 },
  olive: { r: 128, g: 128, b: 0 },
  olivedrab: { r: 107, g: 142, b: 35 },
  orange: { r: 255, g: 165, b: 0 },
  orangered: { r: 255, g: 69, b: 0 },
  orchid: { r: 218, g: 112, b: 214 },
  palegoldenrod: { r: 238, g: 232, b: 170 },
  palegreen: { r: 152, g: 251, b: 152 },
  paleturquoise: { r: 175, g: 238, b: 238 },
  palevioletred: { r: 219, g: 112, b: 147 },
  papayawhip: { r: 255, g: 239, b: 213 },
  peachpuff: { r: 255, g: 218, b: 185 },
  peru: { r: 205, g: 133, b: 63 },
  pink: { r: 255, g: 192, b: 203 },
  plum: { r: 221, g: 160, b: 221 },
  powderblue: { r: 176, g: 224, b: 230 },
  purple: { r: 128, g: 0, b: 128 },
  rebeccapurple: { r: 102, g: 51, b: 153 },
  red: { r: 255, g: 0, b: 0 },
  rosybrown: { r: 188, g: 143, b: 143 },
  royalblue: { r: 65, g: 105, b: 225 },
  saddlebrown: { r: 139, g: 69, b: 19 },
  salmon: { r: 250, g: 128, b: 114 },
  sandybrown: { r: 244, g: 164, b: 96 },
  seagreen: { r: 46, g: 139, b: 87 },
  seashell: { r: 255, g: 245, b: 238 },
  sienna: { r: 160, g: 82, b: 45 },
  silver: { r: 192, g: 192, b: 192 },
  skyblue: { r: 135, g: 206, b: 235 },
  slateblue: { r: 106, g: 90, b: 205 },
  slategray: { r: 112, g: 128, b: 144 },
  slategrey: { r: 112, g: 128, b: 144 },
  snow: { r: 255, g: 250, b: 250 },
  springgreen: { r: 0, g: 255, b: 127 },
  steelblue: { r: 70, g: 130, b: 180 },
  tan: { r: 210, g: 180, b: 140 },
  teal: { r: 0, g: 128, b: 128 },
  thistle: { r: 216, g: 191, b: 216 },
  tomato: { r: 255, g: 99, b: 71 },
  turquoise: { r: 64, g: 224, b: 208 },
  violet: { r: 238, g: 130, b: 238 },
  wheat: { r: 245, g: 222, b: 179 },
  white: { r: 255, g: 255, b: 255 },
  whitesmoke: { r: 245, g: 245, b: 245 },
  yellow: { r: 255, g: 255, b: 0 },
  yellowgreen: { r: 154, g: 205, b: 50 }
};
function rgb(color2, alpha) {
  var rgb2;
  if (namedColors[color2]) {
    rgb2 = namedColors[color2];
  } else if (color2.charAt(0) === "#") {
    rgb2 = hexToRgb(color2);
  } else if (color2.match(/^rgba?\(/)) {
    rgb2 = rgbaToRgb(color2);
  }
  if (!rgb2) {
    rgb2 = { r: 0, g: 0, b: 0, a: 1 };
  }
  if (hasValue(alpha)) {
    rgb2.a = alpha;
  }
  return rgb2;
}
function hexToRgb(hex) {
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function(m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : hexToRgbWithAlpha(hex);
}
function hexToRgbWithAlpha(hex) {
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function(m, r, g, b, a) {
    return r + r + g + g + b + b + a + a;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16),
    a: parseInt(result[4], 16) / 256
  } : void 0;
}
function rgbaToRgb(color2) {
  color2 = color2.replace(/[ ]/g, "");
  var matches = color2.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
  if (matches) {
    matches.push("1");
  } else {
    matches = color2.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i);
    if (!matches) {
      return;
    }
  }
  return {
    r: parseInt(matches[1]),
    g: parseInt(matches[2]),
    b: parseInt(matches[3]),
    a: parseFloat(matches[4])
  };
}
function rgbToHex(rgb2) {
  return "#" + pad2(rgb2.r.toString(16)) + pad2(rgb2.g.toString(16)) + pad2(rgb2.b.toString(16));
}
function rgbToRGBA(rgb2) {
  if (hasValue(rgb2.a) && rgb2.a !== 1) {
    return "rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + "," + rgb2.a + ")";
  } else {
    return "rgb(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ")";
  }
}
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}
function interpolate(rgb1, rgb2, percent2) {
  percent2 = fitToRange(percent2, 0, 1);
  if (rgb1) {
    if (rgb2) {
      return {
        r: rgb1.r + Math.round((rgb2.r - rgb1.r) * percent2),
        g: rgb1.g + Math.round((rgb2.g - rgb1.g) * percent2),
        b: rgb1.b + Math.round((rgb2.b - rgb1.b) * percent2),
        a: (rgb1.a || 1) + Math.round(((rgb2.a || 1) - (rgb1.a || 1)) * percent2)
      };
    } else {
      return rgb1;
    }
  } else if (rgb2) {
    return rgb2;
  } else {
    return rgb1;
  }
}
function lighten(rgb2, percent2) {
  if (rgb2) {
    return {
      r: Math.max(0, Math.min(255, rgb2.r + getLightnessStep(rgb2.r, percent2))),
      g: Math.max(0, Math.min(255, rgb2.g + getLightnessStep(rgb2.g, percent2))),
      b: Math.max(0, Math.min(255, rgb2.b + getLightnessStep(rgb2.b, percent2))),
      a: rgb2.a
    };
  } else {
    return rgb2;
  }
}
function getLightnessStep(value, percent2) {
  var base = percent2 > 0 ? 255 - value : value;
  return Math.round(base * percent2);
}
function brighten(rgb2, percent2) {
  if (rgb2) {
    var base = Math.min(Math.max(rgb2.r, rgb2.g, rgb2.b), 230);
    var step = getLightnessStep(base, percent2);
    return {
      r: Math.max(0, Math.min(255, Math.round(rgb2.r + step))),
      g: Math.max(0, Math.min(255, Math.round(rgb2.g + step))),
      b: Math.max(0, Math.min(255, Math.round(rgb2.b + step))),
      a: rgb2.a
    };
  } else {
    return rgb2;
  }
}
function getBrightnessStep(value, percent2) {
  var base = 255;
  return Math.round(base * percent2);
}
function saturate(rgb2, saturation) {
  if (rgb2 == null || saturation == 1) {
    return rgb2;
  }
  var hsl = rgbToHsl(rgb2);
  hsl.s = saturation;
  return hslToRgb(hsl);
}
function hslToRgb(color2) {
  var r, g, b;
  var h = color2.h;
  var s2 = color2.s;
  var l = color2.l;
  if (s2 == 0) {
    r = g = b = l;
  } else {
    var hue2rgb = function hue2rgb2(p2, q2, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q2 - p2) * 6 * t;
      }
      if (t < 1 / 2) {
        return q2;
      }
      if (t < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    };
    var q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function rgbToHsl(color2) {
  var r = color2.r / 255;
  var g = color2.g / 255;
  var b = color2.b / 255;
  var max2 = Math.max(r, g, b);
  var min2 = Math.min(r, g, b);
  var h = 0;
  var s2 = 0;
  var l = (max2 + min2) / 2;
  if (max2 === min2) {
    h = s2 = 0;
  } else {
    var d = max2 - min2;
    s2 = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    switch (max2) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s: s2,
    l
  };
}
function rgbToHsv(color2) {
  var r = color2.r / 255;
  var g = color2.g / 255;
  var b = color2.b / 255;
  var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
  var h = 0;
  var s2 = 0;
  var v = max2;
  var d = max2 - min2;
  s2 = max2 == 0 ? 0 : d / max2;
  if (max2 == min2) {
    h = 0;
  } else {
    switch (max2) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s: s2,
    v
  };
}
function hsvToRgb(color2) {
  var r = 0;
  var g = 0;
  var b = 0;
  var h = color2.h;
  var s2 = color2.s;
  var v = color2.v;
  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s2);
  var q = v * (1 - f * s2);
  var t = v * (1 - (1 - f) * s2);
  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function isLight(color2) {
  return (color2.r * 299 + color2.g * 587 + color2.b * 114) / 1e3 >= 128;
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/Color.js
var Color = (
  /** @class */
  function() {
    function Color2(color2) {
      this._value = color2;
    }
    Object.defineProperty(Color2.prototype, "rgb", {
      /**
       * Returns [[iRGB]] representation of the color.
       *
       * @return RGB object
       */
      get: function() {
        return this._value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Color2.prototype, "hex", {
      /**
       * Returns color hex value string, e.g. "#FF0000".
       *
       * @return Hex color code
       */
      get: function() {
        return this._value ? rgbToHex(this._value) : "none";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Color2.prototype, "rgba", {
      /**
       * Returns an `rgba()` representation of the color, e.g.:
       * `rgba(255, 0, 0, 0.5)`.
       *
       * @return rgba color string
       */
      get: function() {
        return this._value ? rgbToRGBA(this._value) : "none";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Color2.prototype, "alpha", {
      /**
       * Returns current transparency.
       *
       * @return Alpha (0-1)
       */
      get: function() {
        if (this._value != null && this._value.a != null) {
          return this._value.a;
        } else {
          return 1;
        }
      },
      /**
       * Set alpha (transparency) of the color.
       *
       * @param value Alpha (0-1)
       */
      set: function(value) {
        if (this._value) {
          this._value.a = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Color2.prototype, "lightColor", {
      /**
       * Returns current light color setting.
       *
       * @return Color
       */
      get: function() {
        if (!this._lightColor) {
          this._lightColor = new Color2({ r: 255, g: 255, b: 255 });
        }
        return this._lightColor;
      },
      /**
       * Sets "light" color. Used when determining contrasting color.
       *
       * @param color Color
       */
      set: function(color2) {
        this._lightColor = color2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Color2.prototype, "darkColor", {
      /**
       * Returns current dark color setting.
       *
       * @return Color
       */
      get: function() {
        if (!this._darkColor) {
          this._darkColor = new Color2({ r: 0, g: 0, b: 0 });
        }
        return this._darkColor;
      },
      /**
       * Sets "dark" color. Used when determining contrasting color.
       *
       * @param color Color
       */
      set: function(color2) {
        this._darkColor = color2;
      },
      enumerable: true,
      configurable: true
    });
    Color2.prototype.toString = function() {
      return this.alpha < 1 ? this.rgba : this.hex;
    };
    Color2.prototype.lighten = function(percent2) {
      return new Color2(lighten(this.rgb, percent2));
    };
    Color2.prototype.brighten = function(percent2) {
      return new Color2(brighten(this.rgb, percent2));
    };
    Color2.prototype.saturate = function(saturation) {
      return new Color2(saturate(this.rgb, saturation));
    };
    Object.defineProperty(Color2.prototype, "alternative", {
      /**
       * Returns a either light or dark color that contrasts specifically with
       * this color.
       *
       * Uses properties `darkColor` (default black) and `lightColor` (default
       * white).
       *
       * Useful when determining which color label should be on a colored
       * background, so that it stands out.
       *
       * @return Contrasting color
       */
      get: function() {
        if (this.rgb != null) {
          return isLight(this.rgb) ? this.darkColor : this.lightColor;
        } else {
          throw new Error("Color does not exist");
        }
      },
      enumerable: true,
      configurable: true
    });
    return Color2;
  }()
);
function color(value, alpha) {
  if (!hasValue(value)) {
    return new Color(void 0);
  }
  if (typeof value == "string") {
    var cacheId = "_color_" + value + "_" + (alpha || "1");
    var cached = registry.getCache(cacheId);
    if (cached) {
      return new Color({
        r: cached.r,
        g: cached.g,
        b: cached.b,
        a: cached.a
      });
    }
    var rgb2 = rgb(value, alpha);
    registry.setCache(cacheId, rgb2);
    return new Color(rgb2);
  }
  if (value instanceof Color) {
    if (hasValue(alpha)) {
      value.alpha = alpha;
    }
    return value;
  }
  return new Color(value);
}
function isColor(value) {
  return value instanceof Color;
}
function castColor(value) {
  return color(value);
}
function toColor(value) {
  if (hasValue(value) && !isColor(value)) {
    return castColor(value);
  }
  return value;
}

// node_modules/@amcharts/amcharts4/.internal/core/Base.js
var BaseObject = (
  /** @class */
  function() {
    function BaseObject2() {
      this._disposed = false;
      this._disposers = [];
      this.className = "BaseObject";
    }
    BaseObject2.prototype.debug = function() {
    };
    Object.defineProperty(BaseObject2.prototype, "uid", {
      /**
       * Returns object's internal unique ID.
       *
       * @return Unique ID
       */
      get: function() {
        if (!this._uid) {
          this._uid = registry.getUniqueId();
          registry.map.setKey(this._uid, this);
        }
        return this._uid;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseObject2.prototype, "id", {
      /**
       * @return Id
       */
      get: function() {
        return this._id;
      },
      /**
       * Sets the user-defined id of the element.
       *
       * @param value Id
       */
      set: function(value) {
        this._id = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseObject2.prototype, "map", {
      /**
       * Returns a universal collection for mapping ids with objects.
       *
       * @ignore Exclude from docs
       * @return Map collection
       */
      get: function() {
        if (!this._map) {
          this._map = new Dictionary();
        }
        return this._map;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseObject2.prototype, "delayedMap", {
      /**
       * Returns mapping for objects referenced by id in JSON config that are not yet
       * available at processing time.
       *
       * @ignore Exclude from docs
       * @return Map collection
       */
      get: function() {
        if (!this._delayedMap) {
          this._delayedMap = new Dictionary();
        }
        return this._delayedMap;
      },
      enumerable: true,
      configurable: true
    });
    BaseObject2.prototype.addDelayedMap = function(property, id) {
      var map3 = this.delayedMap;
      if (!map3.hasKey(id)) {
        map3.setKey(id, []);
      }
      var list = map3.getKey(id);
      list.push({
        property,
        target: this
      });
    };
    BaseObject2.prototype.processDelayedMap = function() {
      var _this = this;
      this.delayedMap.each(function(id, list) {
        if (_this.map.hasKey(id)) {
          var target_1 = _this.map.getKey(id);
          each(list, function(item) {
            item.target[item.property] = target_1;
          });
          _this.delayedMap.removeKey(id);
        }
      });
    };
    BaseObject2.prototype.applyTheme = function() {
      var _this = this;
      if (registry) {
        var themes = this.getCurrentThemes();
        if (themes) {
          each(themes, function(theme, index) {
            theme(_this);
          });
        }
      }
    };
    Object.defineProperty(BaseObject2.prototype, "themes", {
      /**
       * @ignore Exclude from docs
       * @return An array of themes
       */
      get: function() {
        return this._themes;
      },
      /**
       * A list of themes to be used for this element.
       *
       * @ignore Exclude from docs
       * @param value An array of themes
       */
      set: function(value) {
        this._themes = value;
      },
      enumerable: true,
      configurable: true
    });
    BaseObject2.prototype.getCurrentThemes = function() {
      return this.themes || registry.themes;
    };
    BaseObject2.prototype.isDisposed = function() {
      return this._disposed;
    };
    BaseObject2.prototype.dispose = function() {
      if (!this._disposed) {
        this._disposed = true;
        var a = this._disposers;
        this._disposers = null;
        while (a.length !== 0) {
          var disposer = a.shift();
          disposer.dispose();
        }
        this.clearCache();
        if (this.clonedFrom) {
          this.clonedFrom.clones.removeValue(this);
        }
        var uid = this._uid;
        if (uid != null) {
          registry.map.removeKey(uid);
        }
      }
    };
    BaseObject2.prototype.addDisposer = function(target) {
      this._disposers.push(target);
    };
    BaseObject2.prototype.removeDispose = function(target) {
      if (!this._disposed) {
        var index = indexOf(this._disposers, target);
        if (index > -1) {
          this._disposers.splice(index, 1);
        }
      }
      target.dispose();
    };
    BaseObject2.prototype.clone = function(cloneId) {
      if (!cloneId) {
        cloneId = "clone-" + registry.getUniqueId();
      }
      var newObject = new this.constructor();
      newObject.cloneId = cloneId;
      newObject.copyFrom(this);
      return newObject;
    };
    Object.defineProperty(BaseObject2.prototype, "clones", {
      /**
       * Returns a collection of object's clones.
       *
       * @ignore Exclude from docs
       * @return Clones
       */
      get: function() {
        if (!this._clones) {
          this._clones = new List();
        }
        return this._clones;
      },
      enumerable: true,
      configurable: true
    });
    BaseObject2.prototype.copyFrom = function(object) {
      object.clones.push(this);
      this.clonedFrom = object;
    };
    Object.defineProperty(BaseObject2.prototype, "className", {
      /**
       * @ignore Exclude from docs
       * @return Class name
       */
      get: function() {
        return this._className;
      },
      /**
       * Element's class name. (a class that was used to instantiate the element)
       *
       * @ignore Exclude from docs
       * @param value  Class name
       */
      set: function(value) {
        this._className = value;
      },
      enumerable: true,
      configurable: true
    });
    BaseObject2.prototype.setCache = function(key, value, ttl) {
      cache.set(this.uid, key, value, ttl);
    };
    BaseObject2.prototype.getCache = function(key, value) {
      if (value === void 0) {
        value = void 0;
      }
      return cache.get(this.uid, key, value);
    };
    BaseObject2.prototype.clearCache = function() {
      cache.clear(this.uid);
    };
    BaseObject2.prototype.setTimeout = function(fn, delay) {
      var _this = this;
      var id = setTimeout(function() {
        _this.removeDispose(disposer);
        fn();
      }, delay);
      var disposer = new Disposer(function() {
        clearTimeout(id);
      });
      this._disposers.push(disposer);
      return disposer;
    };
    BaseObject2.prototype.setInterval = function(fn, delay) {
      var _this = this;
      var id = setInterval(function() {
        _this.removeDispose(disposer);
        fn();
      }, delay);
      var disposer = new Disposer(function() {
        clearTimeout(id);
      });
      this._disposers.push(disposer);
      return disposer;
    };
    Object.defineProperty(BaseObject2.prototype, "config", {
      /**
       * ==========================================================================
       * JSON-BASED CONFIG PROCESSING
       * ==========================================================================
       * @hidden
       */
      /**
       * Use this property to set JSON-based config. When set, triggers processing
       * routine, which will go through all properties, and try to apply values,
       * create instances, etc.
       *
       * Use this with caution, as it is a time-consuming process. It's used for
       * initialchart setup only, not routine operations.
       *
       * @param json JSON config
       */
      set: function(config) {
        try {
          this.processConfig(config);
        } catch (e) {
          this.raiseCriticalError(e);
        }
      },
      enumerable: true,
      configurable: true
    });
    BaseObject2.prototype.processConfig = function(config) {
      var _this = this;
      if (!config) {
        return;
      }
      var target = this;
      eachOrdered(config, function(configKey, value) {
        var configValue = value;
        if (configKey == "callback" && typeof value == "function") {
          value.call(target);
        }
        if (_this.hasProperty(configKey)) {
          var item_1;
          if (isObject(configValue) && hasValue(configValue["type"]) && (!isObject(target[configKey]) || !hasValue(target[configKey].className) || configValue["forceCreate"] || target[configKey].className != configValue["type"]) && !_this.asIs(configKey)) {
            item_1 = _this.createClassInstance(configValue["type"]);
            if (item_1) {
              target[configKey] = item_1;
            } else {
              item_1 = target[configKey];
            }
          } else {
            item_1 = target[configKey];
          }
          if (item_1 instanceof Adapter) {
            _this.processAdapters(item_1, configValue);
          } else if (item_1 instanceof EventDispatcher) {
            _this.processEvents(item_1, configValue);
          } else if (configKey == "locale" && isString(configValue)) {
            if (window["am4lang_" + configValue]) {
              target[configKey] = window["am4lang_" + configValue];
            }
          } else if (configKey == "parent" && isString(configValue)) {
            var parent_1 = _this.map.getKey(configValue);
            if (parent_1) {
              target[configKey] = parent_1;
            } else {
              _this.addDelayedMap("parent", configValue);
            }
          } else if (_this.asIs(configKey)) {
            target[configKey] = configValue;
          } else if (_this.asFunction(configKey) && isString(configValue)) {
            if (hasValue(registry.registeredClasses[configValue])) {
              target[configKey] = registry.registeredClasses[configValue];
            } else {
              throw Error("Invalid easing function: " + configValue);
            }
          } else if (configValue instanceof BaseObject2) {
            target[configKey] = configValue;
          } else if (item_1 instanceof BaseObject2) {
            item_1.config = configValue;
          } else if (item_1 instanceof ListTemplate || item_1 instanceof OrderedListTemplate || item_1 instanceof SortedListTemplate) {
            if (isArray(configValue)) {
              if (item_1 instanceof ListTemplate) {
                _this.processListTemplate(configValue, item_1);
              } else {
                _this.processOrderedTemplate(configValue, item_1);
              }
            } else if (isObject(configValue)) {
              if (configValue instanceof BaseObject2) {
                item_1.template = configValue;
              } else {
                var templateValue = void 0;
                if (hasValue(configValue.template)) {
                  templateValue = configValue.template;
                } else {
                  templateValue = configValue;
                }
                if (item_1.template instanceof BaseObject2) {
                  item_1.template.config = templateValue;
                } else {
                  each2(templateValue, function(entryKey, entryValue) {
                    var listItem = item_1.template[entryKey];
                    if (listItem instanceof Adapter) {
                      _this.processAdapters(listItem, entryValue);
                    } else if (listItem instanceof EventDispatcher) {
                      _this.processEvents(listItem, entryValue);
                    } else if (listItem instanceof DictionaryTemplate) {
                      _this.processDictionaryTemplate(listItem, entryValue);
                    } else if (item_1.template[entryKey] instanceof BaseObject2) {
                      item_1.template[entryKey].config = entryValue;
                    } else if (isObject(entryValue) && hasValue(entryValue["type"])) {
                      listItem = _this.createClassInstance(entryValue["type"]);
                      if (listItem) {
                        if (listItem instanceof BaseObject2) {
                          listItem.config = entryValue;
                        }
                        item_1.template[entryKey] = listItem;
                      } else {
                        item_1.template[entryKey] = entryValue;
                      }
                    } else if (listItem instanceof List) {
                      _this.processList(entryValue, listItem);
                    } else {
                      item_1.template[entryKey] = _this.maybeColorOrPercent(entryValue);
                    }
                  });
                }
                if (hasValue(configValue.values)) {
                  if (item_1 instanceof ListTemplate) {
                    _this.processListTemplate(configValue.values, item_1);
                  } else {
                    _this.processOrderedTemplate(configValue.values, item_1);
                  }
                }
              }
            } else {
            }
          } else if (item_1 instanceof List) {
            if (configKey == "children") {
              _this.processList(configValue, item_1, _this);
            } else {
              _this.processList(configValue, item_1);
            }
          } else if (item_1 instanceof DictionaryTemplate) {
            _this.processDictionaryTemplate(item_1, configValue);
          } else if (item_1 instanceof Dictionary) {
            _this.processDictionary(item_1, configValue);
          } else if (item_1 instanceof Color || item_1 instanceof Percent) {
            target[configKey] = _this.maybeColorOrPercent(configValue);
          } else if (isObject(item_1) && isObject(configValue)) {
            copyAllProperties(configValue, item_1);
          } else {
            configValue = _this.maybeColorOrPercent(configValue);
            target[configKey] = configValue;
          }
        } else if (!_this.isReserved(configKey)) {
          target[configKey] = configValue;
        }
      }, this.configOrder);
      if (this.processingErrors.length) {
        var errors = this.processingErrors.join("\n");
        this._processingErrors = [];
        throw Error(errors);
      }
    };
    BaseObject2.prototype.maybeColorOrPercent = function(value) {
      if (isString(value)) {
        if (value.match(/^[\-]?[0-9.]+\%$/)) {
          return percent(toNumber(value));
        } else if (value.match(/^\#[0-9abcdef]{3,}$/i)) {
          return color(value);
        }
      }
      return value;
    };
    BaseObject2.prototype.processAdapters = function(item, config) {
      var _this = this;
      if (isArray(config)) {
        each(config, function(entry, index) {
          item.add(entry.key, entry.callback, entry.priority || 0, _this);
        });
      } else if (isObject(config)) {
        each2(config, function(key, entry) {
          if (!item.has(key, entry)) {
            item.add(key, entry);
          }
        });
      }
    };
    BaseObject2.prototype.processEvents = function(item, config) {
      var _this = this;
      if (isArray(config)) {
        each(config, function(entry, index) {
          item.on(entry.type, entry.callback, _this);
        });
      } else if (isObject(config)) {
        each2(config, function(key, entry) {
          if (!item.has(key, entry)) {
            item.on(key, entry);
          }
        });
      }
    };
    BaseObject2.prototype.processDictionaryTemplate = function(item, config) {
      if (isObject(config)) {
        each2(config, function(entryKey, entryValue) {
          var listItem;
          if (entryKey == "template") {
            listItem = item.template;
          } else if (item.hasKey(entryKey)) {
            listItem = item.getKey(entryKey);
          } else {
            listItem = item.create(entryKey);
          }
          if (listItem instanceof BaseObject2) {
            listItem.config = entryValue;
          } else if (isObject(listItem) && isObject(entryValue)) {
            copyAllProperties(entryValue, listItem);
          } else {
            listItem.setKey(entryKey, entryValue);
          }
        });
      }
    };
    BaseObject2.prototype.processDictionary = function(item, config) {
      if (isObject(config)) {
        each2(config, function(entryKey, entryValue) {
          item.setKey(entryKey, entryValue);
        });
      }
    };
    BaseObject2.prototype.processListTemplate = function(configValue, item) {
      var _this = this;
      each(configValue, function(entry, index) {
        var type = _this.getConfigEntryType(entry);
        var listItem;
        if (item.hasIndex(index) && !entry["forceCreate"]) {
          listItem = item.getIndex(index);
        } else if (entry instanceof BaseObject2) {
          item.push(entry);
          return;
        } else if (type) {
          listItem = item.create(type);
        } else {
          listItem = item.create();
        }
        if (entry === listItem) {
        } else {
          if (isObject(entry)) {
            if (listItem instanceof BaseObject2) {
              listItem.config = entry;
            } else if (isObject(listItem) && isObject(entry)) {
              copyAllProperties(entry, listItem);
            } else {
              item.setIndex(item.indexOf(listItem), entry);
            }
          }
        }
      });
      while (configValue.length > item.length) {
        item.pop();
      }
    };
    BaseObject2.prototype.processOrderedTemplate = function(configValue, item) {
      var _this = this;
      each(configValue, function(entry, index) {
        var type = _this.getConfigEntryType(entry);
        var listItem;
        if (type) {
          listItem = item.create(type);
        } else {
          listItem = item.create();
        }
        if (isObject(entry)) {
          if (listItem instanceof BaseObject2) {
            listItem.config = entry;
          } else if (isObject(listItem) && isObject(entry)) {
            copyAllProperties(entry, listItem);
          } else {
            item.insert(entry);
          }
        }
      });
    };
    BaseObject2.prototype.processList = function(configValue, item, parent) {
      var _this = this;
      if (!isArray(configValue)) {
        configValue = [configValue];
      }
      var itemCount = item.length;
      var extraCount = 0;
      each(configValue, function(entry, index) {
        if (isObject(entry)) {
          var listItem = void 0;
          if (index < itemCount && !entry["forceCreate"]) {
            listItem = item.getIndex(index);
          } else if (entry instanceof BaseObject2) {
            item.push(entry);
            return;
          } else {
            extraCount++;
            listItem = _this.createEntryInstance(entry);
            if (parent) {
              listItem.parent = parent;
            } else {
              item.push(listItem);
            }
          }
          if (listItem instanceof BaseObject2) {
            listItem.config = entry;
          } else if (isObject(listItem) && isObject(entry)) {
            copyAllProperties(entry, listItem);
          }
        } else {
          if (item.hasIndex(index)) {
            item.setIndex(index, entry);
          } else {
            item.push(entry);
          }
        }
      });
      while (!parent && configValue.length + extraCount < item.length) {
        item.pop();
      }
    };
    BaseObject2.prototype.configOrder = function(a, b) {
      if (a == b) {
        return 0;
      } else if (a == "language") {
        return -1;
      } else if (b == "language") {
        return 1;
      } else {
        return 0;
      }
    };
    BaseObject2.prototype.asIs = function(field) {
      return indexOf(["locale"], field) != -1;
    };
    BaseObject2.prototype.asFunction = function(field) {
      return false;
    };
    BaseObject2.prototype.createClassInstance = function(className) {
      if (hasValue(registry.registeredClasses[className])) {
        return new registry.registeredClasses[className]();
      } else {
        throw Error('Invalid type: "' + className + '".');
      }
    };
    BaseObject2.prototype.createEntryInstance = function(config) {
      var res;
      if (hasValue(config["type"])) {
        res = this.createClassInstance(config["type"]);
      }
      if (!res) {
        return config;
      }
      return res;
    };
    BaseObject2.prototype.getConfigEntryType = function(config) {
      if (hasValue(config["type"])) {
        if (hasValue(registry.registeredClasses[config["type"]])) {
          return registry.registeredClasses[config["type"]];
        } else {
          throw Error('Invalid type: "' + config["type"] + '".');
        }
      }
      return;
    };
    BaseObject2.prototype.hasProperty = function(prop) {
      return prop in this ? true : false;
    };
    BaseObject2.prototype.isReserved = function(key) {
      return ["type", "forceCreate"].indexOf(key) !== -1;
    };
    Object.defineProperty(BaseObject2.prototype, "processingErrors", {
      /**
       * A list of errors that happened during JSON processing.
       *
       * @return Errors
       */
      get: function() {
        if (!this._processingErrors) {
          this._processingErrors = [];
        }
        return this._processingErrors;
      },
      enumerable: true,
      configurable: true
    });
    return BaseObject2;
  }()
);
var BaseObjectEvents = (
  /** @class */
  function(_super) {
    __extends(BaseObjectEvents2, _super);
    function BaseObjectEvents2() {
      var _this = _super.call(this) || this;
      _this.className = "BaseObjectEvents";
      return _this;
    }
    Object.defineProperty(BaseObjectEvents2.prototype, "events", {
      /**
       * An [[EventDispatcher]] instance
       */
      get: function() {
        if (!this._eventDispatcher) {
          this._eventDispatcher = new EventDispatcher();
          this._disposers.push(this._eventDispatcher);
        }
        return this._eventDispatcher;
      },
      enumerable: true,
      configurable: true
    });
    BaseObjectEvents2.prototype.dispatch = function(eventType, data) {
      if (this._eventDispatcher) {
        if (this.events.isEnabled(eventType)) {
          if (data) {
            data.type = eventType;
            data.target = data.target || this;
            this.events.dispatch(eventType, {
              type: eventType,
              target: this
            });
          } else {
            this.events.dispatch(eventType, {
              type: eventType,
              target: this
            });
          }
        }
      }
    };
    BaseObjectEvents2.prototype.dispatchImmediately = function(eventType, data) {
      if (this._eventDispatcher) {
        if (this.events.isEnabled(eventType)) {
          if (data) {
            data.type = eventType;
            data.target = data.target || this;
            this.events.dispatchImmediately(eventType, data);
          } else {
            this.events.dispatchImmediately(eventType, {
              type: eventType,
              target: this
            });
          }
        }
      }
    };
    BaseObjectEvents2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (source._eventDispatcher) {
        this.events.copyFrom(source._eventDispatcher);
      }
    };
    return BaseObjectEvents2;
  }(BaseObject)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Strings.js
var PX = "px";
var STRING = "string";
var NUMBER = "number";
var DATE = "date";
var DURATION = "duration";
var PLACEHOLDER = "__§§§__";
var PLACEHOLDER2 = "__§§§§__";

// node_modules/@amcharts/amcharts4/.internal/core/utils/Utils.js
var Utils_exports = {};
__export(Utils_exports, {
  anyToDate: () => anyToDate,
  anyToNumber: () => anyToNumber,
  camelToDashed: () => camelToDashed,
  capitalize: () => capitalize,
  cleanFormat: () => cleanFormat,
  copy: () => copy2,
  copyProperties: () => copyProperties,
  decimalPlaces: () => decimalPlaces,
  documentPointToSprite: () => documentPointToSprite,
  documentPointToSvg: () => documentPointToSvg,
  escapeForRgex: () => escapeForRgex,
  fitNumber: () => fitNumber,
  fitNumberRelative: () => fitNumberRelative,
  get12Hours: () => get12Hours,
  getBaseURI: () => getBaseURI,
  getDayFromWeek: () => getDayFromWeek,
  getFormat: () => getFormat,
  getMonthWeek: () => getMonthWeek,
  getPixelRatio: () => getPixelRatio,
  getTimeZone: () => getTimeZone,
  getWeek: () => getWeek,
  getYearDay: () => getYearDay,
  height: () => height,
  isIE: () => isIE,
  isNotEmpty: () => isNotEmpty,
  joinUrl: () => joinUrl,
  ltrim: () => ltrim,
  numberToString: () => numberToString,
  padString: () => padString,
  parseUrl: () => parseUrl,
  plainText: () => plainText,
  random: () => random,
  relativeRadiusToValue: () => relativeRadiusToValue,
  relativeToValue: () => relativeToValue,
  reverseString: () => reverseString,
  rtrim: () => rtrim,
  serializeUrl: () => serializeUrl,
  softCopyProperties: () => softCopyProperties,
  splitTextByCharCount: () => splitTextByCharCount,
  spritePointToDocument: () => spritePointToDocument,
  spritePointToSprite: () => spritePointToSprite,
  spritePointToSvg: () => spritePointToSvg,
  spriteRectToSvg: () => spriteRectToSvg,
  stringify: () => stringify,
  stripHash: () => stripHash,
  stripTags: () => stripTags,
  svgPointToDocument: () => svgPointToDocument,
  svgPointToSprite: () => svgPointToSprite,
  svgRectToSprite: () => svgRectToSprite,
  trim: () => trim,
  truncateWithEllipsis: () => truncateWithEllipsis,
  unquote: () => unquote,
  used: () => used,
  valueToRelative: () => valueToRelative,
  width: () => width
});

// node_modules/@amcharts/amcharts4/.internal/core/utils/Browser.js
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isInternetExplorer() {
  return /MSIE |Trident\//.test(navigator.userAgent);
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/Utils.js
function used(value) {
}
function copyProperties(source, target) {
  each2(source, function(key, value) {
    if (hasValue(value)) {
      target[key] = value;
    }
  });
  return target;
}
function stripHash(url) {
  return /^[^#]*/.exec(url)[0];
}
function getBaseURI() {
  var url = "#";
  if (isSafari()) {
    var baseURI = document.baseURI;
    if (baseURI) {
      baseURI = stripHash(baseURI);
      var loc = stripHash(location.href);
      if (baseURI !== loc) {
        url = loc + url;
      }
    }
  }
  return url;
}
function softCopyProperties(source, target) {
  each2(source, function(key, value) {
    if (hasValue(value) && !hasValue(target[key])) {
      target[key] = value;
    }
  });
  return target;
}
function copy2(source, target) {
  each2(source, function(key, value) {
    target[key] = value;
  });
  return target;
}
function isNotEmpty(value) {
  return hasValue(value) && value.toString() !== "";
}
function relativeToValue(percent2, full) {
  if (isNumber(percent2)) {
    return percent2;
  } else if (percent2 != null && isNumber(percent2.value) && isNumber(full)) {
    return full * percent2.value;
  } else {
    return 0;
  }
}
function relativeRadiusToValue(percent2, full, subtractIfNegative) {
  var value;
  if (isNumber(percent2)) {
    value = percent2;
    if (value < 0) {
      if (subtractIfNegative) {
        value = full + value;
      } else {
        value = full - value;
      }
    }
  } else if (percent2 != null && isNumber(percent2.value)) {
    value = full * percent2.value;
  }
  return value;
}
function valueToRelative(value, full) {
  if (value instanceof Percent) {
    return value.value;
  } else {
    return value / full;
  }
}
function getPixelRatio() {
  var ratio = window.devicePixelRatio || 1;
  return ratio;
}
function camelToDashed(str) {
  return str.replace(/\W+/g, "-").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
}
function capitalize(str) {
  var arr = str.split("");
  arr[0] = arr[0].toUpperCase();
  return arr.join("");
}
function stringify(value) {
  return JSON.stringify(value);
}
function escapeForRgex(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function splitTextByCharCount(text, maxChars, fullWords, rtl, fullWordFallback) {
  if (text.length <= maxChars) {
    return [text];
  }
  var res = [];
  if (fullWords) {
    var currentIndex = -1;
    var tmpText = text.replace(/([,;:!?\\\/]+|[\s])/g, PLACEHOLDER + "$1" + PLACEHOLDER);
    var words = tmpText.split(PLACEHOLDER);
    for (var i = 1; i < words.length; i++) {
      var word = words[i];
      if ((word == "." || word == ",") && words[i - 1].match(/[\w]+$/)) {
        words[i - 1] += word;
        words[i] = "";
      }
    }
    for (var i = 0; i < words.length; i++) {
      var word = words[i];
      var wordLength = word.length;
      if (wordLength === 0) {
        continue;
      }
      if (wordLength > maxChars && (fullWords !== true || fullWordFallback != false)) {
        if (rtl) {
          word = reverseString(word);
        }
        var parts = word.match(new RegExp(".{1," + maxChars + "}", "g"));
        if (parts) {
          if (rtl) {
            for (var x = 0; x < parts.length; x++) {
              parts[x] = reverseString(parts[x]);
            }
          }
          res = res.concat(parts);
        }
      } else {
        if (currentIndex === -1) {
          res.push("");
          currentIndex = 0;
        }
        if (res[currentIndex].length + wordLength + 1 > maxChars && res[currentIndex] !== "") {
          res.push("");
          currentIndex++;
        }
        res[currentIndex] += word;
      }
      currentIndex = res.length - 1;
    }
  } else {
    var parts = text.match(new RegExp(".{1," + maxChars + "}", "g"));
    if (parts) {
      if (rtl) {
        for (var x = 0; x < parts.length; x++) {
          if (!rtl) {
            parts[x] = reverseString(parts[x]);
          }
        }
      }
      res = parts;
    }
  }
  if (res.length == 1 && fullWords && fullWordFallback && res[0].length > maxChars) {
    res = [];
  }
  return res;
}
function truncateWithEllipsis(text, maxChars, ellipsis, fullWords, rtl) {
  if (text.length <= maxChars) {
    return text;
  }
  maxChars -= ellipsis.length;
  if (maxChars < 1) {
    maxChars = 1;
  }
  var lines = splitTextByCharCount(text, maxChars, fullWords, rtl);
  return (lines[0] || "") + ellipsis;
}
function trim(str) {
  return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
function rtrim(str) {
  return str.replace(/[\s\uFEFF\xA0]+$/g, "");
}
function ltrim(str) {
  return str.replace(/^[\s\uFEFF\xA0]+/g, "");
}
function reverseString(str) {
  return str.split("").reverse().join("");
}
function unquote(str) {
  var res = str.trim();
  res = str.replace(/^'(.*)'$/, "$1");
  if (res == str) {
    res = str.replace(/^"(.*)"$/, "$1");
  }
  return res;
}
function padString(value, len, char) {
  if (len === void 0) {
    len = 0;
  }
  if (char === void 0) {
    char = "0";
  }
  if (typeof value !== "string") {
    value = value.toString();
  }
  return len > value.length ? Array(len - value.length + 1).join(char) + value : value;
}
function getFormat(format) {
  if (typeof format === "undefined") {
    return STRING;
  }
  format = format.toLowerCase().replace(/^\[[^\]]*\]/, "");
  format = format.replace(/\[[^\]]+\]/, "");
  format = format.trim();
  var hints = format.match(/\/(date|number|duration)$/);
  if (hints) {
    return hints[1];
  }
  if (format === NUMBER) {
    return NUMBER;
  }
  if (format === DATE) {
    return DATE;
  }
  if (format === DURATION) {
    return DURATION;
  }
  if (format.match(/[#0]/)) {
    return NUMBER;
  }
  if (format.match(/[ymwdhnsqaxkzgtei]/)) {
    return DATE;
  }
  return STRING;
}
function cleanFormat(format) {
  return format.replace(/\/(date|number|duration)$/i, "");
}
function stripTags(text) {
  return text ? text.replace(/<[^>]*>/g, "") : text;
}
function plainText(text) {
  return text ? stripTags(("" + text).replace(/[\n\r]+/g, ". ")) : text;
}
function numberToString(value) {
  if (isNaN2(value)) {
    return "NaN";
  }
  if (value === Infinity) {
    return "Infinity";
  }
  if (value === -Infinity) {
    return "-Infinity";
  }
  if (value === 0 && 1 / value === -Infinity) {
    return "-0";
  }
  var negative = value < 0;
  value = Math.abs(value);
  var parsed = getValue(/^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + value));
  var digits = parsed[1];
  var decimals = parsed[2] || "";
  var res;
  if (parsed[3] == null) {
    res = decimals === "" ? digits : digits + "." + decimals;
  } else {
    var exponent = +parsed[3];
    if (value < 1) {
      var zeros = exponent - 1;
      res = "0." + repeat("0", zeros) + digits + decimals;
    } else {
      var zeros = exponent - decimals.length;
      if (zeros === 0) {
        res = digits + decimals;
      } else if (zeros < 0) {
        res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);
      } else {
        res = digits + decimals + repeat("0", zeros);
      }
    }
  }
  return negative ? "-" + res : res;
}
function anyToDate(value) {
  if (isDate(value)) {
    var date = new Date(value);
    date.setMilliseconds(value.getMilliseconds());
    return date;
  } else if (isNumber(value)) {
    return new Date(value);
  } else {
    var num = Number(value);
    if (!isNumber(num)) {
      return new Date(value);
    } else {
      return new Date(num);
    }
  }
}
function anyToNumber(value) {
  if (isDate(value)) {
    return value.getTime();
  } else if (isNumber(value)) {
    return value;
  } else if (isString(value)) {
    var num = Number(value);
    if (!isNumber(num)) {
      return void 0;
    } else {
      return num;
    }
  }
}
function getYearDay(date, utc) {
  if (utc === void 0) {
    utc = false;
  }
  var start = new Date(date.getFullYear(), 0, 0);
  var diff = date.getTime() - start.getTime() + (start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1e3;
  var oneDay = 1e3 * 60 * 60 * 24;
  return Math.floor(diff / oneDay);
}
function getWeek(date, _utc) {
  if (_utc === void 0) {
    _utc = false;
  }
  var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  var day = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - day);
  var firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil(((d.getTime() - firstDay.getTime()) / 864e5 + 1) / 7);
}
function getMonthWeek(date, utc) {
  if (utc === void 0) {
    utc = false;
  }
  var firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);
  var currentWeek = getWeek(date, utc);
  if (currentWeek == 1) {
    currentWeek = 53;
  }
  return currentWeek - firstWeek + 1;
}
function getDayFromWeek(week, year, weekday, utc) {
  if (weekday === void 0) {
    weekday = 1;
  }
  if (utc === void 0) {
    utc = false;
  }
  var date = new Date(year, 0, 4, 0, 0, 0, 0);
  if (utc) {
    date.setUTCFullYear(year);
  }
  var day = week * 7 + weekday - ((date.getDay() || 7) + 3);
  return day;
}
function get12Hours(hours, base) {
  if (hours > 12) {
    hours -= 12;
  } else if (hours === 0) {
    hours = 12;
  }
  return hasValue(base) ? hours + (base - 1) : hours;
}
function getTimeZone(date, long, savings, utc) {
  if (long === void 0) {
    long = false;
  }
  if (savings === void 0) {
    savings = false;
  }
  if (utc === void 0) {
    utc = false;
  }
  if (utc) {
    return long ? "Coordinated Universal Time" : "UTC";
  }
  var wotz = date.toLocaleString("UTC");
  var wtz = date.toLocaleString("UTC", { timeZoneName: long ? "long" : "short" }).substr(wotz.length);
  if (savings === false) {
    wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");
  }
  return wtz;
}
function random(from, to) {
  return Math.floor(Math.random() * (to - from)) + from;
}
function fitNumber(value, min2, max2) {
  if (value > max2) {
    return max2;
  } else if (value < min2) {
    return min2;
  }
  return value;
}
function fitNumberRelative(value, min2, max2) {
  var gap = max2 - min2;
  if (value > max2) {
    value = min2 + (value - gap * Math.floor(value / gap));
  } else if (value < min2) {
    value = min2 + (value - gap * Math.floor(value / gap));
  }
  return value;
}
function svgPointToSprite(point, sprite) {
  var x = point.x;
  var y = point.y;
  var sprites = [];
  if (sprite) {
    while (hasValue(sprite.parent)) {
      sprites.push(sprite);
      sprite = sprite.parent;
    }
    sprites.reverse();
    for (var i = 0; i < sprites.length; i++) {
      var sprite_1 = sprites[i];
      var angle = sprite_1.rotation;
      var relativeX = x - sprite_1.pixelX - sprite_1.ex;
      var relativeY = y - sprite_1.pixelY - sprite_1.ey;
      if (sprite_1.dx) {
        x -= sprite_1.dx;
      }
      if (sprite_1.dy) {
        y -= sprite_1.dy;
      }
      var scale = sprite_1.scale;
      if (sprite_1.group) {
        scale = sprite_1.group.scale;
      }
      x = (cos(-angle) * relativeX - sin(-angle) * relativeY) / scale - sprite_1.pixelPaddingLeft;
      y = (cos(-angle) * relativeY + sin(-angle) * relativeX) / scale - sprite_1.pixelPaddingTop;
    }
  }
  return { x, y };
}
function spritePointToSvg(point, sprite) {
  var x = point.x;
  var y = point.y;
  if (sprite) {
    while (hasValue(sprite.parent)) {
      var angle = sprite.rotation;
      x += sprite.pixelPaddingLeft + sprite.ex;
      y += sprite.pixelPaddingTop + sprite.ey;
      var scale = sprite.scale;
      if (sprite.group) {
        scale = sprite.group.scale;
      }
      var relativeX = sprite.pixelX + (x * cos(angle) - y * sin(angle)) * scale;
      var relativeY = sprite.pixelY + (x * sin(angle) + y * cos(angle)) * scale;
      if (sprite.dx) {
        relativeX += sprite.dx;
      }
      if (sprite.dy) {
        relativeY += sprite.dy;
      }
      x = relativeX;
      y = relativeY;
      sprite = sprite.parent;
    }
  }
  return { x, y };
}
function spritePointToSprite(point, sprite, toSprite) {
  return svgPointToSprite(spritePointToSvg(point, sprite), toSprite);
}
function svgRectToSprite(rect, sprite) {
  var p1 = svgPointToSprite(rect, sprite);
  var p2 = svgPointToSprite({ x: rect.x + rect.width, y: rect.y + rect.height }, sprite);
  return { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
}
function spriteRectToSvg(rect, sprite) {
  var p1 = spritePointToSvg(rect, sprite);
  var p2 = spritePointToSvg({ x: rect.x + rect.width, y: rect.y + rect.height }, sprite);
  return { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
}
function documentPointToSvg(point, svgContainer, cssScale) {
  try {
    var bbox = svgContainer.getBoundingClientRect();
    if (!isNumber(cssScale)) {
      cssScale = 1;
    }
    return {
      "x": (point.x - bbox.left) / cssScale,
      "y": (point.y - bbox.top) / cssScale
    };
  } catch (e) {
    return point;
  }
}
function svgPointToDocument(point, svgContainer) {
  try {
    var bbox = svgContainer.getBoundingClientRect();
    return {
      "x": point.x + bbox.left,
      "y": point.y + bbox.top
    };
  } catch (e) {
    return point;
  }
}
function documentPointToSprite(point, sprite) {
  if (sprite && sprite.htmlContainer) {
    var svgPoint = documentPointToSvg(point, getValue(sprite.htmlContainer), sprite.svgContainer.cssScale);
    return svgPointToSprite(svgPoint, sprite);
  } else {
    return point;
  }
}
function spritePointToDocument(point, sprite) {
  if (sprite && sprite.htmlContainer) {
    var svgPoint = spritePointToSvg(point, sprite);
    return svgPointToDocument(svgPoint, getValue(sprite.htmlContainer));
  } else {
    return point;
  }
}
function width(element) {
  var cs = getComputedStyle(element);
  var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
  var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
  return element.clientWidth - paddingX - borderX;
}
function height(element) {
  var cs = getComputedStyle(element);
  var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
  var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);
  return element.clientHeight - paddingY - borderY;
}
function decimalPlaces(number) {
  var match = ("" + number).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) {
    return 0;
  }
  return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
}
var urlRegexp = /^([a-zA-Z][a-zA-Z0-9\+\.\-]*:)?(?:(\/\/)([^\@]+\@)?([^\/\?\#\:]*)(\:[0-9]+)?)?([^\?\#]*)(\?[^\#]*)?(\#.*)?$/;
function parseUrl(url) {
  var match = urlRegexp.exec(url);
  return {
    protocol: match && match[1] || "",
    separator: match && match[2] || "",
    authority: match && match[3] || "",
    domain: match && match[4] || "",
    port: match && match[5] || "",
    path: match && match[6] || "",
    query: match && match[7] || "",
    hash: match && match[8] || ""
  };
}
function serializeUrl(url) {
  return url.protocol + url.separator + url.authority + url.domain + url.port + url.path + url.query + url.hash;
}
function isRelativeUrl(url) {
  return url.protocol === "" && url.separator === "" && url.authority === "" && url.domain === "" && url.port === "";
}
function joinUrl(left, right) {
  var parsedLeft = parseUrl(left);
  var parsedRight = parseUrl(right);
  if (isRelativeUrl(parsedLeft)) {
    throw new Error("Left URL is not absolute");
  }
  if (isRelativeUrl(parsedRight)) {
    if (parsedRight.path !== "") {
      if (parsedRight.path[0] === "/") {
        parsedLeft.path = parsedRight.path;
      } else {
        var leftPath = parsedLeft.path.split(/\//);
        var rightPath = parsedRight.path.split(/\//);
        if (leftPath.length === 0) {
          if (rightPath.length !== 0) {
            leftPath.push("");
          }
        } else if (leftPath.length > 1) {
          leftPath.pop();
        }
        pushAll(leftPath, rightPath);
        parsedLeft.path = leftPath.join("/");
        if (parsedLeft.path !== "" && parsedLeft.path[0] !== "/") {
          throw new Error("URL path must start with /");
        }
      }
    }
    parsedLeft.query = parsedRight.query;
    parsedLeft.hash = parsedRight.hash;
    return serializeUrl(parsedLeft);
  } else {
    return serializeUrl(parsedRight);
  }
}
function isIE() {
  return !!window.MSInputMethodContext && !!document.documentMode;
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/Ease.js
var Ease_exports = {};
__export(Ease_exports, {
  bounceIn: () => bounceIn,
  bounceInOut: () => bounceInOut,
  bounceOut: () => bounceOut,
  circleIn: () => circleIn,
  circleInOut: () => circleInOut,
  circleOut: () => circleOut,
  cubicIn: () => cubicIn,
  cubicInOut: () => cubicInOut,
  cubicOut: () => cubicOut,
  elasticIn: () => elasticIn,
  elasticInOut: () => elasticInOut,
  elasticOut: () => elasticOut,
  expIn: () => expIn,
  expInOut: () => expInOut,
  expOut: () => expOut,
  linear: () => linear,
  polyIn: () => polyIn,
  polyIn3: () => polyIn3,
  polyInOut: () => polyInOut,
  polyInOut3: () => polyInOut3,
  polyOut: () => polyOut,
  polyOut3: () => polyOut3,
  quadIn: () => quadIn,
  quadInOut: () => quadInOut,
  quadOut: () => quadOut,
  sinIn: () => sinIn,
  sinInOut: () => sinInOut,
  sinOut: () => sinOut
});
function linear(t) {
  return +t;
}
registry.registeredClasses["ease.linear"] = linear;
function quadIn(t) {
  return t * t;
}
registry.registeredClasses["ease.quadIn"] = quadIn;
function quadOut(t) {
  return t * (2 - t);
}
registry.registeredClasses["ease.quadOut"] = quadOut;
function quadInOut(t) {
  t *= 2;
  return (t <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}
registry.registeredClasses["ease.quadInOut"] = quadInOut;
function polyIn(t, e) {
  return Math.pow(t, e);
}
registry.registeredClasses["ease.polyIn"] = polyIn;
function polyOut(t, e) {
  return 1 - Math.pow(1 - t, e);
}
registry.registeredClasses["ease.polyOut"] = polyOut;
function polyInOut(t, e) {
  t *= 2;
  return (t <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
}
registry.registeredClasses["ease.polyInOut"] = polyInOut;
function polyIn3(t) {
  return polyIn(t, 3);
}
registry.registeredClasses["ease.polyIn3"] = polyIn3;
function polyOut3(t) {
  return polyOut(t, 3);
}
registry.registeredClasses["ease.polyOut3"] = polyOut3;
function polyInOut3(t) {
  return polyInOut(t, 3);
}
registry.registeredClasses["ease.polyInOut3"] = polyInOut3;
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}
registry.registeredClasses["ease.expIn"] = expIn;
function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}
registry.registeredClasses["ease.expOut"] = expOut;
function expInOut(t) {
  t *= 2;
  return (t <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}
registry.registeredClasses["ease.expInOut"] = expInOut;
function sinIn(t) {
  return 1 - Math.cos(t * HALFPI);
}
registry.registeredClasses["ease.sinIn"] = sinIn;
function sinOut(t) {
  return Math.sin(t * HALFPI);
}
registry.registeredClasses["ease.sinOut"] = sinOut;
function sinInOut(t) {
  return (1 - Math.cos(PI * t)) / 2;
}
registry.registeredClasses["ease.sinInOut"] = sinInOut;
function cubicIn(t) {
  return t * t * t;
}
registry.registeredClasses["ease.cubicIn"] = cubicIn;
function cubicOut(t) {
  return --t * t * t + 1;
}
registry.registeredClasses["ease.cubicOut"] = cubicOut;
function cubicInOut(t) {
  t *= 2;
  return (t <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
registry.registeredClasses["ease.cubicInOut"] = cubicInOut;
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
registry.registeredClasses["ease.circleIn"] = circleIn;
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
registry.registeredClasses["ease.circleOut"] = circleOut;
function circleInOut(t) {
  t *= 2;
  return (t <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}
registry.registeredClasses["ease.circleInOut"] = circleInOut;
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
registry.registeredClasses["ease.bounceIn"] = bounceIn;
function bounceOut(t) {
  t = +t;
  return t < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
registry.registeredClasses["ease.bounceOut"] = bounceOut;
function bounceInOut(t) {
  t *= 2;
  return (t <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}
registry.registeredClasses["ease.bounceInOut"] = bounceInOut;
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3 / tau;
var s = Math.asin(1 / amplitude) * period;
function elasticIn(t) {
  return amplitude * Math.pow(2, 10 * --t) * Math.sin((s - t) / period);
}
registry.registeredClasses["ease.elasticIn"] = elasticIn;
function elasticOut(t) {
  return 1 - amplitude * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / period);
}
registry.registeredClasses["ease.elasticOut"] = elasticOut;
function elasticInOut(t) {
  t = t * 2 - 1;
  return (t < 0 ? amplitude * Math.pow(2, 10 * t) * Math.sin((s - t) / period) : 2 - amplitude * Math.pow(2, -10 * t) * Math.sin((s + t) / period)) / 2;
}
registry.registeredClasses["ease.elasticInOut"] = elasticInOut;

// node_modules/@amcharts/amcharts4/.internal/core/SpriteState.js
var SpriteState = (
  /** @class */
  function(_super) {
    __extends(SpriteState2, _super);
    function SpriteState2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.transitionDuration = 0;
      _this.transitionEasing = cubicOut;
      _this.properties = {};
      _this.propertyFields = {};
      _this.filters = new List();
      _this.isTemplate = false;
      _this.className = "SpriteState";
      _this._disposers.push(new ListDisposer(_this.filters));
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(SpriteState2.prototype, "adapter", {
      /**
       * Holds Adapter.
       */
      get: function() {
        var _this = this;
        if (!this._adapterO) {
          this._adapterO = new Adapter(this);
          this._adapterO.events.on("inserted", function(ev) {
            _this[ev.newValue.key] = _this[ev.newValue.key];
          }, void 0, false);
          this._adapterO.events.on("removed", function(ev) {
            _this[ev.newValue.key] = _this[ev.newValue.key];
          }, void 0, false);
        }
        return this._adapterO;
      },
      enumerable: true,
      configurable: true
    });
    SpriteState2.prototype.getPropertyValue = function(propertyName) {
      var propValue = this.properties[propertyName];
      var sprite = this.sprite;
      if (sprite) {
        var fieldName = this.propertyFields[propertyName];
        if (hasValue(fieldName)) {
          if (sprite.dataItem) {
            propValue = sprite.dataItem.dataContext[fieldName];
          }
          if (propValue == void 0) {
            propValue = "__unset";
          }
        }
        if (!hasValue(propValue)) {
          var spriteValue = sprite.getPropertyValue(propertyName);
          if (this._adapterO) {
            propValue = this._adapterO.apply(propertyName, spriteValue);
          } else {
            propValue = spriteValue;
          }
          if (propValue == spriteValue) {
            propValue = void 0;
          }
        } else {
          if (this._adapterO) {
            propValue = this._adapterO.apply(propertyName, propValue);
          }
        }
      }
      return propValue;
    };
    SpriteState2.prototype.copyFrom = function(source) {
      if (source && source != this) {
        this.transitionDuration = source.transitionDuration;
        this.transitionEasing = source.transitionEasing;
        copyProperties(source.properties, this.properties);
        copyProperties(source.propertyFields, this.propertyFields);
        this.filters.copyFrom(source.filters);
        if (source._adapterO) {
          this.adapter.copyFrom(source._adapterO);
        }
      }
    };
    Object.defineProperty(SpriteState2.prototype, "allValues", {
      /**
       * Returns all values that should be applied by the SpriteState.
       *
       * It takes adapters into account.
       *
       * @ignore Exclude from docs
       * @return Properties
       * @todo Add adapter values
       * @todo proper type this["_properties"]
       */
      get: function() {
        var _this = this;
        var res = {};
        each2(this.properties, function(prop, value) {
          res[prop] = _this.getPropertyValue(prop);
        });
        if (this._adapterO) {
          var keys = this._adapterO.keys();
          each2(keys, function(_x, prop) {
            var value = _this.getPropertyValue(prop);
            res[prop] = value;
          });
        }
        var propertyFields = this.propertyFields;
        each2(propertyFields, function(prop) {
          var value = _this.getPropertyValue(prop);
          res[prop] = value;
        });
        return res;
      },
      enumerable: true,
      configurable: true
    });
    SpriteState2.prototype.reset = function() {
      this.properties = {};
      this.filters.clear();
    };
    SpriteState2.prototype.processConfig = function(config) {
      if (hasValue(config) && hasValue(config["properties"])) {
        each2(config["properties"], function(key, value) {
          if (isString(value)) {
            if (value.match(/^[0-9.\-]+\%$/)) {
              config["properties"][key] = percent(toNumber(value));
            } else if (value.match(/^\#[0-9abcdef]{3,}$/i)) {
              config["properties"][key] = toColor(value);
            }
          }
        });
      }
      _super.prototype.processConfig.call(this, config);
    };
    SpriteState2.prototype.asFunction = function(field) {
      return field == "transitionEasing" || _super.prototype.asIs.call(this, field);
    };
    return SpriteState2;
  }(BaseObject)
);
registry.registeredClasses["SpriteState"] = SpriteState;

// node_modules/@amcharts/amcharts4/.internal/core/SpriteEvents.js
var SpriteEventDispatcher = (
  /** @class */
  function(_super) {
    __extends(SpriteEventDispatcher2, _super);
    function SpriteEventDispatcher2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._interactionEvents = new Dictionary();
      return _this;
    }
    SpriteEventDispatcher2.prototype._dispatchSpriteEvent = function(ev) {
      if (this.target.disabled || this.target.isTemplate) {
        return;
      }
      if (this.target.events.isEnabled(ev.type)) {
        var imev = merge(ev, {
          target: this.target
        });
        this.target.events.dispatchImmediately(imev.type, imev);
      }
    };
    SpriteEventDispatcher2.prototype._dispatchSpritePointEvent = function(ev) {
      if (this.target.disabled || this.target.isTemplate) {
        return;
      }
      if (this.target.events.isEnabled(ev.type)) {
        var imev = merge(ev, {
          target: this.target,
          spritePoint: ev.point ? documentPointToSprite(ev.point, this.target) : void 0,
          svgPoint: this.target.getSvgPoint(ev.point)
        });
        this.target.events.dispatchImmediately(imev.type, imev);
      }
    };
    SpriteEventDispatcher2.prototype._addInteractionObjectEvent = function(type, callback, context, shouldClone) {
      var _this = this;
      var key = shouldClone + "-" + type;
      var counter = this._interactionEvents.insertKeyIfEmpty(key, function() {
        var disposer = _this.target.interactions.events.on(type, callback, context, shouldClone);
        return new CounterDisposer(function() {
          _this._interactionEvents.removeKey(key);
          disposer.dispose();
        });
      });
      return counter.increment();
    };
    SpriteEventDispatcher2.prototype._on = function(once, type, callback, context, shouldClone, dispatch) {
      var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);
      var disposers = [info.disposer];
      switch (type) {
        case "hit":
        case "track":
        case "doublehit":
        case "wheel":
        case "wheelup":
        case "wheeldown":
        case "wheelleft":
        case "wheelright":
          disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpritePointEvent, this, shouldClone));
          break;
        case "rightclick":
        case "down":
        case "up":
        case "drag":
        case "dragged":
        case "dragstart":
        case "dragstop":
        case "over":
        case "out":
        case "swipe":
        case "swipeleft":
        case "swiperight":
        case "resize":
        case "focus":
        case "blur":
        case "toggled":
          disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpriteEvent, this, shouldClone));
          break;
      }
      switch (type) {
        case "hit":
        case "doublehit":
        case "rightclick":
        case "down":
        case "up":
          this.target.clickable = true;
          break;
        case "toggled":
          this.target.togglable = true;
          break;
        case "drag":
        case "dragstart":
        case "dragstop":
          this.target.draggable = true;
          break;
        case "track":
          this.target.trackable = true;
          break;
        case "resize":
          this.target.resizable = true;
          break;
        case "swipe":
        case "swipeleft":
        case "swiperight":
          this.target.swipeable = true;
          break;
        case "wheel":
        case "wheelup":
        case "wheeldown":
        case "wheelleft":
        case "wheelright":
          this.target.wheelable = true;
          break;
        case "over":
          this.target.hoverable = true;
        case "out":
          this.target.hoverable = true;
          break;
        case "focus":
        case "blur":
          this.target.focusable = true;
          break;
      }
      info.disposer = new MultiDisposer(disposers);
      return info;
    };
    return SpriteEventDispatcher2;
  }(TargetedEventDispatcher)
);

// node_modules/@amcharts/amcharts4/.internal/core/defs/SVGDefaults.js
var SVGDefaults = (
  /** @class */
  function() {
    function SVGDefaults2() {
    }
    SVGDefaults2.opacity = 1;
    SVGDefaults2.strokeOpacity = 1;
    SVGDefaults2.strokeWidth = 1;
    SVGDefaults2.fillOpacity = 1;
    SVGDefaults2.fill = color("#000000");
    SVGDefaults2.stroke = color("#000000");
    SVGDefaults2.focusable = void 0;
    SVGDefaults2.tabindex = 0;
    return SVGDefaults2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/Options.js
var options = {
  verbose: true,
  commercialLicense: false,
  classNamePrefix: "amcharts-",
  autoSetClassName: false,
  minPolylineStep: 0.5,
  onlyShowOnViewport: false,
  queue: false,
  autoDispose: false,
  licenses: [],
  suppressErrors: false,
  suppressWarnings: false,
  animationsEnabled: true,
  nonce: "",
  deferredDelay: 100,
  disableHoverOnTransform: "never",
  pixelPerfectPrecision: 0
};

// node_modules/@amcharts/amcharts4/.internal/core/utils/DOM.js
var SVGNS = "http://www.w3.org/2000/svg";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XLINK = "http://www.w3.org/1999/xlink";
function addEventListener(dom, type, listener, options2) {
  dom.addEventListener(type, listener, options2 || false);
  return new Disposer(function() {
    dom.removeEventListener(type, listener, options2 || false);
  });
}
function getElement(el) {
  if (isString(el)) {
    var e = document.getElementById(el);
    if (e == null) {
      e = document.getElementsByClassName(el)[0];
    }
    if (e instanceof HTMLElement) {
      return e;
    }
  } else if (el instanceof HTMLElement) {
    return el;
  }
}
function addClass(element, className) {
  if (!element) {
    return;
  }
  if (element.classList) {
    var classes = className.split(" ");
    each(classes, function(name) {
      element.classList.add(name);
    });
  } else {
    var currentClassName = element.getAttribute("class");
    if (currentClassName) {
      element.setAttribute("class", currentClassName.split(" ").filter(function(item) {
        return item !== className;
      }).join(" ") + " " + className);
    } else {
      element.setAttribute("class", className);
    }
  }
}
function removeClass(element, className) {
  if (!element) {
    return;
  }
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var currentClassName = element.getAttribute("class");
    if (currentClassName) {
      element.setAttribute("class", currentClassName.split(" ").filter(function(item) {
        return item !== className;
      }).join(" "));
    }
  }
}
function setStyle(element, property, value) {
  element.style[property] = value;
}
function getComputedStyle2(element, property) {
  if (element.currentStyle) {
    return element.currentStyle[property];
  }
  return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
}
function blur() {
  if (document.activeElement && document.activeElement != document.body) {
    if (document.activeElement.blur) {
      document.activeElement.blur();
    } else {
      var input = document.createElement("button");
      input.style.position = "fixed";
      input.style.top = "0px";
      input.style.left = "-10000px";
      document.body.appendChild(input);
      input.focus();
      input.blur();
      document.body.removeChild(input);
    }
  }
}
function focus(element) {
  if (element instanceof HTMLElement) {
    element.focus();
  } else {
    var input = document.createElement("input");
    var fo = document.createElementNS(SVGNS, "foreignObject");
    fo.appendChild(input);
    element.appendChild(fo);
    input.focus();
    input.disabled = true;
    fo.remove();
  }
}
function outerHTML(element) {
  if (element.outerHTML) {
    return element.outerHTML;
  } else {
    var twrap = document.createElement("div");
    var tnode = element.cloneNode(true);
    twrap.appendChild(tnode);
    var content = twrap.innerHTML;
    return content;
  }
}
function isElement(el) {
  return el instanceof Object && el && el.nodeType === 1;
}
function contains2(a, b) {
  var cursor = b;
  while (true) {
    if (a === cursor) {
      return true;
    } else if (cursor.parentNode == null) {
      if (cursor.host == null) {
        return false;
      } else {
        cursor = cursor.host;
      }
    } else {
      cursor = cursor.parentNode;
    }
  }
}
function getShadowRoot(a) {
  var cursor = a;
  while (true) {
    if (cursor.parentNode == null) {
      if (cursor.host != null) {
        return cursor;
      } else {
        return null;
      }
    } else {
      cursor = cursor.parentNode;
    }
  }
}
function getRoot(a) {
  var owner = a.ownerDocument;
  var cursor = a;
  while (true) {
    if (cursor.parentNode == null) {
      if (cursor === owner || cursor.host != null) {
        return cursor;
      } else {
        return null;
      }
    } else {
      cursor = cursor.parentNode;
    }
  }
}
function eventTarget(event) {
  if (typeof event.composedPath === "function") {
    return event.composedPath()[0];
  } else {
    return event.target;
  }
}
function copyAttributes(source, target) {
  each(source.attributes, function(attr) {
    if (attr.value != null) {
      target.setAttribute(attr.name, attr.value);
    }
  });
}
function fixPixelPerfect(el) {
  readFrame(function() {
    try {
      var rect = el.getBoundingClientRect();
      var left_1 = rect.left - Math.round(rect.left);
      var top_1 = rect.top - Math.round(rect.top);
      if (left_1 !== 0) {
        writeFrame(function() {
          el.style.left = left_1 + "px";
        });
      }
      if (top_1 !== 0) {
        writeFrame(function() {
          el.style.top = top_1 + "px";
        });
      }
    } catch (e) {
    }
  });
}
var rootStylesheet;
function getStylesheet(element) {
  if (element == null) {
    if (!hasValue(rootStylesheet)) {
      var e = document.createElement("style");
      e.type = "text/css";
      if (options.nonce != "") {
        e.setAttribute("nonce", options.nonce);
      }
      document.head.appendChild(e);
      rootStylesheet = e.sheet;
    }
    return rootStylesheet;
  } else {
    var e = document.createElement("style");
    e.type = "text/css";
    if (options.nonce != "") {
      e.setAttribute("nonce", options.nonce);
    }
    element.appendChild(e);
    return e.sheet;
  }
}
function appendStylesheet(root, selector) {
  var index = root.cssRules.length;
  root.insertRule(selector + "{}", index);
  return root.cssRules[index];
}
var StyleRule = (
  /** @class */
  function(_super) {
    __extends(StyleRule2, _super);
    function StyleRule2(element, selector, styles) {
      var _this = this;
      var root = getStylesheet(element);
      _this = _super.call(this, function() {
        var index = indexOf(root.cssRules, _this._rule);
        if (index === -1) {
          throw new Error("Could not dispose StyleRule");
        } else {
          root.deleteRule(index);
        }
      }) || this;
      _this._rule = appendStylesheet(root, selector);
      each2(styles, function(key, value) {
        _this.setStyle(key, value);
      });
      return _this;
    }
    Object.defineProperty(StyleRule2.prototype, "selector", {
      /**
       * @return CSS selector
       */
      get: function() {
        return this._rule.selectorText;
      },
      /**
       * A CSS selector text.
       *
       * E.g.: `.myClass p`
       *
       * @param selector  CSS selector
       */
      set: function(selector) {
        this._rule.selectorText = selector;
      },
      enumerable: true,
      configurable: true
    });
    StyleRule2.prototype._setVendorPrefixName = function(name, value) {
      var style = this._rule.style;
      style.setProperty("-webkit-" + name, value, "");
      style.setProperty("-moz-" + name, value, "");
      style.setProperty("-ms-" + name, value, "");
      style.setProperty("-o-" + name, value, "");
      style.setProperty(name, value, "");
    };
    StyleRule2.prototype.setStyle = function(name, value) {
      if (name === "transition") {
        this._setVendorPrefixName(name, value);
      } else {
        this._rule.style.setProperty(name, value, "");
      }
    };
    return StyleRule2;
  }(Disposer)
);
var styleId = 0;
var StyleClass = (
  /** @class */
  function(_super) {
    __extends(StyleClass2, _super);
    function StyleClass2(element, styles, name) {
      var _this = this;
      var className = !hasValue(name) ? "__style_" + ++styleId + "__" : name;
      _this = _super.call(this, element, "." + className, styles) || this;
      _this._className = className;
      return _this;
    }
    Object.defineProperty(StyleClass2.prototype, "className", {
      /**
       * @return Class name
       */
      get: function() {
        return this._className;
      },
      /**
       * Class name.
       *
       * @param name  Class name
       */
      set: function(name) {
        this._className = name;
        this.selector = "." + name;
      },
      enumerable: true,
      configurable: true
    });
    StyleClass2.prototype.toString = function() {
      return this._className;
    };
    return StyleClass2;
  }(StyleRule)
);
function ready(f) {
  if (document.readyState !== "loading") {
    f();
  } else {
    var listener_1 = function() {
      if (document.readyState !== "loading") {
        document.removeEventListener("readystatechange", listener_1);
        f();
      }
    };
    document.addEventListener("readystatechange", listener_1);
  }
}
function findFont(element) {
  var font = getComputedStyle2(element, "font-family");
  if (!font) {
    var parent_1 = element.parentElement || element.parentNode;
    if (parent_1) {
      return findFont(parent_1);
    } else {
      return void 0;
    }
  } else {
    return font;
  }
}
function findFontSize(element) {
  var font = getComputedStyle2(element, "font-size");
  if (!font) {
    var parent_2 = element.parentElement || element.parentNode;
    if (parent_2) {
      return findFontSize(parent_2);
    } else {
      return void 0;
    }
  } else {
    return font;
  }
}
function isElementInViewport(el, viewportTarget) {
  var rect = el.getBoundingClientRect();
  var targets = isArray(viewportTarget) ? viewportTarget : viewportTarget ? [viewportTarget] : [];
  if (targets.length) {
    for (var i = 0; i < targets.length; i++) {
      var target = targets[i];
      if (!isElementInViewport(target)) {
        return false;
      }
      var viewportRect = target.getBoundingClientRect();
      if (rect.top >= 0 && rect.left >= 0 && rect.top <= viewportRect.top + viewportRect.height && rect.left <= viewportRect.left + viewportRect.width) {
        return true;
      }
    }
    return false;
  }
  return rect.top >= 0 && rect.left >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth);
}

// node_modules/@amcharts/amcharts4/.internal/core/rendering/AMElement.js
var AMElement = (
  /** @class */
  function() {
    function AMElement2(element) {
      this._isDisposed = false;
      this._x = 0;
      this._y = 0;
      this._rotationY = 0;
      this._rotationX = 0;
      this._rotation = 0;
      this._scale = 1;
      if (typeof element === "string") {
        this.node = document.createElementNS(SVGNS, element);
      } else {
        this.node = element;
      }
    }
    AMElement2.prototype.removeNode = function() {
      if (this.node) {
        if (this.node.parentNode) {
          this.node.parentNode.removeChild(this.node);
        }
      }
    };
    Object.defineProperty(AMElement2.prototype, "transformString", {
      /**
       * Returns `transform` attribute of the element.
       *
       * @ignore Exclude from docs
       * @return Transform attribute value
       */
      get: function() {
        if (this.node) {
          return this._transformString;
        }
      },
      enumerable: true,
      configurable: true
    });
    AMElement2.prototype.transform = function() {
      var transfromString = "translate(" + this._x + "," + this._y + ")";
      if (this._scale != 1) {
        transfromString += (transfromString ? " " : "") + "scale(" + this._scale + ")";
      }
      if (this._rotation != 0) {
        var rotateString = "rotate(" + this._rotation + ")";
        if (this._rotationX && this._rotationY) {
          rotateString = "rotate(" + this._rotation + " " + this._rotationX + " " + this._rotationY + ")";
        }
        transfromString += (transfromString ? " " : "") + rotateString;
      }
      this._transformString = transfromString;
      this.node.setAttribute("transform", transfromString);
    };
    AMElement2.prototype.getBBox = function() {
      var bbox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      if (this.node && this.node.parentNode) {
        try {
          var svgbbox = this.node.getBBox();
          bbox.x = svgbbox.x;
          bbox.y = svgbbox.y;
          bbox.width = svgbbox.width;
          bbox.height = svgbbox.height;
        } catch (err) {
        }
      }
      return bbox;
    };
    AMElement2.prototype.moveTo = function(point) {
      if (point) {
        var x = point.x;
        var y = point.y;
        if (this._x != x || this._y != y) {
          this._x = x;
          this._y = y;
          this.transform();
        }
      }
    };
    Object.defineProperty(AMElement2.prototype, "content", {
      /**
       * Returns element's contents as SVG markup.
       *
       * @return Contents
       */
      get: function() {
        return this.node.innerHTML || "";
      },
      /**
       * Element's SVG contents.
       *
       * @param value Contents
       */
      set: function(value) {
        this.node.innerHTML = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "textContent", {
      /**
       * @return Text contents
       */
      get: function() {
        return this.node.textContent || "";
      },
      /**
       * Text contents of the SVG element.
       *
       * @param value Text contents
       */
      set: function(value) {
        this.node.textContent = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "x", {
      /**
       * @return X coordinate (px)
       */
      get: function() {
        return this._x;
      },
      /**
       * Element's X position in pixels.
       *
       * @param value  X coordinate (px)
       */
      set: function(value) {
        if (this._x != value) {
          this._x = value;
          this.transform();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "y", {
      /**
       * @return Y coordinate (px)
       */
      get: function() {
        return this._y;
      },
      /**
       * Element's Y position in pixels.
       *
       * @param value Y coordinate (px)
       */
      set: function(value) {
        if (this._y != value) {
          this._y = value;
          this.transform();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "rotation", {
      /**
       * @return Rotation
       */
      get: function() {
        return this._rotation;
      },
      /**
       * Element's rotation in degrees.
       *
       * @param value Rotation
       */
      set: function(angle) {
        if (this._rotation != angle) {
          this._rotation = angle;
          this.transform();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "rotationX", {
      /**
       * @ignore
       */
      get: function() {
        return this._rotationX;
      },
      /**
       * @ignore
       */
      set: function(x) {
        if (this._rotationX != x) {
          this._rotationX = x;
          this.transform();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "rotationY", {
      /**
       * @ignore
       */
      get: function() {
        return this._rotationY;
      },
      /**
       * @ignore
       */
      set: function(y) {
        if (this._rotationY != y) {
          this._rotationY = y;
          this.transform();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AMElement2.prototype, "scale", {
      /**
       * @return Scale
       */
      get: function() {
        return this._scale;
      },
      /**
       * Element's scale where 1 is original size.
       *
       * Setting to 0.5 will reduce element's size by 50%, 2 will make element
       * twice as large, etc.
       *
       * @param value Scale
       */
      set: function(value) {
        if (this._scale != value) {
          this._scale = value;
          this.transform();
        }
      },
      enumerable: true,
      configurable: true
    });
    AMElement2.prototype.removeAttr = function(attribute) {
      this.node.removeAttribute(attribute);
    };
    AMElement2.prototype.attr = function(attributes) {
      var _this = this;
      each2(attributes, function(attributeName, attributeValue) {
        if (!hasValue(attributeValue)) {
          _this.node.removeAttribute(attributeName);
        } else {
          _this.node.setAttribute(attributeName, attributeValue);
        }
      });
      return this;
    };
    AMElement2.prototype.getAttr = function(attribute) {
      return this.node.getAttribute(attribute);
    };
    AMElement2.prototype.attrNS = function(ns, attribute, value) {
      this.node.setAttributeNS(ns, attribute, value);
      return this;
    };
    AMElement2.prototype.getAttrNS = function(ns, attribute) {
      return this.node.getAttributeNS(ns, attribute);
    };
    AMElement2.prototype.removeStyle = function(attribute) {
      this.node.style[attribute] = null;
      delete this.node.style[attribute];
    };
    AMElement2.prototype.getStyle = function(attribute) {
      return this.node.style[attribute];
    };
    AMElement2.prototype.addStyle = function(attributes) {
      var _this = this;
      each2(attributes, function(attributeName, attributeValue) {
        if (!hasValue(attributeValue)) {
          _this.removeStyle(attributeName);
        } else {
          _this.node.style[attributeName] = attributeValue;
        }
      });
      return this;
    };
    AMElement2.prototype.addClass = function(name) {
      addClass(this.node, name);
    };
    AMElement2.prototype.removeClass = function(name) {
      removeClass(this.node, name);
    };
    AMElement2.prototype.setClass = function(name) {
      this.node.setAttribute("class", name);
    };
    AMElement2.prototype.removeChildNodes = function() {
      while (this.node.childNodes.length > 0) {
        this.node.removeChild(this.node.firstChild);
      }
    };
    AMElement2.prototype.isDisposed = function() {
      return this._isDisposed;
    };
    AMElement2.prototype.dispose = function() {
      this.removeNode();
    };
    return AMElement2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/rendering/Group.js
var Group = (
  /** @class */
  function(_super) {
    __extends(Group2, _super);
    function Group2(elementName) {
      return _super.call(this, elementName) || this;
    }
    Group2.prototype.add = function(element) {
      if (element) {
        this.node.appendChild(element.node);
      }
    };
    Group2.prototype.addToBack = function(element) {
      if (element) {
        var first = this.node.childNodes[0];
        if (first) {
          if (first != element.node) {
            this.node.insertBefore(element.node, first);
          }
        } else {
          this.node.appendChild(element.node);
        }
      }
    };
    Group2.prototype.removeElement = function(element) {
      if (element) {
        try {
          if (element.node && element.node.parentNode == this.node) {
            this.node.removeChild(element.node);
          }
        } catch (err) {
        }
      }
    };
    Group2.prototype.hasChild = function(element) {
      for (var i = 0; i < this.node.childNodes.length; i++) {
        if (this.node.childNodes[i] == element.node) {
          return true;
        }
      }
      return false;
    };
    Object.defineProperty(Group2.prototype, "content", {
      /**
       * @return SVG markup
       */
      get: function() {
        return this.node.innerHTML;
      },
      /**
       * Content of the group element.
       *
       * Can be used to add a lot of proprietary SVG markup into group.
       *
       * @param value  SVG markup
       */
      set: function(value) {
        this.node.innerHTML = value;
      },
      enumerable: true,
      configurable: true
    });
    Group2.prototype.removeChildren = function() {
      if (this.node.childNodes) {
        while (this.node.childNodes.length > 0) {
          var childNode = this.node.firstChild;
          if (childNode && childNode.parentNode) {
            childNode.parentNode.removeChild(childNode);
          }
        }
      }
    };
    Group2.prototype.removeChildrenByTag = function(tag) {
      if (this.node.childNodes) {
        var remove2 = this.node.getElementsByTagName(tag);
        for (var i = 0; i < remove2.length; i++) {
          this.node.removeChild(remove2[i]);
        }
      }
    };
    return Group2;
  }(AMElement)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/InterfaceColorSet.js
var InterfaceColorSet = (
  /** @class */
  function(_super) {
    __extends(InterfaceColorSet2, _super);
    function InterfaceColorSet2() {
      var _this = _super.call(this) || this;
      _this._purposes = {
        stroke: color("#e5e5e5"),
        fill: color("#f3f3f3"),
        primaryButton: color("#6794dc"),
        primaryButtonHover: color("#6771dc"),
        primaryButtonDown: color("#68dc75"),
        primaryButtonActive: color("#68dc75"),
        primaryButtonText: color("#FFFFFF"),
        primaryButtonStroke: color("#FFFFFF"),
        secondaryButton: color("#d9d9d9"),
        secondaryButtonHover: color("#d9d9d9").brighten(-0.25),
        secondaryButtonDown: color("#d9d9d9").brighten(-0.35),
        secondaryButtonActive: color("#d9d9d9").brighten(0.35),
        secondaryButtonText: color("#000000"),
        secondaryButtonStroke: color("#FFFFFF"),
        grid: color("#000000"),
        background: color("#ffffff"),
        alternativeBackground: color("#000000"),
        text: color("#000000"),
        alternativeText: color("#FFFFFF"),
        disabledBackground: color("#999999"),
        positive: color("#67dc75"),
        negative: color("#dc6788")
      };
      _this.className = "InterfaceColorSet";
      _this.applyTheme();
      return _this;
    }
    InterfaceColorSet2.prototype.debug = function() {
    };
    InterfaceColorSet2.prototype.getFor = function(purpose) {
      return this._purposes[purpose];
    };
    InterfaceColorSet2.prototype.setFor = function(purpose, color2) {
      this._purposes[purpose] = color2;
    };
    return InterfaceColorSet2;
  }(BaseObject)
);
registry.registeredClasses["InterfaceColorSet"] = InterfaceColorSet;

// node_modules/@amcharts/amcharts4/.internal/core/elements/PopupCSS.js
var rules = new Dictionary();
function PopupCSS_default(element, prefix) {
  if (!prefix) {
    prefix = "ampopup";
  }
  var cs = new InterfaceColorSet();
  var fg = cs.getFor("text");
  var bg = cs.getFor("background");
  bg.alpha = 0.8;
  var abg = cs.getFor("alternativeBackground");
  abg.alpha = 0.05;
  var counter = rules.insertKeyIfEmpty(prefix, function() {
    var disposer = new MultiDisposer([
      new StyleRule(element, "." + prefix, {
        //"width": "100%",
        //"height": "100%",
        "overflow": "visible",
        "position": "absolute",
        "top": "0",
        "left": "0",
        "z-index": "2000"
      }),
      new StyleRule(element, "." + prefix + "-curtain", {
        "width": "100%",
        "height": "100%",
        "position": "absolute",
        "top": "0",
        "left": "0",
        "z-index": "2001",
        "background-color": bg.hex,
        "opacity": "0.5"
      }),
      new StyleRule(element, "." + prefix + "-header", {
        "display": "block",
        "width": "100%",
        "min-height": "1.8em",
        "background": abg.rgba
      }),
      new StyleRule(element, "." + prefix + "-title", {
        "font-weight": "bold",
        "font-size": "110%",
        "padding": "0.5em 1.2em 0.5em 1em"
      }),
      new StyleRule(element, "." + prefix + "-content", {
        /*"width": "100%",
        "height": "100%",*/
        // "padding": "2em 1em 1em 1em",
        "background": bg.hex,
        "background-color": bg.rgba,
        "color": fg.hex,
        "display": "inline-block",
        "position": "absolute",
        "top": "0",
        "left": "0",
        "max-width": "90%",
        "max-height": "90%",
        "overflow": "auto",
        "z-index": "2002"
      }),
      new StyleRule(element, "." + prefix + "-inside", {
        "padding": "1em"
      }),
      new StyleRule(element, "." + prefix + "-close", {
        "display": "block",
        "position": "absolute",
        "top": "0.3em",
        "right": "0.3em",
        "background-color": "rgb(100, 100, 100)",
        "background": "rgba(100, 100, 100, 0.1) url(data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=) no-repeat center",
        "background-size": "80%",
        "width": "1.2em",
        "height": "1.2em",
        "cursor": "pointer"
      })
    ]);
    return new CounterDisposer(function() {
      rules.removeKey(prefix);
      disposer.dispose();
    });
  });
  return counter.increment();
}

// node_modules/@amcharts/amcharts4/.internal/core/interaction/InteractionObjectEvents.js
var InteractionObjectEventDispatcher = (
  /** @class */
  function(_super) {
    __extends(InteractionObjectEventDispatcher2, _super);
    function InteractionObjectEventDispatcher2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._domEvents = {};
      return _this;
    }
    InteractionObjectEventDispatcher2.prototype._addDOMEvent = function(type, key, listener, context) {
      var _this = this;
      if (!this._domEvents[type]) {
        var callback_1 = function(e) {
          listener.call(context, key, e);
        };
        this.target.element.addEventListener(type, callback_1, false);
        this._domEvents[type] = new CounterDisposer(function() {
          delete _this._domEvents[type];
          _this.target.element.removeEventListener(type, callback_1, false);
        });
      }
      return this._domEvents[type].increment();
    };
    InteractionObjectEventDispatcher2.prototype._dispatchKeyboardEvent = function(key, ev) {
      if (this.target.events.isEnabled(key)) {
        this.target.events.dispatchImmediately(key, {
          type: key,
          target: this.target,
          event: ev
        });
      }
    };
    InteractionObjectEventDispatcher2.prototype._on = function(once, type, callback, context, shouldClone, dispatch) {
      var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);
      var disposers = [info.disposer];
      switch (type) {
        case "hit":
        case "doublehit":
        case "rightclick":
        case "down":
        case "up":
          this.target.clickable = true;
          break;
        case "drag":
        case "dragstart":
        case "dragstop":
          this.target.draggable = true;
          break;
        case "track":
          this.target.trackable = true;
          break;
        case "resize":
          this.target.resizable = true;
          break;
        case "swipe":
        case "swipeleft":
        case "swiperight":
          this.target.swipeable = true;
          break;
        case "wheel":
        case "wheelup":
        case "wheeldown":
        case "wheelleft":
        case "wheelright":
          this.target.wheelable = true;
          break;
        case "over":
        case "out":
          this.target.hoverable = true;
          break;
        case "focus":
        case "blur":
        case "focusin":
        case "focusout":
          this.target.focusable = true;
          break;
        case "keydown":
          disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
          break;
        case "keyup":
          disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
          break;
        case "keypress":
          disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
          break;
        case "input":
          disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
          break;
      }
      info.disposer = new MultiDisposer(disposers);
      return info;
    };
    return InteractionObjectEventDispatcher2;
  }(TargetedEventDispatcher)
);

// node_modules/@amcharts/amcharts4/.internal/core/interaction/InteractionObject.js
var InteractionObject = (
  /** @class */
  function(_super) {
    __extends(InteractionObject2, _super);
    function InteractionObject2(element) {
      var _this = _super.call(this) || this;
      _this._eventDispatcher = new InteractionObjectEventDispatcher(_this);
      _this.eventDisposers = new Dictionary();
      _this.replacedStyles = new Dictionary();
      _this._clickable = false;
      _this._contextMenuDisabled = false;
      _this._hoverable = false;
      _this._trackable = false;
      _this._draggable = false;
      _this._swipeable = false;
      _this._resizable = false;
      _this._wheelable = false;
      _this._inert = false;
      _this._isHover = false;
      _this.isRealHover = false;
      _this._isHoverByTouch = false;
      _this._isDown = false;
      _this._isFocused = false;
      _this._isTouchProtected = false;
      _this._inertiaOptions = new Dictionary();
      _this.inertias = new Dictionary();
      _this._hitOptions = {};
      _this._hoverOptions = {};
      _this._swipeOptions = {};
      _this._keyboardOptions = {};
      _this._mouseOptions = {};
      _this._cursorOptions = {
        "defaultStyle": [{
          "property": "cursor",
          "value": "default"
        }]
      };
      _this._disposers.push(_this._eventDispatcher);
      _this._element = element;
      _this.className = "InteractionObject";
      _this._disposers.push(new DictionaryDisposer(_this.inertias));
      _this._disposers.push(new DictionaryDisposer(_this.eventDisposers));
      _this.applyTheme();
      return _this;
    }
    ;
    Object.defineProperty(InteractionObject2.prototype, "events", {
      /**
       * An [[EventDispatcher]] instance which holds events for this object
       */
      get: function() {
        return this._eventDispatcher;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "isHover", {
      /**
       * @return Hovered?
       */
      get: function() {
        return this._isHover;
      },
      /**
       * Indicates if this element is currently hovered.
       *
       * @param value Hovered?
       */
      set: function(value) {
        if (this.isHover != value) {
          this._isHover = value;
          if (value) {
            getInteraction().overObjects.moveValue(this);
          } else {
            this.isRealHover = false;
            getInteraction().overObjects.removeValue(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "isHoverByTouch", {
      /**
       * @return Hovered?
       */
      get: function() {
        return this._isHoverByTouch;
      },
      /**
       * Indicates if this element is currently hovered.
       *
       * @param value Hovered?
       */
      set: function(value) {
        if (this.isHoverByTouch != value) {
          this._isHoverByTouch = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "overPointers", {
      /**
       * A list of pointers currently over the element.
       *
       * @see {@link Pointer}
       * @return List if pointers currently hovering the element
       */
      get: function() {
        if (!this._overPointers) {
          this._overPointers = new List();
        }
        return this._overPointers;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "isDown", {
      /**
       * @return Has down pointers?
       */
      get: function() {
        return this._isDown;
      },
      /**
       * Indicates if this element has currently any pointers pressing on it.
       *
       * @param value Has down pointers?
       */
      set: function(value) {
        if (this.isDown != value) {
          this._isDown = value;
          if (value) {
            getInteraction().downObjects.moveValue(this);
          } else {
            getInteraction().downObjects.removeValue(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "downPointers", {
      /**
       * A list of pointers currently pressing down on this element.
       *
       * @see {@link Pointer}
       * @return List of down pointers
       */
      get: function() {
        if (!this._downPointers) {
          this._downPointers = new List();
        }
        return this._downPointers;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "isFocused", {
      /**
       * @return Focused?
       */
      get: function() {
        return this._isFocused;
      },
      /**
       * Indicates if this element is currently focused.
       *
       * @param value Focused?
       */
      set: function(value) {
        if (this.isFocused != value) {
          this._isFocused = value;
          if (value) {
            getInteraction().focusedObject = this;
          } else {
            getInteraction().focusedObject = void 0;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "isTouchProtected", {
      /**
       * @ignore
       * @return Touch protected?
       */
      get: function() {
        return this._isTouchProtected;
      },
      /**
       * Indicates if this element is currently being protected from touch actions.
       *
       * @ignore
       * @param value Touch protected?
       */
      set: function(value) {
        if (this._isTouchProtected != value) {
          this._isTouchProtected = value;
          if (value) {
            getInteraction().unprepElement(this);
          } else if (this.draggable || this.swipeable || this.trackable || this.resizable) {
            getInteraction().prepElement(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "clickable", {
      /**
       * @return Clickable?
       */
      get: function() {
        return this._clickable;
      },
      /**
       * Is element clickable? Clickable elements will generate "hit" events when
       * clicked or tapped.
       *
       * @param value Clickable?
       */
      set: function(value) {
        if (this._clickable !== value) {
          this._clickable = value;
          getInteraction().processClickable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "contextMenuDisabled", {
      /**
       * @return Context menu disabled?
       */
      get: function() {
        return this._contextMenuDisabled;
      },
      /**
       * Should element prevent context menu to be displayed, e.g. when
       * right-clicked?
       *
       * @default false
       * @param value Context menu disabled?
       */
      set: function(value) {
        if (this._contextMenuDisabled !== value) {
          this._contextMenuDisabled = value;
          getInteraction().processContextMenu(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "hoverable", {
      /**
       * @return Hoverable?
       */
      get: function() {
        return this._hoverable;
      },
      /**
       * Indicates if element should generate hover events.
       *
       * @param value Hoverable?
       */
      set: function(value) {
        if (this._hoverable !== value) {
          this._hoverable = value;
          getInteraction().processHoverable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "trackable", {
      /**
       * @return Track pointer?
       */
      get: function() {
        return this._trackable;
      },
      /**
       * Indicates if pointer movement over element should be tracked.
       *
       * @param value Track pointer?
       */
      set: function(value) {
        if (this._trackable !== value) {
          this._trackable = value;
          getInteraction().processTrackable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "draggable", {
      /**
       * @return Draggable?
       */
      get: function() {
        return this._draggable;
      },
      /**
       * Indicates if element can be dragged. (moved)
       *
       * @param value Draggable?
       */
      set: function(value) {
        if (this._draggable !== value) {
          this._draggable = value;
          getInteraction().processDraggable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "swipeable", {
      /**
       * @return Track swipe?
       */
      get: function() {
        return this._swipeable;
      },
      /**
       * Indicates whether element should react to swipe gesture.
       *
       * @param value Track swipe?
       */
      set: function(value) {
        if (this._swipeable !== value) {
          this._swipeable = value;
          getInteraction().processSwipeable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "resizable", {
      /**
       * @return Resizeble?
       */
      get: function() {
        return this._resizable;
      },
      /**
       * Indicates if element can be resized.
       *
       * @param value Resizeable?
       */
      set: function(value) {
        if (this._resizable !== value) {
          this._resizable = value;
          getInteraction().processResizable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "wheelable", {
      /**
       * @return Track wheel?
       */
      get: function() {
        return this._wheelable;
      },
      /**
       * Indicates whether track moouse wheel rotation over element.
       *
       * @param value Track wheel?
       */
      set: function(value) {
        if (this._wheelable !== value) {
          this._wheelable = value;
          getInteraction().processWheelable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "inert", {
      /**
       * @return Inert?
       */
      get: function() {
        return this._inert;
      },
      /**
       * Indicates if element is inert, i.e. if it should carry movement momentum
       * after it is dragged and released.
       *
       * @param value Inert?
       */
      set: function(value) {
        if (this._inert !== value) {
          this._inert = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "focusable", {
      /**
       * @return Focusable?
       */
      get: function() {
        return this._focusable;
      },
      /**
       * Indicates if element can gain focus.
       *
       * @param value Focusable?
       */
      set: function(value) {
        if (this._focusable !== value) {
          this._focusable = value;
          if (this._focusable && this.tabindex == -1) {
            this._tabindex = 1;
          }
          getInteraction().processFocusable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "tabindex", {
      /**
       * @return Tab index
       */
      get: function() {
        return getValueDefault(this._tabindex, -1);
      },
      /**
       * Element's tab index.
       *
       * @param value Tab index
       */
      set: function(value) {
        if (this._tabindex !== value) {
          this._tabindex = value;
          if (value > -1) {
            this.focusable = true;
          }
          getInteraction().processFocusable(this);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "element", {
      /**
       * @return Element
       */
      get: function() {
        return this._element;
      },
      /**
       * A DOM element associated with this element.
       *
       * @param element Element
       */
      set: function(element) {
        this._element = element;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "originalPosition", {
      /**
       * @ignore Exclude from docs
       * @return Position.
       */
      get: function() {
        return this._originalPosition || { x: 0, y: 0 };
      },
      /**
       * Element's original position.
       *
       * @ignore Exclude from docs
       * @param value Position
       */
      set: function(value) {
        this._originalPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "originalScale", {
      /**
       * @return Scale
       */
      get: function() {
        return getValueDefault(this._originalScale, 1);
      },
      /**
       * Element's original scale.
       *
       * @ignore Exclude from docs
       * @param value Scale
       */
      set: function(value) {
        if (this._originalScale !== value) {
          this._originalScale = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "originalAngle", {
      /**
       * @return Angle
       */
      get: function() {
        return getValueDefault(this._originalAngle, 0);
      },
      /**
       * Element's original angle.
       *
       * @ignore Exclude from docs
       * @param value Angle
       */
      set: function(value) {
        if (this._originalAngle !== value) {
          this._originalAngle = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "inertiaOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("inertiaOptions", this._inertiaOptions);
        } else {
          return this._inertiaOptions;
        }
      },
      /**
       * Inertia options.
       *
       * @param value  Options
       */
      set: function(value) {
        this._inertiaOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "hitOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("hitOptions", this._hitOptions);
        } else {
          return this._hitOptions;
        }
      },
      /**
       * Hit options.
       *
       * @param value  Options
       */
      set: function(value) {
        this._hitOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "hoverOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("hoverOptions", this._hoverOptions);
        } else {
          return this._hoverOptions;
        }
      },
      /**
       * Hover options.
       *
       * @param value  Options
       */
      set: function(value) {
        this._hoverOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "swipeOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("swipeOptions", this._swipeOptions);
        } else {
          return this._swipeOptions;
        }
      },
      /**
       * Swipe options.
       *
       * @param value  Options
       */
      set: function(value) {
        this._swipeOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "keyboardOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("keyboardOptions", this._keyboardOptions);
        } else {
          return this._keyboardOptions;
        }
      },
      /**
       * Keyboard options.
       *
       * @param value  Options
       */
      set: function(value) {
        this._keyboardOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "mouseOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("mouseOptions", this._mouseOptions);
        } else {
          return this._mouseOptions;
        }
      },
      /**
       * Mouse options.
       *
       * Enables controlling options related to the mouse, for example sensitivity
       * of its mouse wheel.
       *
       * E.g. the below will reduce chart's wheel-zoom speed to half its default
       * speed:
       *
       * ```TypeScript
       * chart.plotContainer.mouseOptions.sensitivity = 0.5;
       * ```
       * ```JavaScript
       * chart.plotContainer.mouseOptions.sensitivity = 0.5;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "plotContainer": {
       *     "mouseOptions": {
       *       "sensitivity": 0.5
       *     }
       *   }
       * }
       * ```
       *
       * @since 4.5.14
       * @param value  Options
       */
      set: function(value) {
        this._mouseOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InteractionObject2.prototype, "cursorOptions", {
      /**
       * @return Options
       */
      get: function() {
        if (this.sprite && this.sprite._adapterO) {
          return this.sprite._adapterO.apply("cursorOptions", this._cursorOptions);
        } else {
          return this._cursorOptions;
        }
      },
      /**
       * Cursor options.
       *
       * @param value  Options
       */
      set: function(value) {
        this._cursorOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    InteractionObject2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.inertiaOptions = source.inertiaOptions;
      this.hitOptions = source.hitOptions;
      this.hoverOptions = source.hoverOptions;
      this.swipeOptions = source.swipeOptions;
      this.keyboardOptions = source.keyboardOptions;
      this.cursorOptions = source.cursorOptions;
      this.contextMenuDisabled = source.contextMenuDisabled;
      getInteraction().applyCursorOverStyle(this);
    };
    InteractionObject2.prototype.setEventDisposer = function(key, value, f) {
      var disposer = this.eventDisposers.getKey(key);
      if (value) {
        if (disposer == null) {
          this.eventDisposers.setKey(key, f());
        }
      } else {
        if (disposer != null) {
          disposer.dispose();
          this.eventDisposers.removeKey(key);
        }
      }
    };
    InteractionObject2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      var interaction2 = getInteraction();
      interaction2.overObjects.removeValue(this);
      interaction2.downObjects.removeValue(this);
      interaction2.trackedObjects.removeValue(this);
      interaction2.transformedObjects.removeValue(this);
      if (this.isHover && this.wheelable) {
        interaction2.unlockWheel();
      }
      if (interaction2.focusedObject === this) {
        interaction2.focusedObject = void 0;
      }
    };
    return InteractionObject2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/interaction/InteractionKeyboardObject.js
var InteractionKeyboardObject = (
  /** @class */
  function() {
    function InteractionKeyboardObject2(io, ev) {
      this._disposed = false;
      this.directionX = 0;
      this.directionY = 0;
      this.interaction = io;
      this.keyboardEvent = ev;
      this._startedOn = (/* @__PURE__ */ new Date()).getTime();
      getInteraction().processDragStart(io);
      system.animations.push(this);
      this.update();
    }
    InteractionKeyboardObject2.prototype.update = function() {
      var io = this.interaction;
      var speed = getInteraction().getKeyboardOption(io, "speed"), accelleration = getInteraction().getKeyboardOption(io, "accelleration"), accellerationDelay = getInteraction().getKeyboardOption(io, "accellerationDelay"), shift = {
        x: 0,
        y: 0
      };
      if (this.keyboardEvent.shiftKey) {
        speed *= 0.5;
        accelleration = 1;
      } else if (this.keyboardEvent.ctrlKey) {
        speed *= 2;
      }
      var ms = (/* @__PURE__ */ new Date()).getTime() - this._startedOn;
      var accelleratedMs = ms - accellerationDelay;
      if (accelleration > 0 && accelleratedMs > 0) {
        var accellerationFactor = ms / accellerationDelay;
        ms = accellerationDelay;
        shift.x += this.directionX * (speed * accelleration * accellerationFactor * accelleratedMs);
        shift.y += this.directionY * (speed * accelleration * accellerationFactor * accelleratedMs);
      }
      shift.x += this.directionX * (speed * ms);
      shift.y += this.directionY * (speed * ms);
      getInteraction().handleTransformMove(io, shift, { x: 0, y: 0 }, this.keyboardEvent, true, false);
    };
    InteractionKeyboardObject2.prototype.isDisposed = function() {
      return this._disposed;
    };
    InteractionKeyboardObject2.prototype.dispose = function() {
      if (!this._disposed) {
        getInteraction().processDragStop(this.interaction);
        remove(system.animations, this);
      }
    };
    return InteractionKeyboardObject2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/interaction/Inertia.js
var Inertia = (
  /** @class */
  function(_super) {
    __extends(Inertia2, _super);
    function Inertia2(interaction2, type, point, startPoint) {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.animations = [];
      _this.className = "Inertia";
      _this.interaction = interaction2;
      _this.type = type;
      _this.point = point;
      _this.startPoint = startPoint;
      _this._disposers.push(new AnimationDisposer(_this.animations));
      return _this;
    }
    Object.defineProperty(Inertia2.prototype, "x", {
      /**
       * Returns current X coordinate.
       *
       * @return X
       */
      get: function() {
        return this.point.x;
      },
      /**
       * Sets current X coordinate.
       *
       * Will trigger "drag" event for the target element.
       *
       * @param value X
       */
      set: function(value) {
        if (isNumber(value)) {
          this.point.x = value;
          this.handleMove();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Inertia2.prototype, "y", {
      /**
       * Returns current Y coordinate.
       *
       * @return Y
       */
      get: function() {
        return this.point.y;
      },
      /**
       * Sets current Y coordinate.
       *
       * Will trigger "drag" event for the target element.
       *
       * @param value Y
       */
      set: function(value) {
        if (isNumber(value)) {
          this.point.y = value;
          this.handleMove();
        }
      },
      enumerable: true,
      configurable: true
    });
    Inertia2.prototype.handleMove = function() {
      if (this.interaction.events.isEnabled("drag")) {
        var imev = {
          type: "drag",
          target: this.interaction,
          shift: {
            x: this.x - this.startPoint.x,
            y: this.y - this.startPoint.y
          },
          startPoint: this.startPoint,
          point: {
            x: this.x,
            y: this.y
          },
          touch: false
        };
        this.interaction.events.dispatchImmediately("drag", imev);
      }
    };
    Inertia2.prototype.done = function() {
      this.interaction.inertias.removeKey(this.type);
      if (this.type === "move") {
        getInteraction().processDragStop(this.interaction);
      }
      this.dispose();
    };
    return Inertia2;
  }(BaseObject)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Keyboard.js
var Keyboard = (
  /** @class */
  function() {
    function Keyboard2() {
    }
    Keyboard2.prototype.getEventKey = function(ev) {
      var code = ev.keyCode || ev.which, key;
      switch (code) {
        case 38:
          key = "up";
          break;
        case 40:
          key = "down";
          break;
        case 37:
          key = "left";
          break;
        case 39:
          key = "right";
          break;
        case 13:
          key = "enter";
          break;
        case 27:
          key = "esc";
          break;
        case 36:
          key = "home";
          break;
        case 35:
          key = "end";
          break;
        case 9:
          key = "tab";
          break;
        case 17:
          key = "ctrl";
          break;
        case 18:
          key = "alt";
          break;
        case 16:
          key = "shift";
          break;
        case 32:
          key = "space";
          break;
        case 36:
          key = "home";
          break;
        case 35:
          key = "end";
          break;
        case 33:
          key = "pgup";
          break;
        case 34:
          key = "pgdn";
          break;
        case 45:
          key = "ins";
          break;
        case 46:
          key = "del";
          break;
        case 107:
          key = "plus";
          break;
        case 109:
          key = "minus";
          break;
        default:
          key = "other";
          break;
      }
      return key;
    };
    Keyboard2.prototype.isKey = function(ev, key) {
      var eventKey = this.getEventKey(ev);
      if (isString(key)) {
        key = [key];
      }
      return key.indexOf(eventKey) !== -1;
    };
    Keyboard2.prototype.shiftKey = function(ev) {
      return ev.shiftKey;
    };
    Keyboard2.prototype.ctrlKey = function(ev) {
      return ev.ctrlKey;
    };
    Keyboard2.prototype.altKey = function(ev) {
      return ev.altKey;
    };
    Keyboard2.prototype.metaKey = function(ev) {
      return ev.metaKey;
    };
    return Keyboard2;
  }()
);
var keyboard = new Keyboard();

// node_modules/@amcharts/amcharts4/.internal/core/utils/Time.js
var Time_exports = {};
__export(Time_exports, {
  add: () => add,
  checkChange: () => checkChange,
  copy: () => copy3,
  getDuration: () => getDuration,
  getNextUnit: () => getNextUnit,
  getTime: () => getTime,
  getTimezoneMinutes: () => getTimezoneMinutes,
  now: () => now,
  round: () => round2,
  setTimezone: () => setTimezone,
  timeUnitDurations: () => timeUnitDurations
});
var timeUnitDurations = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 2592e6,
  year: 31536e6
};
function getNextUnit(unit) {
  switch (unit) {
    case "year":
      return;
    case "month":
      return "year";
    case "week":
      return "month";
    case "day":
      return "month";
    case "hour":
      return "day";
    case "minute":
      return "hour";
    case "second":
      return "minute";
    case "millisecond":
      return "second";
  }
}
function getDuration(unit, count) {
  if (!hasValue(count)) {
    count = 1;
  }
  return timeUnitDurations[unit] * count;
}
function now() {
  return /* @__PURE__ */ new Date();
}
function getTime() {
  return now().getTime();
}
function copy3(date) {
  return new Date(date.getTime());
}
function checkChange(dateOne, dateTwo, unit, utc) {
  dateOne = new Date(dateOne.getTime());
  dateTwo = new Date(dateTwo.getTime());
  var timeZoneOffset1 = 0;
  var timeZoneOffset2 = 0;
  if (!utc && unit != "millisecond") {
    timeZoneOffset1 = dateOne.getTimezoneOffset();
    dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);
    timeZoneOffset2 = dateTwo.getTimezoneOffset();
    dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);
  }
  var changed = false;
  switch (unit) {
    case "year":
      if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
        changed = true;
      }
      break;
    case "month":
      if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
        changed = true;
      } else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
        changed = true;
      }
      break;
    case "day":
      if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
        changed = true;
      } else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {
        changed = true;
      }
      break;
    case "hour":
      if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {
        changed = true;
      }
      break;
    case "minute":
      if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {
        changed = true;
      }
      break;
    case "second":
      if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {
        changed = true;
      }
      break;
    case "millisecond":
      if (dateOne.getTime() != dateTwo.getTime()) {
        changed = true;
      }
      break;
  }
  if (changed) {
    return true;
  }
  var nextUnit = getNextUnit(unit);
  if (nextUnit) {
    dateOne.setUTCMinutes(dateOne.getUTCMinutes() + timeZoneOffset1);
    dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() + timeZoneOffset2);
    return checkChange(dateOne, dateTwo, nextUnit, utc);
  } else {
    return false;
  }
}
function add(date, unit, count, utc) {
  var timeZoneOffset = 0;
  if (!utc && unit != "millisecond") {
    timeZoneOffset = date.getTimezoneOffset();
    date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
  }
  switch (unit) {
    case "day":
      var day = date.getUTCDate();
      date.setUTCDate(day + count);
      break;
    case "second":
      var seconds = date.getUTCSeconds();
      date.setUTCSeconds(seconds + count);
      break;
    case "millisecond":
      var milliseconds = date.getUTCMilliseconds();
      date.setUTCMilliseconds(milliseconds + count);
      break;
    case "hour":
      var hours = date.getUTCHours();
      date.setUTCHours(hours + count);
      break;
    case "minute":
      var minutes = date.getUTCMinutes();
      date.setUTCMinutes(minutes + count);
      break;
    case "year":
      var year = date.getUTCFullYear();
      date.setUTCFullYear(year + count);
      break;
    case "month":
      var month = date.getUTCMonth();
      date.setUTCMonth(month + count);
      break;
    case "week":
      var wday = date.getUTCDate();
      date.setUTCDate(wday + count * 7);
      break;
  }
  if (!utc && unit != "millisecond") {
    date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
    if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
      var newTimeZoneOffset = date.getTimezoneOffset();
      if (newTimeZoneOffset != timeZoneOffset) {
        var diff = newTimeZoneOffset - timeZoneOffset;
        date.setUTCMinutes(date.getUTCMinutes() + diff);
        if (date.getTimezoneOffset() != newTimeZoneOffset) {
          date.setUTCMinutes(date.getUTCMinutes() - diff);
        }
      }
    }
  }
  return date;
}
function round2(date, unit, count, firstDateOfWeek, utc, firstDate, roundMinutes, timezone) {
  if (roundMinutes === void 0) {
    roundMinutes = 0;
  }
  if (!isNumber(count)) {
    count = 1;
  }
  var timeZoneOffset = 0;
  if (timezone && ["day", "month", "week", "year"].indexOf(unit) != -1) {
    date = setTimezone(date, timezone);
  }
  if (!utc && unit != "millisecond") {
    timeZoneOffset = date.getTimezoneOffset();
    date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
  }
  switch (unit) {
    case "day":
      var day = date.getUTCDate();
      if (count > 1) {
        if (firstDate) {
          firstDate = round2(firstDate, "day", 1);
          var difference = date.getTime() - firstDate.getTime();
          var unitCount = Math.floor(difference / getDuration("day") / count);
          var duration = getDuration("day", unitCount * count);
          date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
        }
      } else {
        date.setUTCDate(day);
      }
      date.setUTCHours(0, 0, 0, 0);
      break;
    case "second":
      var seconds = date.getUTCSeconds();
      if (count > 1) {
        seconds = Math.floor(seconds / count) * count;
      }
      date.setUTCSeconds(seconds, 0);
      break;
    case "millisecond":
      if (count == 1) {
        return date;
      }
      var milliseconds = date.getUTCMilliseconds();
      milliseconds = Math.floor(milliseconds / count) * count;
      date.setUTCMilliseconds(milliseconds);
      break;
    case "hour":
      var hours = date.getUTCHours();
      if (count > 1) {
        hours = Math.floor(hours / count) * count;
      }
      date.setUTCHours(hours, roundMinutes, 0, 0);
      break;
    case "minute":
      var minutes = date.getUTCMinutes();
      milliseconds = date.getUTCMilliseconds();
      if (count > 1) {
        minutes = Math.floor(minutes / count) * count;
      }
      date.setUTCMinutes(minutes, 0, 0);
      break;
    case "month":
      var month = date.getUTCMonth();
      if (count > 1) {
        month = Math.floor(month / count) * count;
      }
      date.setUTCMonth(month, 1);
      date.setUTCHours(0, roundMinutes, 0, 0);
      break;
    case "year":
      var year = date.getUTCFullYear();
      if (count > 1) {
        year = Math.floor(year / count) * count;
      }
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, roundMinutes, 0, 0);
      break;
    case "week":
      var wday = date.getUTCDate();
      var weekDay = date.getUTCDay();
      if (!isNumber(firstDateOfWeek)) {
        firstDateOfWeek = 1;
      }
      if (weekDay >= firstDateOfWeek) {
        wday = wday - weekDay + firstDateOfWeek;
      } else {
        wday = wday - (7 + weekDay) + firstDateOfWeek;
      }
      date.setUTCDate(wday);
      date.setUTCHours(0, roundMinutes, 0, 0);
      break;
  }
  if (!utc && unit != "millisecond") {
    date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
    if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
      var newTimeZoneOffset = date.getTimezoneOffset();
      if (newTimeZoneOffset != timeZoneOffset) {
        var diff = newTimeZoneOffset - timeZoneOffset;
        date.setUTCMinutes(date.getUTCMinutes() + diff);
      }
    }
  }
  return date;
}
function setTimezone(date, timezone) {
  var d = new Date(date.toLocaleString("en-US", { timeZone: timezone }));
  return d;
}
function getTimezoneMinutes(timezone) {
  var d = /* @__PURE__ */ new Date();
  d.setHours(0, 0, 0, 0);
  var d2 = setTimezone(d, timezone);
  return d2.getMinutes();
}

// node_modules/@amcharts/amcharts4/.internal/core/interaction/Interaction.js
var Interaction = (
  /** @class */
  function(_super) {
    __extends(Interaction2, _super);
    function Interaction2() {
      var _this = (
        // Call super
        _super.call(this) || this
      );
      _this._globalEventsAdded = false;
      _this._pointerEvents = {
        "pointerdown": "mousedown",
        "pointerup": "mouseup",
        "pointermove": "mousemove",
        "pointercancel": "mouseup",
        "pointerover": "mouseover",
        "pointerout": "mouseout",
        "wheel": "wheel"
      };
      _this._usePointerEventsOnly = false;
      _this._useTouchEventsOnly = false;
      _this._addHoverEvents = true;
      _this._passiveSupported = false;
      _this._delayedEvents = { out: [] };
      _this.overObjects = new List();
      _this.downObjects = new List();
      _this.trackedObjects = new List();
      _this.transformedObjects = new List();
      _this.pointers = new Dictionary();
      _this.inertiaOptions = new Dictionary();
      _this.hitOptions = {
        "doubleHitTime": 300,
        //"delayFirstHit": false,
        "hitTolerance": 10,
        "noFocus": true
      };
      _this.hoverOptions = {
        "touchOutBehavior": "leave",
        "touchOutDelay": 1e3
      };
      _this.swipeOptions = {
        "time": 500,
        "verticalThreshold": 75,
        "horizontalThreshold": 30
      };
      _this.keyboardOptions = {
        "speed": 0.1,
        "accelleration": 1.2,
        "accellerationDelay": 2e3
      };
      _this.mouseOptions = {
        "sensitivity": 1
      };
      _this.className = "Interaction";
      _this.body = _this.getInteraction(document.body);
      _this._disposers.push(_this.body);
      if (window.hasOwnProperty("PointerEvent")) {
        _this._pointerEvents.pointerdown = "pointerdown";
        _this._pointerEvents.pointerup = "pointerup";
        _this._pointerEvents.pointermove = "pointermove";
        _this._pointerEvents.pointercancel = "pointercancel";
        _this._pointerEvents.pointerover = "pointerover";
        _this._pointerEvents.pointerout = "pointerout";
      } else if (window.hasOwnProperty("MSPointerEvent")) {
        _this._pointerEvents.pointerdown = "MSPointerDown";
        _this._pointerEvents.pointerup = "MSPointerUp";
        _this._pointerEvents.pointermove = "MSPointerMove";
        _this._pointerEvents.pointercancel = "MSPointerUp";
        _this._pointerEvents.pointerover = "MSPointerOver";
        _this._pointerEvents.pointerout = "MSPointerOut";
      } else if (typeof matchMedia !== "undefined" && matchMedia("(pointer:fine)").matches) {
        if ("ontouchstart" in window) {
          _this._addHoverEvents = false;
          _this._useTouchEventsOnly = true;
        }
      } else if (window.navigator.userAgent.match(/MSIE /)) {
        _this._usePointerEventsOnly = true;
      } else if (_this.fullFF()) {
        _this._usePointerEventsOnly = true;
      } else {
        _this._useTouchEventsOnly = true;
      }
      if ("onwheel" in document.createElement("div")) {
        _this._pointerEvents.wheel = "wheel";
      } else if (hasValue(document.onmousewheel)) {
        _this._pointerEvents.wheel = "mousewheel";
      }
      _this.inertiaOptions.setKey("move", {
        "time": 100,
        "duration": 500,
        "factor": 1,
        "easing": polyOut3
      });
      _this.inertiaOptions.setKey("resize", {
        "time": 100,
        "duration": 500,
        "factor": 1,
        "easing": polyOut3
      });
      _this._passiveSupported = Interaction2.passiveSupported;
      _this.applyTheme();
      return _this;
    }
    Interaction2.prototype.fullFF = function() {
      return window.navigator.userAgent.match(/Firefox/) && !window.navigator.userAgent.match(/Android/);
    };
    Interaction2.prototype.debug = function() {
    };
    Interaction2.prototype.addGlobalEvents = function() {
      var _this = this;
      if (!this._globalEventsAdded) {
        if (!this._useTouchEventsOnly) {
          this._disposers.push(addEventListener(document, this._pointerEvents.pointerdown, function(ev) {
            _this.handleGlobalPointerDown(ev);
          }));
          this._disposers.push(addEventListener(document, this._pointerEvents.pointermove, function(ev) {
            _this.handleGlobalPointerMove(ev);
          }));
          this._disposers.push(addEventListener(document, this._pointerEvents.pointerup, function(ev) {
            _this.handleGlobalPointerUp(ev);
          }));
          this._disposers.push(addEventListener(document, this._pointerEvents.pointercancel, function(ev) {
            _this.handleGlobalPointerUp(ev, true);
          }));
          this._disposers.push(addEventListener(document, "mouseenter", function(ev) {
            if (!hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {
              _this.handleDocumentLeave(ev);
            }
          }));
        }
        if (!this._usePointerEventsOnly) {
          this._disposers.push(addEventListener(document, "touchstart", function(ev) {
            _this.handleGlobalTouchStart(ev);
          }));
          this._disposers.push(addEventListener(document, "touchmove", function(ev) {
            _this.handleGlobalTouchMove(ev);
          }));
          this._disposers.push(addEventListener(document, "touchend", function(ev) {
            _this.handleGlobalTouchEnd(ev);
          }));
        }
        this._disposers.push(addEventListener(document, "keydown", function(ev) {
          _this.handleGlobalKeyDown(ev);
        }));
        this._disposers.push(addEventListener(document, "keyup", function(ev) {
          _this.handleGlobalKeyUp(ev);
        }));
        this._globalEventsAdded = true;
      }
    };
    Interaction2.prototype.processClickable = function(io) {
      this.processTouchable(io);
    };
    Interaction2.prototype.processContextMenu = function(io) {
      if (io.contextMenuDisabled) {
        if (!io.eventDisposers.hasKey("contextMenuDisabled")) {
          io.eventDisposers.setKey("contextMenuDisabled", addEventListener(io.element, "contextmenu", function(e) {
            e.preventDefault();
          }));
        }
      } else {
        if (io.eventDisposers.hasKey("contextMenuDisabled")) {
          io.eventDisposers.getKey("contextMenuDisabled").dispose();
        }
      }
    };
    Interaction2.prototype.processHoverable = function(io) {
      var _this = this;
      if (io.hoverable || io.trackable) {
        this.addGlobalEvents();
        this.applyCursorOverStyle(io);
        if (!io.eventDisposers.hasKey("hoverable") && this._addHoverEvents) {
          io.eventDisposers.setKey("hoverable", new MultiDisposer([
            addEventListener(io.element, this._pointerEvents.pointerout, function(e) {
              return _this.handlePointerOut(io, e);
            }),
            addEventListener(io.element, this._pointerEvents.pointerover, function(e) {
              return _this.handlePointerOver(io, e);
            })
          ]));
        }
        if (io.trackable) {
        }
      } else {
        var disposer = io.eventDisposers.getKey("hoverable");
        if (disposer != null) {
          disposer.dispose();
          io.eventDisposers.removeKey("hoverable");
        }
      }
      this.processTouchable(io);
    };
    Interaction2.prototype.processMovable = function(io) {
      if (io.draggable || io.swipeable || io.trackable || io.resizable) {
        if (!this.isGlobalElement(io) && !io.isTouchProtected) {
          this.prepElement(io);
        }
        this.applyCursorOverStyle(io);
      }
      this.processTouchable(io);
    };
    Interaction2.prototype.processTrackable = function(io) {
      this.processHoverable(io);
      this.processMovable(io);
      if (io.trackable) {
        this.trackedObjects.moveValue(io);
      } else {
        this.trackedObjects.removeValue(io);
      }
    };
    Interaction2.prototype.processDraggable = function(io) {
      this.processMovable(io);
    };
    Interaction2.prototype.processSwipeable = function(io) {
      this.processMovable(io);
    };
    Interaction2.prototype.processResizable = function(io) {
      this.processMovable(io);
    };
    Interaction2.prototype.processWheelable = function(io) {
      var _this = this;
      if (io.wheelable) {
        if (!io.eventDisposers.hasKey("wheelable")) {
          io.eventDisposers.setKey("wheelable", new MultiDisposer([
            addEventListener(io.element, this._pointerEvents.wheel, function(e) {
              return _this.handleMouseWheel(io, e);
            }, this._passiveSupported ? { passive: false } : false),
            io.events.on("out", function(e) {
              if (io.wheelable) {
                _this.unlockWheel();
              }
            }),
            io.events.on("over", function(e) {
              if (io.wheelable) {
                _this.lockWheel();
              }
            })
          ]));
        }
      } else {
        var disposer = io.eventDisposers.getKey("wheelable");
        if (disposer != null) {
          disposer.dispose();
          io.eventDisposers.removeKey("wheelable");
        }
      }
    };
    Interaction2.prototype.processFocusable = function(io) {
      var _this = this;
      if (io.focusable === true && io.tabindex > -1 && !this._useTouchEventsOnly) {
        if (!io.eventDisposers.hasKey("focusable")) {
          io.eventDisposers.setKey("focusable", new MultiDisposer([
            addEventListener(io.element, "focus", function(e) {
              return _this.handleFocus(io, e);
            }),
            addEventListener(io.element, "blur", function(e) {
              return _this.handleBlur(io, e);
            }),
            addEventListener(io.element, this._pointerEvents.pointerdown, function(e) {
              return _this.handleFocusBlur(io, e);
            }),
            addEventListener(io.element, "touchstart", function(e) {
              return _this.handleFocusBlur(io, e);
            }, this._passiveSupported ? { passive: false } : false)
          ]));
        }
      } else {
        var disposer = io.eventDisposers.getKey("focusable");
        if (disposer != null) {
          disposer.dispose();
          io.eventDisposers.removeKey("focusable");
        }
      }
    };
    Interaction2.prototype.processTouchable = function(io) {
      var _this = this;
      if (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {
        this.addGlobalEvents();
        if (!io.eventDisposers.hasKey("touchable")) {
          if (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {
            io.eventDisposers.setKey("touchable", new MultiDisposer([
              addEventListener(io.element, this._pointerEvents.pointerdown, function(e) {
                return _this.handlePointerDown(io, e);
              }),
              addEventListener(io.element, "touchstart", function(e) {
                return _this.handleTouchDown(io, e);
              }, this._passiveSupported ? { passive: false } : false)
            ]));
          } else if (!this._useTouchEventsOnly) {
            io.eventDisposers.setKey("touchable", addEventListener(io.element, this._pointerEvents.pointerdown, function(e) {
              return _this.handlePointerDown(io, e);
            }));
          } else if (!this._usePointerEventsOnly) {
            io.eventDisposers.setKey("touchable", addEventListener(io.element, "touchstart", function(e) {
              return _this.handleTouchDown(io, e);
            }, this._passiveSupported ? { passive: false } : false));
          }
        }
      } else {
        var disposer = io.eventDisposers.getKey("touchable");
        if (disposer != null) {
          disposer.dispose();
          io.eventDisposers.removeKey("touchable");
        }
      }
    };
    Interaction2.prototype.handleFocus = function(io, ev) {
      if (!io.focusable) {
        ev.preventDefault();
        return;
      }
      io.isFocused = true;
      if (io.events.isEnabled("focus") && !system.isPaused) {
        var imev = {
          type: "focus",
          target: io,
          event: ev
        };
        io.events.dispatchImmediately("focus", imev);
      }
    };
    Interaction2.prototype.handleFocusBlur = function(io, ev) {
      if (io.focusable !== false && this.getHitOption(io, "noFocus")) {
        io.events.once("focus", function() {
          io.events.disableType("blur");
          blur();
          if (io.sprite) {
            io.sprite.handleBlur();
          }
          io.events.enableType("blur");
        });
      }
    };
    Interaction2.prototype.handleBlur = function(io, ev) {
      if (!io.focusable) {
        ev.preventDefault();
        return;
      }
      io.isFocused = false;
      if (io.events.isEnabled("blur") && !system.isPaused) {
        var imev = {
          type: "blur",
          target: io,
          event: ev
        };
        io.events.dispatchImmediately("blur", imev);
      }
    };
    Interaction2.prototype.handleGlobalKeyDown = function(ev) {
      if (this.focusedObject) {
        if (keyboard.isKey(ev, "esc")) {
          blur();
        } else if (this.focusedObject.draggable && keyboard.isKey(ev, ["up", "down", "left", "right"])) {
          ev.preventDefault();
          var io = this.focusedObject;
          var disposerKey = "interactionKeyboardObject";
          if (io.eventDisposers.hasKey(disposerKey)) {
            return;
          }
          var ko = new InteractionKeyboardObject(io, ev);
          io.eventDisposers.setKey(disposerKey, ko);
          switch (keyboard.getEventKey(ev)) {
            case "up":
              ko.directionY = -1;
              break;
            case "down":
              ko.directionY = 1;
              break;
            case "left":
              ko.directionX = -1;
              break;
            case "right":
              ko.directionX = 1;
              break;
          }
        }
      }
    };
    Interaction2.prototype.handleGlobalKeyUp = function(ev) {
      var disposerKey = "interactionKeyboardObject";
      if (this.focusedObject) {
        var disposer = this.focusedObject.eventDisposers.getKey(disposerKey);
        if (disposer != null) {
          ev.preventDefault();
          disposer.dispose();
          this.focusedObject.eventDisposers.removeKey(disposerKey);
        }
        var sprite = this.focusedObject.sprite;
        if (keyboard.isKey(ev, "enter") && sprite) {
          if (sprite.events.isEnabled("hit") || sprite.events.isEnabled("toggled")) {
            this.focusedObject.dispatchImmediately("hit");
          } else if (sprite.showTooltipOn == "hit") {
            this.focusedObject.dispatchImmediately("up");
          }
        }
      }
    };
    Interaction2.prototype.handleGlobalPointerMove = function(ev) {
      var pointer = this.getPointer(ev);
      pointer.point = this.getPointerPoint(ev);
      if (this.events.isEnabled("track") && !system.isPaused) {
        var imev = {
          type: "track",
          target: this,
          event: ev,
          pointer,
          touch: pointer.touch
        };
        this.events.dispatchImmediately("track", imev);
      }
      this.addBreadCrumb(pointer, pointer.point);
      this.handleGlobalMove(pointer, ev);
    };
    Interaction2.prototype.handleGlobalPointerDown = function(ev) {
      this.processDelayed();
      var pointer = this.getPointer(ev);
      if (this.events.isEnabled("down") && !system.isPaused) {
        var imev = {
          type: "down",
          target: this,
          event: ev,
          pointer,
          touch: pointer.touch
        };
        this.events.dispatchImmediately("down", imev);
      }
    };
    Interaction2.prototype.preventTouchAction = function(ev) {
      if (!ev.defaultPrevented) {
        ev.preventDefault();
      }
    };
    Interaction2.prototype.handleGlobalPointerUp = function(ev, cancelled) {
      if (cancelled === void 0) {
        cancelled = false;
      }
      var pointer = this.getPointer(ev);
      if (this.events.isEnabled("up") && !system.isPaused) {
        var imev = {
          type: "up",
          target: this,
          event: ev,
          pointer,
          touch: pointer.touch
        };
        this.events.dispatchImmediately("up", imev);
      }
      this.handleGlobalUp(pointer, ev, cancelled);
    };
    Interaction2.prototype.handleGlobalTouchMove = function(ev) {
      for (var i = 0; i < ev.changedTouches.length; i++) {
        var pointer = this.getPointer(ev.changedTouches[i]);
        pointer.point = this.getPointerPoint(ev.changedTouches[i]);
        if (this.events.isEnabled("track") && !system.isPaused) {
          var imev = {
            type: "track",
            target: this,
            event: ev,
            pointer,
            touch: pointer.touch
          };
          this.events.dispatchImmediately("track", imev);
        }
        this.addBreadCrumb(pointer, pointer.point);
        this.handleGlobalMove(pointer, ev);
      }
    };
    Interaction2.prototype.handleGlobalTouchStart = function(ev) {
      this.processDelayed();
      for (var i = 0; i < ev.changedTouches.length; i++) {
        var pointer = this.getPointer(ev.changedTouches[i]);
        if (!this._usePointerEventsOnly && this.events.isEnabled("down") && !system.isPaused) {
          var imev = {
            type: "down",
            target: this,
            event: ev,
            pointer,
            touch: pointer.touch
          };
          this.events.dispatchImmediately("down", imev);
        }
      }
    };
    Interaction2.prototype.handleGlobalTouchEnd = function(ev) {
      for (var i = 0; i < ev.changedTouches.length; i++) {
        var pointer = this.getPointer(ev.changedTouches[i]);
        if (this.events.isEnabled("up") && !system.isPaused) {
          var imev = {
            type: "up",
            target: this,
            event: ev,
            pointer,
            touch: pointer.touch
          };
          this.events.dispatchImmediately("up", imev);
        }
        this.handleGlobalUp(pointer, ev);
      }
    };
    Interaction2.prototype.handlePointerDown = function(io, ev) {
      var pointer = this.getPointer(ev);
      if (!pointer.touch && ev.which != 1 && ev.which != 3) {
        return;
      }
      pointer.button = ev.which;
      this.resetPointer(pointer, ev);
      this.handleDown(io, pointer, ev);
    };
    Interaction2.prototype.handlePointerOver = function(io, ev) {
      var pointer = this.getPointer(ev);
      this.handleOver(io, pointer, ev);
    };
    Interaction2.prototype.handlePointerOut = function(io, ev) {
      var pointer = this.getPointer(ev);
      this.handleOut(io, pointer, ev);
    };
    Interaction2.prototype.handleMouseWheel = function(io, ev) {
      var pointer = this.getPointer(ev);
      pointer.point = this.getPointerPoint(ev);
      var deltaX = 0, deltaY = 0;
      var mod = 1;
      if (ev.deltaMode == 1) {
        mod = 50;
      }
      mod *= this.getMouseOption(io, "sensitivity");
      if (ev instanceof WheelEvent) {
        deltaX = Math.round(-1 * ev.wheelDeltaX || ev.deltaX * mod);
        deltaY = Math.round(-1 * ev.wheelDeltaY || ev.deltaY * mod);
      } else {
        throw new Error("Invalid event type");
      }
      this.handleWheel(io, pointer, deltaX, deltaY, ev);
    };
    Interaction2.prototype.handleTouchDown = function(io, ev) {
      for (var i = 0; i < ev.changedTouches.length; i++) {
        var pointer = this.getPointer(ev.changedTouches[i]);
        this.maybePreventDefault(io, ev, pointer);
        this.resetPointer(pointer, ev.changedTouches[i]);
        this.handleDown(io, pointer, ev);
      }
    };
    Interaction2.prototype.handleHit = function(io, pointer, ev) {
      var now2 = getTime();
      if (io.lastHit && io.lastHit >= now2 - this.getHitOption(io, "doubleHitTime")) {
        if (now2 - io.lastHit < 100) {
          return;
        }
        io.lastHit = void 0;
        io.lastHitPointer = void 0;
        if (io.events.isEnabled("doublehit") && !system.isPaused) {
          var imev = {
            type: "doublehit",
            target: io,
            point: pointer.point,
            event: ev,
            touch: pointer.touch
          };
          io.events.dispatchImmediately("doublehit", imev);
        }
      } else {
        io.lastHit = now2;
        io.lastHitPointer = pointer;
        if (pointer.button === 3) {
          if (io.events.isEnabled("rightclick") && !system.isPaused) {
            var imev = {
              type: "rightclick",
              target: io,
              event: ev
            };
            io.events.dispatchImmediately("rightclick", imev);
          }
        } else {
          if (io.events.isEnabled("hit") && !system.isPaused) {
            var imev = {
              type: "hit",
              target: io,
              event: ev,
              point: pointer.point,
              touch: pointer.touch
            };
            io.events.dispatchImmediately("hit", imev);
          }
        }
      }
    };
    Interaction2.prototype.handleOver = function(io, pointer, ev, soft) {
      if (soft === void 0) {
        soft = false;
      }
      if (!io.hoverable) {
        return;
      }
      var hoversPaused = false;
      if (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, "hitTolerance"))) {
        hoversPaused = true;
        this.cancelAllHovers(ev);
      }
      this.processDelayed();
      io.overPointers.moveValue(pointer);
      if (!io.isRealHover) {
        if (!hoversPaused) {
          io.isHover = true;
          io.isRealHover = true;
          this.overObjects.moveValue(io);
        }
        this.handleTrack(this.body, pointer, ev, true);
        if (io.events.isEnabled("over") && !system.isPaused && !hoversPaused) {
          var imev = {
            type: "over",
            target: io,
            event: ev,
            pointer,
            touch: pointer.touch
          };
          io.events.dispatchImmediately("over", imev);
        }
      }
    };
    Interaction2.prototype.handleOut = function(io, pointer, ev, soft, force) {
      var _this = this;
      if (soft === void 0) {
        soft = false;
      }
      if (force === void 0) {
        force = false;
      }
      if (!io.hoverable) {
        return;
      }
      io.overPointers.removeValue(pointer);
      if (io.isHover && (!io.hasDelayedOut || force)) {
        if (soft && io.overPointers.length) {
          return;
        }
        if (pointer && pointer.touch && !force && !this.old(pointer)) {
          var behavior = this.getHoverOption(io, "touchOutBehavior");
          if (behavior == "leave") {
            this._delayedEvents.out.push({
              type: "out",
              io,
              pointer,
              event: ev,
              keepUntil: getTime() + 500
            });
            io.hasDelayedOut = true;
            return;
          } else if (behavior == "delay" && this.getHoverOption(io, "touchOutDelay")) {
            this._delayedEvents.out.push({
              type: "out",
              io,
              pointer,
              event: ev,
              keepUntil: getTime() + 500,
              timeout: this.setTimeout(function() {
                _this.handleOut(io, pointer, ev, true);
              }, this.getHoverOption(io, "touchOutDelay"))
            });
            return;
          } else {
          }
        }
        io.isHover = false;
        this.overObjects.removeValue(io);
        if (!io.isDisposed() && io.events.isEnabled("out") && !system.isPaused) {
          var imev = {
            type: "out",
            target: io,
            event: ev,
            pointer,
            touch: pointer.touch
          };
          io.events.dispatchImmediately("out", imev);
        }
        io.overPointers.clear();
        io.hasDelayedOut = false;
      }
    };
    Interaction2.prototype.processDelayed = function() {
      var delayedEvent;
      while (true) {
        delayedEvent = this._delayedEvents.out.pop();
        if (!delayedEvent) {
          break;
        }
        if (delayedEvent.timeout) {
          delayedEvent.timeout.dispose();
        }
        this.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);
      }
    };
    Interaction2.prototype.handleDown = function(io, pointer, ev) {
      this.maybePreventDefault(io, ev, pointer);
      if (io.inert) {
        this.stopInertia(io);
      }
      this.handleOver(io, pointer, ev, true);
      io.downPointers.moveValue(pointer);
      this.applyCursorDownStyle(io, pointer);
      if (!io.isDown) {
        if (io.focusable !== false && this.getHitOption(io, "noFocus") && this.focusedObject) {
          blur();
        }
        io.isDown = true;
        this.downObjects.moveValue(io);
        if (io.draggable) {
          this.processDragStart(io, pointer, ev);
        }
        if (io.resizable) {
          this.processResizeStart(io, pointer, ev);
        }
      }
      if (io.events.isEnabled("down") && !system.isPaused) {
        var imev = {
          type: "down",
          target: io,
          event: ev,
          pointer,
          touch: pointer.touch
        };
        io.events.dispatchImmediately("down", imev);
      }
    };
    Interaction2.prototype.handleGlobalUp = function(pointer, ev, cancelled) {
      var _this = this;
      if (cancelled === void 0) {
        cancelled = false;
      }
      var sorted = this.downObjects.values.slice();
      sorted.sort(function(x, y) {
        if (x && y) {
          var pos = x.element.compareDocumentPosition(y.element);
          if (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            return 1;
          } else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {
            return -1;
          } else {
            return 0;
          }
        } else {
          return 0;
        }
      });
      each(sorted, function(io) {
        if (io && io.downPointers.contains(pointer)) {
          _this.handleUp(io, pointer, ev, cancelled);
        }
      });
    };
    Interaction2.prototype.handleDocumentLeave = function(ev) {
      var _this = this;
      each3(this.downObjects.backwards().iterator(), function(io) {
        io.downPointers.each(function(pointer) {
          _this.handleUp(io, pointer, ev);
        });
      });
    };
    Interaction2.prototype.handleUp = function(io, pointer, ev, cancelled) {
      if (cancelled === void 0) {
        cancelled = false;
      }
      this.restoreCursorDownStyle(io, pointer);
      io.downPointers.removeValue(pointer);
      if (pointer && pointer.touch || this._useTouchEventsOnly) {
        this.handleOut(io, pointer, ev, true);
      }
      if (io.isDown) {
        if (io.downPointers.length == 0) {
          io.isDown = false;
          this.downObjects.removeValue(io);
        }
        if (io.events.isEnabled("up") && !system.isPaused && pointer) {
          var imev = {
            type: "up",
            target: io,
            event: ev,
            pointer,
            touch: pointer.touch
          };
          io.events.dispatchImmediately("up", imev);
        }
        if (!cancelled) {
          if (io.swipeable && this.swiped(io, pointer)) {
            this.handleSwipe(io, pointer, ev);
          } else {
            if (io.clickable && !this.moved(pointer, this.getHitOption(io, "hitTolerance"))) {
              this.handleHit(io, pointer, ev);
            }
            if (io.inert && this.moved(pointer, this.getHitOption(io, "hitTolerance"))) {
              this.handleInertia(io, pointer);
            } else if (io.draggable) {
              this.processDragStop(io, pointer, ev);
            }
            if (io.resizable) {
              this.processResizeStop(io, pointer, ev);
            }
          }
        }
      }
    };
    Interaction2.prototype.maybePreventDefault = function(io, ev, pointer) {
      if (hasValue(ev) && (io.draggable || io.swipeable || io.trackable || io.resizable) && !this.isGlobalElement(io) && ev.cancelable !== false && (!io.isTouchProtected || !pointer || !pointer.touch)) {
        ev.preventDefault();
      }
    };
    Interaction2.prototype.cancelAllHovers = function(ev) {
      var _this = this;
      each3(this.overObjects.backwards().iterator(), function(io) {
        if (io) {
          var pointer = io.overPointers.getIndex(0);
          _this.handleOut(io, pointer, ev, true, true);
        }
      });
    };
    Interaction2.prototype.shouldCancelHovers = function(pointer) {
      return options.disableHoverOnTransform == "always" || options.disableHoverOnTransform == "touch" && pointer.touch;
    };
    Interaction2.prototype.handleGlobalMove = function(pointer, ev) {
      var _this = this;
      if (!pointer.touch) {
        var target_1 = eventTarget(pointer.lastEvent);
        each3(this.overObjects.backwards().iterator(), function(io) {
          if (io && io.overPointers.contains(pointer) && io.hoverable) {
            var reset = false;
            if (io.element && pointer.lastEvent) {
              if (!contains2(io.element, target_1)) {
                reset = true;
              }
            } else {
              reset = true;
            }
            if (reset) {
              _this.handleOut(io, pointer, ev, true);
            }
          }
        });
      }
      each3(this.transformedObjects.backwards().iterator(), function(io) {
        if (io.downPointers.contains(pointer) && // Swipe still happening?
        !(io.swipeable && _this.swiping(io, pointer)) && (io.draggable || io.resizable)) {
          _this.handleTransform(io, ev);
        }
      });
      each3(this.trackedObjects.backwards().iterator(), function(io) {
        if (!io.overPointers.contains(pointer)) {
          _this.handleTrack(io, pointer, ev);
        }
      });
    };
    Interaction2.prototype.handleTrack = function(io, pointer, ev, skipCheck) {
      if (skipCheck === void 0) {
        skipCheck = false;
      }
      if (!skipCheck && !this.moved(pointer, 0)) {
        return;
      }
      if (io.events.isEnabled("track") && !system.isPaused) {
        var imev = {
          type: "track",
          target: io,
          event: ev,
          point: pointer.point,
          pointer,
          touch: pointer.touch
        };
        io.events.dispatchImmediately("track", imev);
      }
    };
    Interaction2.prototype.handleSwipe = function(io, pointer, ev) {
      if (io.events.isEnabled("swipe") && !system.isPaused) {
        var imev = {
          type: "swipe",
          target: io,
          event: ev,
          touch: pointer.touch
        };
        io.events.dispatchImmediately("swipe", imev);
      }
      if (pointer.startPoint.x < pointer.point.x) {
        if (io.events.isEnabled("swiperight") && !system.isPaused) {
          var imev = {
            type: "swiperight",
            target: io,
            event: ev,
            touch: pointer.touch
          };
          io.events.dispatchImmediately("swiperight", imev);
        }
      } else {
        if (io.events.isEnabled("swipeleft") && !system.isPaused) {
          var imev = {
            type: "swipeleft",
            target: io,
            event: ev,
            touch: pointer.touch
          };
          io.events.dispatchImmediately("swipeleft", imev);
        }
      }
    };
    Interaction2.prototype.handleWheel = function(io, pointer, deltaX, deltaY, ev) {
      var shift = {
        x: deltaX,
        y: deltaY
      };
      if (io.events.isEnabled("wheel") && !system.isPaused) {
        io.events.dispatchImmediately("wheel", {
          type: "wheel",
          target: io,
          event: ev,
          point: pointer.point,
          shift
        });
      }
      if (deltaX < 0) {
        if (io.events.isEnabled("wheelleft") && !system.isPaused) {
          io.events.dispatchImmediately("wheelleft", {
            type: "wheelleft",
            target: io,
            event: ev,
            point: pointer.point,
            shift
          });
        }
      } else if (deltaX > 0) {
        if (io.events.isEnabled("swiperight") && !system.isPaused) {
          io.events.dispatchImmediately("wheelright", {
            type: "wheelright",
            target: io,
            event: ev,
            point: pointer.point,
            shift
          });
        }
      } else if (deltaY < 0) {
        if (io.events.isEnabled("wheelup") && !system.isPaused) {
          io.events.dispatchImmediately("wheelup", {
            type: "wheelup",
            target: io,
            event: ev,
            point: pointer.point,
            shift
          });
        }
      } else if (deltaY > 0) {
        if (io.events.isEnabled("wheeldown") && !system.isPaused) {
          io.events.dispatchImmediately("wheeldown", {
            type: "wheeldown",
            target: io,
            event: ev,
            point: pointer.point,
            shift
          });
        }
      }
    };
    Interaction2.prototype.handleInertia = function(io, pointer) {
      if (io.draggable && io.downPointers.length === 0) {
        this.handleMoveInertia(io, pointer);
      }
      if (io.resizable && io.downPointers.length > 1) {
        this.handleResizeInertia(io, pointer);
      }
    };
    Interaction2.prototype.handleMoveInertia = function(io, pointer) {
      var interaction2 = io;
      var type = "move";
      var point = {
        "x": pointer.point.x,
        "y": pointer.point.y
      };
      var startPoint = {
        "x": pointer.startPoint.x,
        "y": pointer.startPoint.y
      };
      var inertia = new Inertia(interaction2, type, point, startPoint);
      var ref = this.getTrailPoint(pointer, getTime() - this.getInertiaOption(io, "move", "time"));
      if (typeof ref === "undefined") {
        this.processDragStop(io, pointer, pointer.lastUpEvent);
        return;
      }
      var factor = this.getInertiaOption(io, "move", "factor");
      var animationOptions = [{
        "to": pointer.point.x + (pointer.point.x - ref.point.x) * factor,
        "property": "x"
      }, {
        "to": pointer.point.y + (pointer.point.y - ref.point.y) * factor,
        "property": "y"
      }];
      var animation = new Animation(inertia, animationOptions, this.getInertiaOption(io, "move", "duration"), this.getInertiaOption(io, "move", "easing")).start();
      this._disposers.push(animation.events.on("animationended", function(ev) {
        inertia.done();
      }));
      io.inertias.setKey("move", inertia);
    };
    Interaction2.prototype.handleResizeInertia = function(io, pointer) {
    };
    Interaction2.prototype.handleTransform = function(io, ev) {
      var pointer1 = io.downPointers.getIndex(0);
      var point1 = null;
      var startPoint1 = null;
      if (pointer1) {
        point1 = pointer1.point;
        startPoint1 = pointer1.startPoint;
      }
      var pointer2;
      var point2;
      var startPoint2;
      point2 = {
        "x": io.originalPosition.x,
        "y": io.originalPosition.y
      };
      startPoint2 = point2;
      var singlePoint = true;
      for (var i = 1; i < io.downPointers.length; i++) {
        var nextPointer = io.downPointers.getIndex(i);
        if (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {
          singlePoint = false;
          pointer2 = nextPointer;
          point2 = pointer2.point;
          startPoint2 = pointer2.startPoint;
          break;
        }
      }
      var pointer1Moved = pointer1 && this.moved(pointer1, 0);
      if (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {
        if (io.events.isEnabled("dragstart") && !system.isPaused) {
          io.events.dispatchImmediately("dragstart", pointer1.dragStartEvents.shift());
        }
      }
      if (singlePoint && io.draggable) {
        this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);
        if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, "hitTolerance"))) {
          this.cancelAllHovers(ev);
        }
      } else {
        var pointer2Moved = pointer2 && this.moved(pointer2, 0);
        if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, "hitTolerance")) || this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, "hitTolerance"))) {
          this.cancelAllHovers(ev);
        }
        if (io.draggable && io.resizable) {
          this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);
          this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);
        } else {
          if (io.draggable) {
            this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);
          }
          if (io.resizable && (!singlePoint || ev.ctrlKey)) {
            this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);
          }
        }
      }
    };
    Interaction2.prototype.handleTransformMove = function(io, point, startPoint, ev, pointerMoved, touch) {
      if (pointerMoved) {
        if (io.events.isEnabled("drag") && !system.isPaused && (!io.isTouchProtected || !touch)) {
          var imev = {
            type: "drag",
            target: io,
            event: ev,
            shift: {
              "x": point.x - startPoint.x,
              "y": point.y - startPoint.y
            },
            startPoint,
            point,
            touch
          };
          io.events.dispatchImmediately("drag", imev);
        }
      }
    };
    Interaction2.prototype.handleTransformResize = function(io, point1, startPoint1, point2, startPoint2, ev, pointerMoved, touch) {
      if (io.events.isEnabled("resize") && !system.isPaused && (!io.isTouchProtected || !touch)) {
        var imev = {
          type: "resize",
          target: io,
          event: ev,
          scale: getScale(point1, startPoint1, point2, startPoint2),
          startPoint1,
          point1,
          startPoint2,
          point2,
          touch
        };
        io.events.dispatchImmediately("resize", imev);
      }
    };
    Interaction2.prototype.processDragStart = function(io, pointer, ev) {
      this.transformedObjects.moveValue(io);
      if (this.shouldCancelHovers(pointer)) {
        this.cancelAllHovers(ev);
      }
      var imev = {
        type: "dragstart",
        target: io,
        event: ev,
        touch: pointer ? pointer.touch : false
      };
      if (pointer) {
        pointer.dragTarget = io;
      }
      if (pointer && pointer.dragStartEvents) {
        pointer.dragStartEvents.push(imev);
      } else {
        if (!system.isPaused) {
          io.dispatchImmediately("dragstart", imev);
        }
      }
    };
    Interaction2.prototype.processDragStop = function(io, pointer, ev) {
      if (!pointer) {
        pointer = this.getDragPointer(io);
      }
      if (pointer) {
        pointer.dragTarget = void 0;
      }
      this.transformedObjects.removeValue(io);
      if (!pointer || this.moved(pointer, 0)) {
        if (io.events.isEnabled("dragstop") && !system.isPaused) {
          var imev = {
            type: "dragstop",
            target: io,
            touch: pointer ? pointer.touch : false
          };
          io.events.dispatchImmediately("dragstop", imev);
        }
      }
    };
    Interaction2.prototype.processResizeStart = function(io, pointer, ev) {
      this.transformedObjects.moveValue(io);
    };
    Interaction2.prototype.processResizeStop = function(io, pointer, ev) {
      this.transformedObjects.removeValue(io);
    };
    Interaction2.prototype.dragStart = function(io, pointer) {
      if (!pointer) {
        pointer = this.getDragPointer(io);
      }
      if (pointer) {
        this.handleDown(io, pointer, pointer.lastDownEvent);
      }
    };
    Interaction2.prototype.dragStop = function(io, pointer, cancelled) {
      if (!pointer) {
        pointer = this.getDragPointer(io);
      }
      if (pointer && !cancelled) {
        this.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);
      }
    };
    Interaction2.prototype.getDragPointer = function(io) {
      if (io) {
        return io.downPointers.getIndex(0);
      } else if (this.transformedObjects.length) {
        return this.getDragPointer(this.transformedObjects.getIndex(0));
      } else {
        return void 0;
      }
    };
    Interaction2.prototype.getPointerId = function(ev) {
      var id = "";
      if (hasValue(ev.identifier)) {
        id = "" + ev.identifier;
      } else if (hasValue(ev.pointerId)) {
        id = "" + ev.pointerId;
      } else {
        id = "m";
      }
      return id.replace("-", "");
    };
    Interaction2.prototype.getPointerPoint = function(ev) {
      return {
        "x": ev.clientX,
        "y": ev.clientY
      };
    };
    Interaction2.prototype.getPointer = function(ev) {
      var id = this.getPointerId(ev);
      var point = this.getPointerPoint(ev);
      var pointer;
      if (this.pointers.hasKey(id)) {
        pointer = this.pointers.getKey(id);
        pointer.touch = this.isPointerTouch(ev);
      } else {
        pointer = {
          "id": id,
          //"touch": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != "pointer"),
          //"touch": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != "mouse"),
          "touch": this.isPointerTouch(ev),
          "startPoint": point,
          "startTime": getTime(),
          "point": point,
          "track": [],
          "swipeCanceled": false,
          "dragStartEvents": []
        };
        this.addBreadCrumb(pointer, point);
        this.pointers.setKey(id, pointer);
      }
      pointer.lastEvent = ev;
      this.lastPointer = pointer;
      return pointer;
    };
    Interaction2.prototype.isPointerTouch = function(ev) {
      if (typeof Touch !== "undefined" && ev instanceof Touch) {
        return true;
      } else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && hasValue(ev.pointerType)) {
        switch (ev.pointerType) {
          case "touch":
          case "pen":
          case 2:
            return true;
          case "mouse":
          case 4:
            return false;
          default:
            return !(ev instanceof MouseEvent);
        }
      } else if (hasValue(ev.type)) {
        if (ev.type.match(/^mouse/)) {
          return false;
        }
      }
      return true;
    };
    Interaction2.prototype.resetPointer = function(pointer, ev) {
      var point = this.getPointerPoint(ev);
      ;
      pointer.startTime = getTime();
      pointer.startPoint = { x: point.x, y: point.y };
      pointer.point = { x: point.x, y: point.y };
      pointer.track = [];
      pointer.swipeCanceled = false;
    };
    Interaction2.prototype.addBreadCrumb = function(pointer, point) {
      pointer.track.push({
        "timestamp": getTime(),
        "point": point
      });
    };
    Interaction2.prototype.lockDocument = function() {
      this.prepElement(this.body);
    };
    Interaction2.prototype.unlockDocument = function() {
      if (this.transformedObjects.length == 0) {
        this.restoreAllStyles(this.body);
      }
    };
    Interaction2.prototype.lockElement = function(io) {
      this.prepElement(io);
    };
    Interaction2.prototype.unlockElement = function(io) {
      this.restoreAllStyles(io);
    };
    Interaction2.prototype.lockWheel = function() {
      window.addEventListener(this._pointerEvents.wheel, this.wheelLockEvent, this._passiveSupported ? { passive: false } : false);
    };
    Interaction2.prototype.unlockWheel = function() {
      window.removeEventListener(this._pointerEvents.wheel, this.wheelLockEvent);
    };
    Interaction2.prototype.isLocalElement = function(pointer, svg, id) {
      var cached = this.getCache("local_pointer_" + pointer.id);
      if (hasValue(cached)) {
        return cached;
      }
      var doc = getRoot(svg) || document;
      if (doc.elementFromPoint) {
        var target = doc.elementFromPoint(pointer.point.x, pointer.point.y);
        var local = target && contains2(svg, target);
        this.setCache("local_pointer_" + pointer.id + "_" + id, local, 100);
        return local;
      }
      return false;
    };
    Interaction2.prototype.wheelLockEvent = function(ev) {
      ev.preventDefault();
      return false;
    };
    Interaction2.prototype.prepElement = function(io) {
      var el = io.element;
      if (el) {
        var props = [
          "touchAction",
          "webkitTouchAction",
          "MozTouchAction",
          "MSTouchAction",
          "msTouchAction",
          "oTouchAction",
          "userSelect",
          "webkitUserSelect",
          "MozUserSelect",
          "MSUserSelect",
          "msUserSelect",
          "oUserSelect",
          "touchSelect",
          "webkitTouchSelect",
          "MozTouchSelect",
          "MSTouchSelect",
          "msTouchSelect",
          "oTouchSelect",
          "touchCallout",
          "webkitTouchCallout",
          "MozTouchCallout",
          "MSTouchCallout",
          "msTouchCallout",
          "oTouchCallout",
          "contentZooming",
          "webkitContentZooming",
          "MozContentZooming",
          "MSContentZooming",
          "msContentZooming",
          "oContentZooming",
          "userDrag",
          "webkitUserDrag",
          "MozUserDrag",
          "MSUserDrag",
          "msUserDrag",
          "oUserDrag"
        ];
        for (var i = 0; i < props.length; i++) {
          if (props[i] in el.style) {
            this.setTemporaryStyle(io, props[i], "none");
          }
        }
        this.setTemporaryStyle(io, "tapHighlightColor", "rgba(0, 0, 0, 0)");
      }
    };
    Interaction2.prototype.unprepElement = function(io) {
      var el = io.element;
      if (el) {
        var props = [
          "touchAction",
          "webkitTouchAction",
          "MozTouchAction",
          "MSTouchAction",
          "msTouchAction",
          "oTouchAction",
          "userSelect",
          "webkitUserSelect",
          "MozUserSelect",
          "MSUserSelect",
          "msUserSelect",
          "oUserSelect",
          "touchSelect",
          "webkitTouchSelect",
          "MozTouchSelect",
          "MSTouchSelect",
          "msTouchSelect",
          "oTouchSelect",
          "touchCallout",
          "webkitTouchCallout",
          "MozTouchCallout",
          "MSTouchCallout",
          "msTouchCallout",
          "oTouchCallout",
          "contentZooming",
          "webkitContentZooming",
          "MozContentZooming",
          "MSContentZooming",
          "msContentZooming",
          "oContentZooming",
          "userDrag",
          "webkitUserDrag",
          "MozUserDrag",
          "MSUserDrag",
          "msUserDrag",
          "oUserDrag"
        ];
        for (var i = 0; i < props.length; i++) {
          if (props[i] in el.style) {
            this.restoreStyle(io, props[i]);
          }
        }
        this.restoreStyle(io, "tapHighlightColor");
      }
    };
    Interaction2.prototype.getHitOption = function(io, option) {
      var res = io.hitOptions[option];
      if (typeof res === "undefined") {
        res = this.hitOptions[option];
      }
      return res;
    };
    Interaction2.prototype.getHoverOption = function(io, option) {
      var res = io.hoverOptions[option];
      if (typeof res === "undefined") {
        res = this.hoverOptions[option];
      }
      return res;
    };
    Interaction2.prototype.getSwipeOption = function(io, option) {
      var res = io.swipeOptions[option];
      if (typeof res === "undefined") {
        res = this.swipeOptions[option];
      }
      return res;
    };
    Interaction2.prototype.getKeyboardOption = function(io, option) {
      var res = io.keyboardOptions[option];
      if (typeof res === "undefined") {
        res = this.keyboardOptions[option];
      }
      return res;
    };
    Interaction2.prototype.getMouseOption = function(io, option) {
      var res = io.mouseOptions[option];
      if (typeof res === "undefined") {
        res = this.mouseOptions[option];
      }
      return res;
    };
    Interaction2.prototype.getInertiaOption = function(io, type, option) {
      var options2 = io.inertiaOptions.getKey(type);
      var res;
      if (options2 && hasValue(options2[option])) {
        res = options2[option];
      } else {
        res = this.inertiaOptions.getKey(type)[option];
      }
      return res;
    };
    Interaction2.prototype.stopInertia = function(io) {
      var x;
      var inertias = ["move", "resize"];
      for (var i = 0; i < inertias.length; i++) {
        x = inertias[i];
        if (io.inertias.hasKey(x)) {
          var inertia = io.inertias.getKey(x);
          if (inertia) {
            inertia.dispose();
            continue;
          }
        }
      }
    };
    Interaction2.prototype.swiping = function(io, pointer) {
      var now2 = getTime();
      if (pointer.swipeCanceled || !io.swipeable) {
        return false;
      } else if (Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, "verticalThreshold") && pointer.startTime > now2 - this.getSwipeOption(io, "time")) {
        return true;
      } else {
        return false;
      }
    };
    Interaction2.prototype.swiped = function(io, pointer) {
      var now2 = getTime();
      if (pointer.swipeCanceled) {
        return false;
      } else if (Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, "horizontalThreshold") && Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, "verticalThreshold") && pointer.startTime > now2 - this.getSwipeOption(io, "time")) {
        return true;
      } else {
        return false;
      }
    };
    Interaction2.prototype.applyCursorOverStyle = function(io) {
      var options2 = io.cursorOptions;
      if (!hasValue(options2.overStyle)) {
        return;
      }
      for (var i = 0; i < options2.overStyle.length; i++) {
        setStyle(io.element, options2.overStyle[i].property, options2.overStyle[i].value);
      }
    };
    Interaction2.prototype.applyCursorDownStyle = function(io, pointer) {
      if (pointer && pointer.touch) {
        return;
      }
      var downStyle = io.cursorOptions.downStyle;
      if (io.downPointers.contains(pointer) && hasValue(downStyle)) {
        for (var i = 0; i < downStyle.length; i++) {
          this.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);
          this.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);
        }
      }
    };
    Interaction2.prototype.restoreCursorDownStyle = function(io, pointer) {
      if (pointer && pointer.touch) {
        return;
      }
      var downStyle = io.cursorOptions.downStyle;
      if (io.downPointers.contains(pointer) && hasValue(downStyle)) {
        for (var i = 0; i < downStyle.length; i++) {
          this.restoreStyle(this.body, downStyle[i].property);
          this.restoreStyle(io, downStyle[i].property);
        }
      }
    };
    Interaction2.prototype.setGlobalStyle = function(style) {
      var body = getInteraction().body;
      var styles = isArray(style) ? style : [style];
      for (var i = 0; i < styles.length; i++) {
        this.setTemporaryStyle(body, styles[i].property, styles[i].value);
      }
    };
    Interaction2.prototype.restoreGlobalStyle = function(style) {
      var body = getInteraction().body;
      var styles = isArray(style) ? style : [style];
      for (var i = 0; i < styles.length; i++) {
        this.restoreStyle(body, styles[i].property);
      }
    };
    Interaction2.prototype.isGlobalElement = function(io) {
      return document.body === io.element;
    };
    Interaction2.prototype.moved = function(pointer, tolerance, minTime) {
      if (minTime === void 0) {
        minTime = 300;
      }
      var shift = this.getShift(pointer);
      return Math.abs(shift.x) > tolerance || Math.abs(shift.y) > tolerance;
    };
    Interaction2.prototype.old = function(pointer, minTime) {
      if (minTime === void 0) {
        minTime = 300;
      }
      return getTime() - pointer.startTime > minTime;
    };
    Interaction2.prototype.getShift = function(pointer) {
      return {
        "x": pointer.startPoint.x - pointer.point.x,
        "y": pointer.startPoint.y - pointer.point.y
      };
    };
    Interaction2.prototype.getTrailPoint = function(pointer, timestamp) {
      var res;
      for (var i = 0; i < pointer.track.length; i++) {
        if (pointer.track[i].timestamp >= timestamp) {
          res = pointer.track[i];
          break;
        }
      }
      return res;
    };
    Interaction2.prototype.pointerExists = function(list, pointer) {
      var exists = false;
      list.each(function(item) {
        if (item == pointer) {
          return;
        }
        exists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;
      });
      return exists;
    };
    Interaction2.prototype.getInteraction = function(element) {
      return new InteractionObject(element);
    };
    Interaction2.prototype.setTemporaryStyle = function(io, property, value) {
      var el = io.element;
      if (hasValue(el.style[property]) && !io.replacedStyles.hasKey(property)) {
        io.replacedStyles.setKey(property, el.style[property]);
      }
      setStyle(el, property, value);
    };
    Interaction2.prototype.restoreStyle = function(io, property) {
      if (io.replacedStyles.hasKey(property)) {
        io.element.style[property] = io.replacedStyles.getKey(property);
        io.replacedStyles.removeKey(property);
      } else {
        delete io.element.style[property];
      }
    };
    Interaction2.prototype.restoreAllStyles = function(io) {
      each3(io.replacedStyles.iterator(), function(a) {
        var key = a[0];
        var value = a[1];
        io.element.style[key] = value;
        io.replacedStyles.removeKey(key);
      });
    };
    Interaction2.prototype.dispose = function() {
      if (!this.isDisposed()) {
        _super.prototype.dispose.call(this);
        this.restoreAllStyles(this.body);
        this.unlockWheel();
      }
    };
    Interaction2.prototype.log = function(text, ev, io) {
      var show = true;
      if (show) {
        if (ev.changedTouches) {
          for (var i = 0; i < ev.changedTouches.length; i++) {
            this.logTouch(text, ev.type, ev.changedTouches[i]);
          }
          return;
        }
        var type = "";
        if (ev.pointerType) {
          switch (ev.pointerType) {
            case 2:
              type = "touch";
              break;
            case 4:
              type = "mouse";
              break;
            default:
              type = ev.pointerType;
              break;
          }
        } else if (typeof TouchEvent != "undefined" && ev instanceof TouchEvent) {
          type = "touch";
        } else if (ev.type.match(/^mouse/)) {
          type = "mouse";
        } else {
          type = "???";
        }
        var id = "";
        if (hasValue(ev.identifier)) {
          id = ev.identifier;
        } else if (hasValue(ev.pointerId)) {
          id = ev.pointerId;
        } else {
          id = "???";
        }
        if (io) {
          console.log(text + " (" + io.uid + ")  " + ev.type + "  " + type + "  " + id);
        } else {
          console.log(text + "  " + ev.type + "  " + type + "  " + id);
        }
      }
    };
    Interaction2.prototype.areTransformed = function(except) {
      var count = this.transformedObjects.length;
      if (except) {
        var ex = isArray(except) ? except : [except];
        for (var i = 0; i < ex.length; i++) {
          if (this.transformedObjects.contains(ex[i])) {
            count--;
          }
        }
      }
      return count > 0;
    };
    Interaction2.prototype.logTouch = function(text, type, ev) {
      console.log(text + "  " + type + "  touch  " + ev.identifier);
    };
    Object.defineProperty(Interaction2, "passiveSupported", {
      /**
       * Indicates if passive mode options is supported by this browser.
       */
      get: function() {
        var _this = this;
        if (this._passiveSupported == null) {
          try {
            var options_1 = Object.defineProperty({}, "passive", {
              get: function() {
                _this._passiveSupported = true;
              }
            });
            window.addEventListener("test", options_1, options_1);
            window.removeEventListener("test", options_1, options_1);
          } catch (err) {
            this._passiveSupported = false;
          }
        }
        return this._passiveSupported;
      },
      enumerable: true,
      configurable: true
    });
    return Interaction2;
  }(BaseObjectEvents)
);
var interaction = null;
function getInteraction() {
  if (interaction == null) {
    interaction = new Interaction();
  }
  return interaction;
}

// node_modules/@amcharts/amcharts4/.internal/core/elements/Popup.js
var Popup = (
  /** @class */
  function(_super) {
    __extends(Popup2, _super);
    function Popup2() {
      var _this = _super.call(this) || this;
      _this.adapter = new Adapter(_this);
      _this._elements = {};
      _this._IOs = {};
      _this._content = "";
      _this._title = "";
      _this._classPrefix = "ampopup";
      _this._defaultStyles = true;
      _this._showCurtain = false;
      _this._draggable = true;
      _this._align = "center";
      _this._dynamicResize = true;
      _this._verticalAlign = "middle";
      _this._shift = {
        x: 0,
        y: 0
      };
      _this._tempShift = {
        x: 0,
        y: 0
      };
      _this._readerTitle = "";
      _this._closable = true;
      _this._cssLoaded = false;
      _this._fitTo = "window";
      _this.isTemplate = false;
      _this._sized = false;
      _this.className = "Popup";
      return _this;
    }
    Popup2.prototype.open = function() {
      if (this.container) {
        if (this._elements.wrapper) {
          this.container.appendChild(this._elements.wrapper);
        }
        if (this._elements.curtain) {
          this.container.appendChild(this._elements.curtain);
          this.showCurtain = this.showCurtain;
        }
        this.positionElement();
        this.dispatchImmediately("opened");
      }
    };
    Popup2.prototype.close = function() {
      if (this._elements.wrapper) {
        if (this._elements.wrapper.parentElement) {
          this._elements.wrapper.parentElement.removeChild(this._elements.wrapper);
        }
      }
      if (this._elements.curtain) {
        if (this._elements.curtain.parentElement) {
          this._elements.curtain.parentElement.removeChild(this._elements.curtain);
        }
      }
      this.dispatchImmediately("closed");
      this.releasePointers();
    };
    Popup2.prototype.dispose = function() {
      this.close();
      _super.prototype.dispose.call(this);
    };
    Popup2.prototype.positionElement = function(forceResize) {
      var _this = this;
      if (forceResize === void 0) {
        forceResize = true;
      }
      if (!this._elements.wrapper) {
        return;
      }
      setTimeout(function() {
        if (!_this._elements.wrapper) {
          return;
        }
        if (forceResize || !_this._sized) {
          _this._elements.wrapper.style.opacity = "0.01";
          _this._elements.wrapper.style.left = "0";
          _this._elements.wrapper.style.top = "0";
          _this._elements.wrapper.style.margin = "0 0 0 0";
          _this._elements.wrapper.style.width = "";
          _this._elements.wrapper.style.height = "";
          var bbox = _this._elements.wrapper.getBoundingClientRect();
          _this._elements.wrapper.style.width = bbox.width + "px";
          _this._elements.wrapper.style.height = bbox.height + "px";
          _this._sized = true;
        }
        if (_this.dynamicResize) {
          var images = _this._elements.wrapper.getElementsByTagName("img");
          for (var i = 0; i < images.length; i++) {
            var image = images[i];
            if (!image.complete) {
              image.addEventListener("load", function() {
                _this.positionElement(true);
              });
              break;
            }
          }
        }
        setTimeout(function() {
          if (!_this._elements.wrapper) {
            return;
          }
          var bbox2;
          if ((forceResize || !_this._sized) && _this._bbox) {
            bbox2 = _this._bbox;
          } else {
            bbox2 = _this._elements.wrapper.getBoundingClientRect();
            _this._elements.wrapper.style.opacity = "";
          }
          switch (_this.align) {
            case "left":
              _this._elements.wrapper.style.left = "0";
              _this._elements.wrapper.style.right = "auto";
              _this._elements.wrapper.style.marginLeft = _this.toStyle(_this._shift.x + _this._tempShift.x);
              break;
            case "center":
              _this._elements.wrapper.style.left = "50%";
              _this._elements.wrapper.style.right = "auto";
              _this._elements.wrapper.style.marginLeft = _this.toStyle(Math.round(-bbox2.width / 2) + (_this._shift.x + _this._tempShift.x));
              break;
            case "right":
              _this._elements.wrapper.style.left = "auto";
              _this._elements.wrapper.style.right = "0";
              _this._elements.wrapper.style.marginLeft = _this.toStyle(_this._shift.x + _this._tempShift.x);
              break;
            default:
              _this._elements.wrapper.style.left = _this.toStyle(_this.left) || "auto";
              _this._elements.wrapper.style.right = _this.toStyle(_this.right) || "auto";
              _this._elements.wrapper.style.marginLeft = _this.toStyle(_this._shift.x + _this._tempShift.x);
              break;
          }
          switch (_this.verticalAlign) {
            case "top":
              _this._elements.wrapper.style.top = "0";
              _this._elements.wrapper.style.bottom = "auto";
              _this._elements.wrapper.style.marginTop = _this.toStyle(_this._shift.y + _this._tempShift.y);
              break;
            case "middle":
              _this._elements.wrapper.style.top = "50%";
              _this._elements.wrapper.style.bottom = "auto";
              _this._elements.wrapper.style.marginTop = _this.toStyle(Math.round(-bbox2.height / 2) + (_this._shift.y + _this._tempShift.y));
              break;
            case "bottom":
              _this._elements.wrapper.style.top = "auto";
              _this._elements.wrapper.style.bottom = "0";
              _this._elements.wrapper.style.marginTop = _this.toStyle(_this._shift.y + _this._tempShift.y);
              break;
            default:
              _this._elements.wrapper.style.top = _this.toStyle(_this.top) || "auto";
              _this._elements.wrapper.style.bottom = _this.toStyle(_this.bottom) || "auto";
              _this._elements.wrapper.style.marginTop = _this.toStyle(_this._shift.y + _this._tempShift.y);
              break;
          }
        }, 1);
      }, 1);
    };
    Popup2.prototype.setupDragging = function() {
      var _this = this;
      if (this.draggable) {
        if (!this._IOs.header.events.has("drag")) {
          this._IOs.header.events.on("drag", function(ev) {
            _this._tempShift.x = ev.shift.x;
            _this._tempShift.y = ev.shift.y;
            _this.positionElement(false);
          });
        }
        if (!this._IOs.header.events.has("dragstop")) {
          this._IOs.header.events.on("dragstop", function(ev) {
            _this._shift.x += _this._tempShift.x;
            _this._shift.y += _this._tempShift.y;
            _this._tempShift.x = 0;
            _this._tempShift.y = 0;
            _this.positionElement(false);
          });
        }
      } else {
        if (this._IOs.header) {
          getInteraction().unprepElement(this._IOs.header);
          if (this._IOs.header.events.has("drag")) {
            this._IOs.header.events.off("drag");
          }
          if (this._IOs.header.events.has("dragstop")) {
            this._IOs.header.events.off("dragstop");
          }
        }
      }
    };
    Popup2.prototype.toStyle = function(value) {
      if (!hasValue(value)) {
        return null;
      } else if (isNumber(value)) {
        return "" + value + "px";
      } else {
        return value.toString();
      }
    };
    Object.defineProperty(Popup2.prototype, "classPrefix", {
      /**
       * A prefix that is applied to class names of various popup elements.
       *
       * @return Class name prefix
       */
      get: function() {
        return this.adapter.apply("classPrefix", this._classPrefix);
      },
      /**
       * @param value Class name prefix
       */
      set: function(value) {
        this._classPrefix = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "classPrefixRaw", {
      /**
       * Returns raw prefix (without adapters applied).
       *
       * @ignore Exclude from docs
       * @return Class name prefix
       */
      get: function() {
        return this._classPrefix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "content", {
      /**
       * @return Popup content
       */
      get: function() {
        return this.adapter.apply("content", this._content);
      },
      /**
       * Popup content.
       *
       * Popup content can be any valid HTML, including CSS.
       *
       * @param value Popup content
       */
      set: function(value) {
        if (this._content != value) {
          this._content = value;
          if (!this._elements.content) {
            this.createContentElement();
          }
          this._elements.content.innerHTML = value;
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Popup2.prototype.getClassNames = function() {
      return this.adapter.apply("classNames", {
        wrapperClass: this.classPrefix + "",
        headerClass: this.classPrefix + "-header",
        titleClass: this.classPrefix + "-title",
        contentClass: this.classPrefix + "-content",
        insideClass: this.classPrefix + "-inside",
        curtainClass: this.classPrefix + "-curtain",
        closeClass: this.classPrefix + "-close"
      });
    };
    Popup2.prototype.createContentElement = function() {
      if (this._elements.wrapper) {
        return;
      }
      var classNames = this.getClassNames();
      var wrapper = document.createElement("div");
      wrapper.className = classNames.contentClass;
      wrapper.style.opacity = "0.01";
      var close = document.createElement("a");
      close.className = classNames.closeClass;
      var header = document.createElement("div");
      header.className = classNames.headerClass;
      var title = document.createElement("div");
      title.innerHTML = this.title;
      title.className = classNames.titleClass;
      if (!this.title) {
        title.style.display = "none";
      }
      var content = document.createElement("div");
      content.className = classNames.insideClass;
      content.innerHTML = this.content;
      this._IOs.wrapper = getInteraction().getInteraction(wrapper);
      this._IOs.header = getInteraction().getInteraction(header);
      this._disposers.push(this._IOs.wrapper);
      this._IOs.wrapper.events.on("over", this.disablePointers, this);
      this._IOs.wrapper.events.on("out", this.releasePointers, this);
      this._IOs.close = getInteraction().getInteraction(close);
      this._disposers.push(this._IOs.close);
      close.style.visibility = "hidden";
      wrapper.setAttribute("role", "dialog");
      header.appendChild(close);
      header.appendChild(title);
      wrapper.appendChild(header);
      wrapper.appendChild(content);
      this.container.appendChild(wrapper);
      this._elements.wrapper = wrapper;
      this._elements.header = header;
      this._elements.content = content;
      this._elements.title = title;
      this._elements.close = close;
      if (this.defaultStyles) {
        this.loadDefaultCSS();
      }
      this.createCurtainElement();
      this.applyEvents();
      this.applyReaderSettings();
      this.setupDragging();
    };
    Object.defineProperty(Popup2.prototype, "title", {
      /**
       * @return Popup title
       */
      get: function() {
        return this.adapter.apply("title", this._title);
      },
      /**
       * Popup title.
       *
       * Popup title can be any valid HTML, including CSS.
       *
       * @param value  Popup title
       */
      set: function(value) {
        if (this._title != value) {
          this._title = value;
          if (!this._elements.content) {
            this.createContentElement();
          }
          this._elements.title.innerHTML = value;
          this.positionElement();
          this.applyReaderSettings();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "readerTitle", {
      /**
       * @return Popup content
       */
      get: function() {
        return this.adapter.apply("readerTitle", this._readerTitle != "" ? this._readerTitle : this.title);
      },
      /**
       * A title for screen readers. It is very highly recommended to set that title
       * so that people using screen reader tools can get an immediate summary of
       * the information in the popup.
       *
       * @param value  Reader title
       */
      set: function(value) {
        if (this._readerTitle != value) {
          this._readerTitle = value;
          this.applyReaderSettings();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "closable", {
      /**
       * @return Closable?
       */
      get: function() {
        return this.adapter.apply("closable", this._closable);
      },
      /**
       * Is popup closable?
       *
       * If it is, it can be closed in a number of ways, e.g. by hitting ESC key,
       * clicking curtain, or clicking the close button.
       *
       * If it is not closable, the only way to close it is via `close()` call.
       *
       * @param value Closable?
       */
      set: function(value) {
        if (value !== this._closable) {
          this._closable = value;
          this.applyEvents();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "fitTo", {
      /**
       * @ignore
       * @todo Implement
       * @return Fit option
       */
      get: function() {
        return this.adapter.apply("fitTo", this._fitTo);
      },
      /**
       * If set to other than "none" will try to re-adjust the position of the
       * popop to fit within chart container or browser window.
       *
       * @ignore
       * @todo Implement
       * @default "window"
       * @param value  Fit option
       */
      set: function(value) {
        if (value != this._fitTo) {
          this._fitTo = value;
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "defaultStyles", {
      /**
       * @return Use default CSS?
       */
      get: function() {
        return this.adapter.apply("defaultStyles", this._defaultStyles);
      },
      /**
       * Should popup use default CSS?
       *
       * If default CSS is disabled, an external CSS should handle the look of the
       * popup, since it will look quite out of place otherwise.
       *
       * @default true
       * @param Use default CSS?
       */
      set: function(value) {
        if (this._defaultStyles != value) {
          this._defaultStyles = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "showCurtain", {
      /**
       * @return Show curtain?
       */
      get: function() {
        return this.adapter.apply("showCurtain", this._showCurtain);
      },
      /**
       * Should popup use dim out all content behind it?
       *
       * @default false
       * @param Show curtain?
       */
      set: function(value) {
        if (this._showCurtain != value) {
          this._showCurtain = value;
          if (this._elements.curtain) {
            this._elements.curtain.style.display = value ? "block" : "none";
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Popup2.prototype.createCurtainElement = function() {
      var classNames = this.getClassNames();
      var curtain = document.createElement("div");
      curtain.className = classNames.curtainClass;
      this.container.appendChild(curtain);
      this._IOs.curtain = getInteraction().getInteraction(curtain);
      this._disposers.push(this._IOs.curtain);
      this._IOs.curtain.events.on("over", this.disablePointers, this);
      this._IOs.curtain.events.on("out", this.releasePointers, this);
      curtain.style.display = this.showCurtain ? "block" : "none";
      this._elements.curtain = curtain;
    };
    Object.defineProperty(Popup2.prototype, "draggable", {
      /**
       * @return Show curtain?
       */
      get: function() {
        return this.adapter.apply("draggable", this._draggable);
      },
      /**
       * Can the popup be dragged with a pointer?
       *
       * @default false
       * @param Show curtain?
       */
      set: function(value) {
        if (this._draggable != value) {
          this._draggable = value;
          this.setupDragging();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "dynamicResize", {
      /**
       * @return Resize dynamically?
       */
      get: function() {
        return this.adapter.apply("dynamicResize", this._dynamicResize);
      },
      /**
       * Resize popup as images are being loaded.
       *
       * @default true
       * @since 4.9.17
       * @param Resize dynamically?
       */
      set: function(value) {
        if (this._dynamicResize != value) {
          this._dynamicResize = value;
          this.positionElement(true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "align", {
      /**
       * @return Horizontal position
       */
      get: function() {
        return this.adapter.apply("align", this._align);
      },
      /**
       * Horizontal positioning of the content window.
       *
       * Available options: "left", "center" (default), "right", and "none".
       *
       * @default "center"
       * @param Horizontal position
       */
      set: function(value) {
        if (this._align != value) {
          this._align = value;
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "verticalAlign", {
      /**
       * @return Vertical position
       */
      get: function() {
        return this.adapter.apply("verticalAlign", this._verticalAlign);
      },
      /**
       * Vertical positioning of the content window.
       *
       * Available options: "top", "middle" (default), "bottom", and "none".
       *
       * @default "middle"
       * @param Vertical position
       */
      set: function(value) {
        if (this._verticalAlign != value) {
          this._verticalAlign = value;
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "left", {
      /**
       * @return Left
       */
      get: function() {
        return this.adapter.apply("left", this._left);
      },
      /**
       * "left" coordinate of a non-aligned (`align = "none"`) popup.
       *
       * Can be either absolute pixel value, or relative (`Percent`).
       *
       * Setting this property will automatically set `align` to "none".
       *
       * NOTE: The position is relative to the chart container.
       *
       * @param Left
       */
      set: function(value) {
        if (this.left != value) {
          this._left = value;
          this._align = "none";
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "right", {
      /**
       * @return Right
       */
      get: function() {
        return this.adapter.apply("right", this._right);
      },
      /**
       * "right" coordinate of a non-aligned (`align = "none"`) popup.
       *
       * Can be either absolute pixel value, or relative (`Percent`).
       *
       * Setting this property will automatically set `align` to "none".
       *
       * NOTE: The position is relative to the chart container.
       *
       * @param Right
       */
      set: function(value) {
        if (this.right != value) {
          this._right = value;
          this._align = "none";
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "top", {
      /**
       * @return Top
       */
      get: function() {
        return this.adapter.apply("top", this._top);
      },
      /**
       * "top" coordinate of a non-aligned (`verticalAlign = "none"`) popup.
       *
       * Can be either absolute pixel value, or relative (`Percent`).
       *
       * Setting this property will automatically set `verticalAlign` to "none".
       *
       * NOTE: The position is relative to the chart container.
       *
       * @param Top
       */
      set: function(value) {
        if (this.top != value) {
          this._top = value;
          this._verticalAlign = "none";
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "bottom", {
      /**
       * @return Bottom
       */
      get: function() {
        return this.adapter.apply("bottom", this._bottom);
      },
      /**
       * "bottom" coordinate of a non-aligned (`verticalAlign = "none"`) popup.
       *
       * Can be either absolute pixel value, or relative (`Percent`).
       *
       * Setting this property will automatically set `verticalAlign` to "none".
       *
       * NOTE: The position is relative to the chart container.
       *
       * @param Bottom
       */
      set: function(value) {
        if (this.bottom != value) {
          this._bottom = value;
          this._verticalAlign = "none";
          this.positionElement();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Popup2.prototype, "elements", {
      /**
       * Returns an object with references to various elements of the Popup.
       *
       * * `wrapper`
       * * `title`
       * * `content`
       * * `close`
       * * `curtain`
       */
      get: function() {
        return this._elements;
      },
      enumerable: true,
      configurable: true
    });
    Popup2.prototype.loadDefaultCSS = function() {
      if (!this._cssLoaded) {
        this._disposers.push(PopupCSS_default(getShadowRoot(this.container), this.classPrefix));
        each2(this._elements, function(key, el) {
          el.style.display = "";
        });
        this._cssLoaded = true;
      }
    };
    Popup2.prototype.applyEvents = function() {
      var _this = this;
      if (this._IOs.close) {
        if (this.closable) {
          this._IOs.close.element.style.visibility = "visible";
          var disposers = [
            getInteraction().body.events.on("keyup", function(ev) {
              if (keyboard.isKey(ev.event, "esc") && _this.closable) {
                _this.close();
              }
            }),
            this._IOs.close.events.on("hit", function(ev) {
              _this.close();
            })
          ];
          disposers.push(this._IOs.curtain.events.on("hit", function(ev) {
            if (_this.showCurtain && _this.closable) {
              _this.close();
            }
          }));
          this._disposers.push(new MultiDisposer(disposers));
        } else {
          this._IOs.close.element.style.visibility = "hidden";
        }
      }
    };
    Popup2.prototype.disablePointers = function() {
      if (this.sprite) {
        this._spriteInteractionsEnabled = this.sprite.interactionsEnabled;
        this.sprite.interactionsEnabled = false;
      }
    };
    Popup2.prototype.releasePointers = function() {
      if (hasValue(this._spriteInteractionsEnabled)) {
        this.sprite.interactionsEnabled = this._spriteInteractionsEnabled;
        this._spriteInteractionsEnabled = void 0;
      }
    };
    Popup2.prototype.applyReaderSettings = function() {
      this.elements.wrapper.setAttribute("aria-label", this.readerTitle);
    };
    Popup2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.container = source.container;
      this.sprite = source.sprite;
      this.classPrefix = source.classPrefixRaw;
      this.content = source.content;
      this.title = source.title;
      this.readerTitle = source.readerTitle;
      this.defaultStyles = source.defaultStyles;
      this.showCurtain = source.showCurtain;
      this.align = source.align;
      this.verticalAlign = source.verticalAlign;
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.adapter.copyFrom(source.adapter);
    };
    return Popup2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/elements/Modal.js
var Modal = (
  /** @class */
  function(_super) {
    __extends(Modal2, _super);
    function Modal2() {
      var _this = _super.call(this) || this;
      _this.adapter = new Adapter(_this);
      _this.className = "Modal";
      _this.showCurtain = true;
      _this.draggable = false;
      return _this;
    }
    return Modal2;
  }(Popup)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Log.js
function log() {
  var messages = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    messages[_i] = arguments[_i];
  }
  if (options.verbose) {
    if (console) {
      console.log.apply(console, __spread(messages));
    }
  }
}
function warn() {
  var messages = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    messages[_i] = arguments[_i];
  }
  if (!options.suppressWarnings) {
    if (console) {
      console.warn.apply(console, __spread(messages));
    }
  }
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/ResizeSensor.js
var Native = (
  /** @class */
  function() {
    function Native2() {
      var _this = this;
      this._targets = [];
      this._observer = new ResizeObserver(function(entries) {
        each(entries, function(entry) {
          each(_this._targets, function(x) {
            if (x.target === entry.target) {
              x.callback();
            }
          });
        });
      });
    }
    Native2.prototype.addTarget = function(target, callback) {
      this._observer.observe(target, { box: "content-box" });
      this._targets.push({ target, callback });
    };
    Native2.prototype.removeTarget = function(target) {
      this._observer.unobserve(target);
      keepIf(this._targets, function(x) {
        return x.target !== target;
      });
    };
    return Native2;
  }()
);
var Raf = (
  /** @class */
  function() {
    function Raf2() {
      this._targets = [];
    }
    Raf2.prototype.addTarget = function(target, callback) {
      var _this = this;
      if (this._targets.length === 0) {
        var lastTime_1 = null;
        var loop_1 = function() {
          var currentTime = Date.now();
          if (lastTime_1 === null || currentTime > lastTime_1 + Raf2.delay) {
            lastTime_1 = currentTime;
            each(_this._targets, function(x) {
              var newSize = x.target.getBoundingClientRect();
              if (newSize.width !== x.size.width || newSize.height !== x.size.height) {
                x.size = newSize;
                x.callback();
              }
            });
          }
          _this._timer = requestAnimationFrame(loop_1);
        };
        this._timer = requestAnimationFrame(loop_1);
      }
      var size = target.getBoundingClientRect();
      this._targets.push({ target, callback, size });
    };
    Raf2.prototype.removeTarget = function(target) {
      keepIf(this._targets, function(x) {
        return x.target !== target;
      });
      if (this._targets.length === 0) {
        cancelAnimationFrame(this._timer);
      }
    };
    Raf2.delay = 200;
    return Raf2;
  }()
);
var observer = null;
function makeSensor() {
  if (observer === null) {
    if (typeof ResizeObserver !== "undefined") {
      observer = new Native();
    } else {
      observer = new Raf();
    }
  }
  return observer;
}
var ResizeSensor = (
  /** @class */
  function() {
    function ResizeSensor2(element, callback) {
      this._disposed = false;
      this._sensor = makeSensor();
      this._element = element;
      this._sensor.addTarget(element, callback);
    }
    ResizeSensor2.prototype.isDisposed = function() {
      return this._disposed;
    };
    ResizeSensor2.prototype.dispose = function() {
      if (!this._disposed) {
        this._disposed = true;
        this._sensor.removeTarget(this._element);
      }
    };
    Object.defineProperty(ResizeSensor2.prototype, "sensor", {
      get: function() {
        return this._sensor;
      },
      enumerable: true,
      configurable: true
    });
    ResizeSensor2.prototype.reset = function() {
      warn("resizeSensor.reset() is no longer needed and can be removed");
    };
    return ResizeSensor2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/rendering/SVGContainer.js
var svgContainers = [];
var SVGContainer = (
  /** @class */
  function() {
    function SVGContainer2(htmlElement, ghost) {
      var _this = this;
      this._disposed = false;
      this.autoResize = true;
      this.nonExportableSprites = [];
      this._disposers = [];
      this.cssScale = 1;
      this._printing = false;
      this.htmlElement = htmlElement;
      if (!ghost) {
        this._printing = false;
        this.initSensor();
        this._disposers.push(addEventListener(window, "beforeprint", function() {
          _this._printing = true;
        }));
        this._disposers.push(addEventListener(window, "afterprint", function() {
          _this._printing = false;
        }));
      }
      svgContainers.push(this);
      var svgContainer = document.createElement("div");
      var style = svgContainer.style;
      style.width = "100%";
      style.height = "100%";
      style.position = "relative";
      htmlElement.appendChild(svgContainer);
      this.SVGContainer = svgContainer;
    }
    SVGContainer2.prototype.initSensor = function() {
      var _this = this;
      if (this.resizeSensor) {
        this.resizeSensor.dispose();
      }
      var callback = function() {
        if (_this.autoResize && !_this._printing) {
          _this.measure();
        }
      };
      this.resizeSensor = new ResizeSensor(this.htmlElement, callback);
      this._disposers.push(this.resizeSensor);
    };
    SVGContainer2.prototype.measure = function() {
      var width2 = width(this.htmlElement);
      var height2 = height(this.htmlElement);
      var container = this.container;
      if (container) {
        if (this.width != width2 || this.height != height2) {
          this.width = width2;
          this.height = height2;
          if (width2 > 0) {
            container.maxWidth = width2;
          }
          if (height2 > 0) {
            container.maxHeight = height2;
          }
          fixPixelPerfect(this.SVGContainer);
        }
        if (!container.maxWidth) {
          container.maxWidth = 0;
        }
        if (!container.maxHeight) {
          container.maxHeight = 0;
        }
        this.cssScale = 1;
        this.checkTransform(this.htmlElement);
      }
    };
    Object.defineProperty(SVGContainer2.prototype, "container", {
      /**
       * @return Container
       */
      get: function() {
        return this._container;
      },
      /**
       * A [[Container]] element which is placed into container.
       *
       * @param container  Container
       */
      set: function(container) {
        this._container = container;
        this.measure();
      },
      enumerable: true,
      configurable: true
    });
    SVGContainer2.prototype.isDisposed = function() {
      return this._disposed;
    };
    SVGContainer2.prototype.dispose = function() {
      if (!this._disposed) {
        remove(svgContainers, this);
      }
      each(this._disposers, function(item) {
        item.dispose();
      });
    };
    Object.defineProperty(SVGContainer2.prototype, "hideOverflow", {
      /**
       * Indicates if chart container should have its style set
       * to `overflow: hidden`.
       *
       * Normally, we don't want that, so that certain elements, such as tooltips,
       * would be able to go outside chart area.
       *
       * There is one issue though. Some browsers ignore SVG masks and would
       * display scrollbars if chart elements, that go outside chart area extend
       * outside window.
       *
       * This is especially true for [[MapChart]], which can have its elements
       * extend very widely when zoomed in. Even if those parts are not visible
       * because of SVG masks, some browsers might still display window scrollbars.
       *
       * This is why we set this setting to `true` in [[MapChart]].
       *
       * Other charts use default of `false`.
       */
      set: function(value) {
        if (value) {
          this.SVGContainer.style.overflow = "hidden";
        } else {
          this.SVGContainer.style.overflow = "";
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SVGContainer2.prototype, "modal", {
      /**
       * ==========================================================================
       * MODAL/POPUP RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns a [[Modal]] instance, associated with this chart.
       * (elements top parent)
       *
       * Accessing modal does not make it appear. To make a modal appear, use
       * `showModal()` method.
       *
       * @see {@link Modal} for more information about using Modal windows
       * @return Modal instance
       */
      get: function() {
        if (!hasValue(this._modal)) {
          this._modal = new Modal();
          this._modal.container = this.SVGContainer;
          this._disposers.push(this._modal);
        }
        return this._modal;
      },
      enumerable: true,
      configurable: true
    });
    SVGContainer2.prototype.openModal = function(text, title) {
      this.closeModal();
      var modal = this.modal;
      modal.content = text;
      modal.readerTitle = title || "";
      modal.title = title || "";
      modal.open();
      return modal;
    };
    SVGContainer2.prototype.closeModal = function() {
      if (this._modal) {
        this.modal.close();
      }
    };
    Object.defineProperty(SVGContainer2.prototype, "popups", {
      /**
       * A list of popups for this chart.
       *
       * @return Popups
       */
      get: function() {
        if (!hasValue(this._popups)) {
          var popupTemplate = new Popup();
          popupTemplate.container = this.SVGContainer;
          this._popups = new ListTemplate(popupTemplate);
          this._disposers.push(new ListDisposer(this._popups));
          this._disposers.push(this._popups.template);
        }
        return this._popups;
      },
      enumerable: true,
      configurable: true
    });
    SVGContainer2.prototype.openPopup = function(text, title) {
      var popup = this.popups.create();
      popup.content = text;
      if (hasValue(title)) {
        popup.title = title;
      }
      popup.open();
      return popup;
    };
    SVGContainer2.prototype.closeAllPopups = function() {
      this.popups.each(function(popup) {
        popup.close();
      });
    };
    Object.defineProperty(SVGContainer2.prototype, "readerAlertElement", {
      /**
       * ==========================================================================
       * ACCESSIBILITY STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * A `<div>` element used as as placeholder to trigger screen alerts.
       *
       * @sunce 4.9.2
       * @return Element
       */
      get: function() {
        if (!hasValue(this._readerAlertElement)) {
          var div = document.createElement("div");
          div.setAttribute("role", "alert");
          div.style.zIndex = "-100000";
          div.style.opacity = "0";
          div.style.position = "absolute";
          div.style.top = "0";
          this.SVGContainer.appendChild(div);
          this._readerAlertElement = div;
        }
        return this._readerAlertElement;
      },
      enumerable: true,
      configurable: true
    });
    SVGContainer2.prototype.readerAlert = function(text) {
      this.readerAlertElement.innerHTML = text;
    };
    SVGContainer2.prototype.checkTransform = function(div) {
      if (window.getComputedStyle) {
        if (div && div.style) {
          var style = window.getComputedStyle(div, null);
          if (style) {
            var matrix = style.getPropertyValue("-webkit-transform") || style.getPropertyValue("-moz-transform") || style.getPropertyValue("-ms-transform") || style.getPropertyValue("-o-transform") || style.getPropertyValue("transform");
            if (matrix && matrix !== "none") {
              var values = matrix.split("(")[1].split(")")[0].split(",");
              var a = Number(values[0]);
              var b = Number(values[1]);
              var scale = Math.sqrt(a * a + b * b);
              if (!isNaN(scale)) {
                this.cssScale *= scale;
              }
            }
          }
        }
        if (div.parentNode && div.parentNode instanceof HTMLElement) {
          this.checkTransform(div.parentNode);
        }
      }
    };
    return SVGContainer2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/rendering/Paper.js
var Paper = (
  /** @class */
  function() {
    function Paper2(container, id) {
      this.container = container;
      this.id = id;
      var svg = document.createElementNS(SVGNS, "svg");
      svg.setAttribute("version", "1.1");
      svg.setAttributeNS(XMLNS, "xmlns", SVGNS);
      svg.setAttributeNS(XMLNS, "xmlns:xlink", XLINK);
      svg.setAttribute("role", "group");
      this.container.appendChild(svg);
      this.defs = document.createElementNS(SVGNS, "defs");
      svg.appendChild(this.defs);
      svg.style.width = "100%";
      svg.style.height = "100%";
      svg.style.overflow = "visible";
      this.svg = svg;
    }
    Paper2.prototype.add = function(elementName) {
      return new AMElement(elementName);
    };
    Paper2.prototype.addGroup = function(groupName) {
      return new Group(groupName);
    };
    Paper2.prototype.append = function(element) {
      if (element) {
        this.svg.appendChild(element.node);
      }
    };
    Paper2.prototype.appendDef = function(element) {
      if (element) {
        this.defs.appendChild(element.node);
      }
    };
    Paper2.prototype.foreignObject = function() {
      var element = new AMElement("foreignObject");
      return element;
    };
    Paper2.prototype.supportsForeignObject = function() {
      return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Extensibility", "1.1");
    };
    return Paper2;
  }()
);
var ghostPaper = null;
function getGhostPaper() {
  if (ghostPaper === null) {
    var ghostDiv = document.createElement("div");
    ghostDiv.hidden = true;
    ghostDiv.style.width = "1px";
    ghostDiv.style.height = "1px";
    ghostDiv.style.position = "absolute";
    ghostDiv.style.zIndex = "-1000000";
    document.body.appendChild(ghostDiv);
    var ghostSvgContainer = new SVGContainer(ghostDiv, true);
    ghostPaper = new Paper(ghostSvgContainer.SVGContainer, "ghost");
  }
  return ghostPaper;
}

// node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/Pattern.js
var Pattern = (
  /** @class */
  function(_super) {
    __extends(Pattern2, _super);
    function Pattern2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._elements = new List();
      _this.properties = {};
      _this.className = "Pattern";
      _this.width = 10;
      _this.height = 10;
      _this.x = 0;
      _this.y = 0;
      _this.patternUnits = "userSpaceOnUse";
      var interfaceColors = new InterfaceColorSet();
      _this.backgroundFill = interfaceColors.getFor("background");
      _this.backgroundOpacity = 0;
      _this.fillOpacity = 1;
      _this.fill = interfaceColors.getFor("alternativeBackground");
      _this.stroke = interfaceColors.getFor("alternativeBackground");
      _this.strokeOpacity = 1;
      _this.strokeWidth = 1;
      _this.shapeRendering = "crispEdges";
      _this.rotation = 0;
      _this.element = _this.paper.addGroup("pattern");
      _this.id = "pattern-" + registry.getUniqueId();
      _this.element.attr({ "id": _this.id });
      _this._disposers.push(_this.element);
      _this._disposers.push(new ListDisposer(_this._elements));
      _this.patternUnits = _this.patternUnits;
      _this.width = _this.width;
      _this.height = _this.height;
      _this.applyTheme();
      return _this;
    }
    Pattern2.prototype.draw = function() {
      var _this = this;
      var patternElement = this.element;
      if (patternElement) {
        patternElement.removeChildNodes();
        var background = this.paper.add("rect");
        background.attr({ "width": this.width, "height": this.height, "shape-rendering": "crispEdges", "fill": this.backgroundFill.hex, "fill-opacity": this.backgroundOpacity, "stroke": this.backgroundFill.hex, "stroke-opacity": 0 });
        patternElement.add(background);
        patternElement.attr({ "x": this.x, "y": this.y, "width": this.width, "height": this.height, "stroke": this.stroke.hex, "fill": this.fill.hex, "fill-opacity": this.fillOpacity, "stroke-opacity": this.strokeOpacity, "stroke-width": this.strokeWidth, "shape-rendering": this.shapeRendering, "patternUnits": this.patternUnits, "stroke-dasharray": this.strokeDasharray });
        each3(this._elements.iterator(), function(element) {
          element.rotation = _this.rotation;
          element.rotationX = _this.properties["rotationX"];
          element.rotationY = _this.properties["rotationY"];
          _this.element.add(element);
        });
      }
    };
    Pattern2.prototype.animate = function(animationOptions, duration, easing) {
      return new Animation(this, animationOptions, duration, easing).start();
    };
    Pattern2.prototype.addElement = function(element) {
      this._elements.push(element);
      this._disposers.push(element);
    };
    Pattern2.prototype.removeElement = function(element) {
      this._elements.removeValue(element);
      this.removeDispose(element);
    };
    Object.defineProperty(Pattern2.prototype, "elements", {
      /**
       * Returns the list of SVG elements comprising the pattern.
       *
       * @return Pattern elements
       */
      get: function() {
        return this._elements;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "fillOpacity", {
      /**
       * @return Opacity (0-1)
       */
      get: function() {
        return this.properties["fillOpacity"];
      },
      /**
       * Pattern fill opacity. (0-1)
       *
       * @param value  Opacity (0-1)
       */
      set: function(value) {
        this.properties["fillOpacity"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "fill", {
      /**
       * @return Fill color
       */
      get: function() {
        return this.properties["fill"];
      },
      /**
       * Fill color of the pattern.
       *
       * @param value  Fill color
       */
      set: function(value) {
        this.properties["fill"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "backgroundFill", {
      /**
       * @return Background color
       */
      get: function() {
        return this.properties["backgroundFill"];
      },
      /**
       * Pattern background fill color.
       *
       * @param value  Background color
       */
      set: function(value) {
        this.properties["backgroundFill"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "backgroundOpacity", {
      /**
       * @return Background opacity (0-1)
       */
      get: function() {
        return this.properties["backgroundOpacity"];
      },
      /**
       * Pattern backgorund opacity. (0-1)
       *
       * @param value  Background opacity (0-1)
       */
      set: function(value) {
        this.properties["backgroundOpacity"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "stroke", {
      /**
       * @return Color
       */
      get: function() {
        return this.properties["stroke"];
      },
      /**
       * Pattern stroke (border) color.
       *
       * @param value  Color
       */
      set: function(value) {
        this.properties["stroke"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "strokeOpacity", {
      /**
       * @return Opacity (0-1)
       */
      get: function() {
        return this.properties["strokeOpacity"];
      },
      /**
       * Pattern stroke opacity. (0-1)
       *
       * @param value  Opacity (0-1)
       */
      set: function(value) {
        this.properties["strokeOpacity"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "strokeWidth", {
      /**
       * @return Stroke thickness (px)
       */
      get: function() {
        return this.properties["strokeWidth"];
      },
      /**
       * Pattern stroke thickness in pixels.
       *
       * @param value  Stroke thickness (px)
       */
      set: function(value) {
        this.properties["strokeWidth"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "shapeRendering", {
      get: function() {
        return this.properties["shapeRendering"];
      },
      /**
       * Shape rendering
       * @param value [description]
       */
      set: function(value) {
        this.properties["shapeRendering"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "rotation", {
      /**
       * @return Rotation
       */
      get: function() {
        return this.properties["rotation"];
      },
      /**
       * Pattern rotation in degrees.
       *
       * @param value  Rotation
       */
      set: function(value) {
        this.properties["rotation"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "patternUnits", {
      /**
       * @return Units
       */
      get: function() {
        return this.properties["patternUnits"];
      },
      /**
       * Pattern measuring units.
       *
       * Available options: "userSpaceOnUse" | "objectBoundingBox".
       *
       * @param value  Units
       */
      set: function(value) {
        this.properties["patternUnits"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "width", {
      /**
       * @return Width (px)
       */
      get: function() {
        return this.properties["width"];
      },
      /**
       * Pattern width in pixels.
       *
       * @param value  Width (px)
       */
      set: function(value) {
        this.properties["width"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "height", {
      /**
       * @return Height (px)
       */
      get: function() {
        return this.properties["height"];
      },
      /**
       * Pattern height in pixels.
       *
       * @param value Height (px)
       */
      set: function(value) {
        this.properties["height"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "x", {
      /**
       * @return X (px)
       */
      get: function() {
        return this.properties["x"];
      },
      /**
       * X position. (pixels)
       *
       * @param value X (px)
       */
      set: function(value) {
        this.properties["x"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "y", {
      /**
       * @return Y (px)
       */
      get: function() {
        return this.properties["y"];
      },
      /**
       * Y position (px).
       *
       * @param value Y (px)
       */
      set: function(value) {
        this.properties["y"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "paper", {
      /**
       * @ignore Exclude from docs
       * @return Paper
       */
      get: function() {
        if (this._paper) {
          return this._paper;
        }
        return getGhostPaper();
      },
      /**
       * [[Paper]] instance to draw pattern in.
       *
       * @ignore Exclude from docs
       * @param paper  Paper
       */
      set: function(paper) {
        if (this._paper != paper) {
          this._paper = paper;
          this.draw();
          paper.appendDef(this.element);
        }
      },
      enumerable: true,
      configurable: true
    });
    Pattern2.prototype.copyFrom = function(source) {
      var _this = this;
      _super.prototype.copyFrom.call(this, source);
      each2(source.properties, function(key, value) {
        _this[key] = value;
      });
    };
    Object.defineProperty(Pattern2.prototype, "animations", {
      /**
       * A list of animations currently running on the patter.
       *
       * @ignore Exclude from docs
       * @return Animation list
       */
      get: function() {
        if (!this._animations) {
          this._animations = [];
          this._disposers.push(new AnimationDisposer(this._animations));
        }
        return this._animations;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Pattern2.prototype, "strokeDasharray", {
      /**
       * @return `stroke-dasharray`
       */
      get: function() {
        return this.properties["strokeDashArray"];
      },
      /**
       * A `stroke-dasharray` for the stroke (outline).
       *
       * "Dasharray" allows setting rules to make lines dashed, dotted, etc.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more info on `stroke-dasharray`
       * @param value  `stroke-dasharray`
       */
      set: function(value) {
        this.properties["strokeDashArray"] = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Pattern2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.elements) && isArray(config.elements)) {
          for (var i = 0, len = config.elements.length; i < len; i++) {
            var element = config.elements[i];
            if (hasValue(element["type"])) {
              var sprite = this.createEntryInstance(element);
              if (sprite instanceof BaseObject) {
                sprite.config = element;
              }
              this.addElement(hasValue(element["typeProperty"]) ? sprite[element["typeProperty"]] : sprite.element);
            }
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    return Pattern2;
  }(BaseObject)
);
registry.registeredClasses["Pattern"] = Pattern;

// node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/LinearGradient.js
var LinearGradient = (
  /** @class */
  function(_super) {
    __extends(LinearGradient2, _super);
    function LinearGradient2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._stops = new List();
      _this._rotation = 0;
      _this.className = "LinearGradient";
      _this._stops.events.on("setIndex", _this.validate, _this);
      _this._stops.events.on("inserted", _this.validate, _this);
      _this.element = _this.paper.addGroup("linearGradient");
      _this.id = "gradient-" + registry.getUniqueId();
      _this.element.attr({ "id": _this.id });
      _this._disposers.push(_this.element);
      _this.applyTheme();
      return _this;
    }
    LinearGradient2.prototype.validate = function() {
      var _this = this;
      var rotation = (this._rotation + 90) * RADIANS;
      var x1 = Math.round(50 + Math.sin(rotation + Math.PI) * 50) + "%";
      var y1 = Math.round(50 + Math.cos(rotation) * 50) + "%";
      var x2 = Math.round(50 + Math.sin(rotation) * 50) + "%";
      var y2 = Math.round(50 + Math.cos(rotation + Math.PI) * 50) + "%";
      var gradientElement = this.element;
      gradientElement.removeChildNodes();
      gradientElement.attr({ "x1": x1, "x2": x2, "y1": y1, "y2": y2 });
      each3(indexed(this._stops.iterator()), function(a) {
        var i = a[0];
        var stop = a[1];
        var offset = stop.offset;
        if (!isNumber(offset)) {
          offset = i / (_this._stops.length - 1);
        }
        var gradientStop = _this.paper.add("stop");
        if (hasValue(stop.color)) {
          gradientStop.attr({ "stop-color": stop.color.toString() });
        }
        if (isNumber(stop.opacity)) {
          gradientStop.attr({ "stop-opacity": stop.opacity });
        }
        if (isNumber(offset)) {
          gradientStop.attr({ "offset": offset });
        }
        gradientElement.add(gradientStop);
      });
    };
    LinearGradient2.prototype.clear = function() {
      this._stops.clear();
    };
    LinearGradient2.prototype.addColor = function(color2, opacity, offset) {
      this._stops.push({ color: color2, opacity, offset });
    };
    Object.defineProperty(LinearGradient2.prototype, "stops", {
      /**
       * A list of color stops in the gradient.
       *
       * @return Stops
       */
      get: function() {
        return this._stops;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LinearGradient2.prototype, "paper", {
      /**
       * @ignore Exclude from docs
       * @return Paper
       */
      get: function() {
        if (this._paper) {
          return this._paper;
        }
        return getGhostPaper();
      },
      /**
       * [[Paper]] instace to use for the gradient.
       *
       * @ignore Exclude from docs
       * @param paper  Paper
       */
      set: function(paper) {
        if (this._paper != paper) {
          this._paper = paper;
          this.validate();
          paper.appendDef(this.element);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LinearGradient2.prototype, "rotation", {
      /**
       * @return Rotation
       */
      get: function() {
        return this._rotation;
      },
      /**
       * Rotation (direction) of the gradient in degrees.
       *
       * @param value  Rotation
       */
      set: function(value) {
        this._rotation = value;
        this.validate();
      },
      enumerable: true,
      configurable: true
    });
    LinearGradient2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.stops.copyFrom(source.stops);
      this._rotation = source.rotation;
    };
    Object.defineProperty(LinearGradient2.prototype, "gradientUnits", {
      /**
       * Which units are used when drawing gradient filter.
       *
       * Use `"userSpaceOnUse"` when applying gradient on a perfectly straight line.
       *
       * @since 4.9.17
       * @default objectBoundingBox
       * @param value Filter units
       */
      set: function(value) {
        this.element.attr({ gradientUnits: value });
      },
      enumerable: true,
      configurable: true
    });
    return LinearGradient2;
  }(BaseObject)
);
registry.registeredClasses["LinearGradient"] = LinearGradient;

// node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/RadialGradient.js
var RadialGradient = (
  /** @class */
  function(_super) {
    __extends(RadialGradient2, _super);
    function RadialGradient2() {
      var _this = _super.call(this) || this;
      _this._stops = new List();
      _this.element = _this.paper.addGroup("radialGradient");
      _this.id = "gradient-" + registry.getUniqueId();
      _this.element.attr({ "id": _this.id });
      _this._disposers.push(_this.element);
      _this.applyTheme();
      return _this;
    }
    RadialGradient2.prototype.draw = function() {
      var _this = this;
      var gradientElement = this.element;
      if (isNumber(this.cx)) {
        var value = this.cx;
        if (value instanceof Percent) {
          value = value.percent + "%";
        }
        gradientElement.attr({ "cx": value });
      }
      if (isNumber(this.cy)) {
        var value = this.cy;
        if (value instanceof Percent) {
          value = value.percent + "%";
        }
        gradientElement.attr({ "cy": value });
      }
      if (this.fx) {
        var value = this.fx;
        if (value instanceof Percent) {
          value = value.percent + "%";
        }
        gradientElement.attr({ "fx": value });
      }
      if (this.fy) {
        var value = this.fy;
        if (value instanceof Percent) {
          value = value.percent + "%";
        }
        gradientElement.attr({ "fy": value });
      }
      gradientElement.removeChildNodes();
      each3(indexed(this._stops.iterator()), function(a) {
        var i = a[0];
        var stop = a[1];
        var offset = stop.offset;
        if (!isNumber(offset)) {
          offset = i / (_this._stops.length - 1);
        }
        var gradientStop = _this.paper.add("stop");
        if (hasValue(stop.color)) {
          gradientStop.attr({ "stop-color": stop.color.toString() });
        }
        if (isNumber(stop.opacity)) {
          gradientStop.attr({ "stop-opacity": stop.opacity });
        }
        if (isNumber(offset)) {
          gradientStop.attr({ "offset": offset });
        }
        gradientElement.add(gradientStop);
      });
    };
    RadialGradient2.prototype.addColor = function(color2, opacity, offset) {
      this._stops.push({ color: color2, opacity, offset });
      this.draw();
    };
    Object.defineProperty(RadialGradient2.prototype, "paper", {
      /**
       * @ignore Exclude from docs
       * @return Paper
       */
      get: function() {
        if (this._paper) {
          return this._paper;
        }
        return getGhostPaper();
      },
      /**
       * A [[Paper]] instace to use for the gradient.
       *
       * @ignore Exclude from docs
       * @param paper  Paper
       */
      set: function(paper) {
        if (this._paper != paper) {
          this._paper = paper;
          this.draw();
          paper.appendDef(this.element);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadialGradient2.prototype, "cx", {
      get: function() {
        return this._cx;
      },
      /**
       * Center x coordinate of the gradient, can be set as number or Percent
       *
       * @param point  Center point
       */
      set: function(value) {
        this._cx = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadialGradient2.prototype, "cy", {
      get: function() {
        return this._cy;
      },
      /**
       * Center y coordinate of the gradient, can be set as number or Percent
       *
       * @param point  Center point
       */
      set: function(value) {
        this._cy = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadialGradient2.prototype, "fx", {
      get: function() {
        return this._fx;
      },
      /**
       * y coordinate of the focal point of a gradient, can be set in pixels or as Percent
       *
       * @param point  Center point
       */
      set: function(value) {
        this._fx = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadialGradient2.prototype, "fy", {
      get: function() {
        return this._fy;
      },
      /**
       * y coordinate of the focal point of a gradient, can be set in pixels or as Percent
       *
       * @param point  Center point
       */
      set: function(value) {
        this._fy = value;
        this.draw();
      },
      enumerable: true,
      configurable: true
    });
    RadialGradient2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.stops.copyFrom(source.stops);
      this.cx = source.cx;
      this.cy = source.cy;
      this.fx = source.fx;
      this.fy = source.fy;
    };
    Object.defineProperty(RadialGradient2.prototype, "stops", {
      /**
       * A list of color stops in the gradient.
       *
       * @return Stops
       */
      get: function() {
        return this._stops;
      },
      enumerable: true,
      configurable: true
    });
    RadialGradient2.prototype.clear = function() {
      this._stops.clear();
    };
    return RadialGradient2;
  }(BaseObject)
);
registry.registeredClasses["RadialGradient"] = RadialGradient;

// node_modules/@amcharts/amcharts4/.internal/core/interaction/Mouse.js
var MouseCursorStyle = (
  /** @class */
  function() {
    function MouseCursorStyle2() {
    }
    MouseCursorStyle2.grab = [{
      "property": "cursor",
      "value": "move"
    }, {
      "property": "cursor",
      "value": "grab"
    }, {
      "property": "cursor",
      "value": "-webkit-grab"
    }];
    MouseCursorStyle2.grabbing = [{
      "property": "cursor",
      "value": "move"
    }, {
      "property": "cursor",
      "value": "grabbing"
    }, {
      "property": "cursor",
      "value": "-webkit-grabbing"
    }];
    MouseCursorStyle2.pointer = [{
      "property": "cursor",
      "value": "pointer"
    }];
    MouseCursorStyle2.default = [{
      "property": "cursor",
      "value": "default"
    }];
    MouseCursorStyle2.horizontalResize = [{
      "property": "cursor",
      "value": "ew-resize"
    }];
    MouseCursorStyle2.verticalResize = [{
      "property": "cursor",
      "value": "ns-resize"
    }];
    MouseCursorStyle2.notAllowed = [{
      "property": "cursor",
      "value": "not-allowed"
    }];
    MouseCursorStyle2.text = [{
      "property": "cursor",
      "value": "text"
    }];
    return MouseCursorStyle2;
  }()
);

// node_modules/@amcharts/amcharts4/lang/en.js
var en_default = {
  // Number formatting options.
  // 
  // Please check with the local standards which separator is accepted to be
  // used for separating decimals, and which for thousands.
  "_decimalSeparator": ".",
  "_thousandSeparator": ",",
  // Position of the percent sign in numbers
  "_percentPrefix": null,
  "_percentSuffix": "%",
  // Suffixes for numbers
  // When formatting numbers, big or small numers might be reformatted to
  // shorter version, by applying a suffix.
  // 
  // For example, 1000000 might become "1m".
  // Or 1024 might become "1KB" if we're formatting byte numbers.
  // 
  // This section defines such suffixes for all such cases.
  "_big_number_suffix_3": "k",
  "_big_number_suffix_6": "M",
  "_big_number_suffix_9": "G",
  "_big_number_suffix_12": "T",
  "_big_number_suffix_15": "P",
  "_big_number_suffix_18": "E",
  "_big_number_suffix_21": "Z",
  "_big_number_suffix_24": "Y",
  "_small_number_suffix_3": "m",
  "_small_number_suffix_6": "μ",
  "_small_number_suffix_9": "n",
  "_small_number_suffix_12": "p",
  "_small_number_suffix_15": "f",
  "_small_number_suffix_18": "a",
  "_small_number_suffix_21": "z",
  "_small_number_suffix_24": "y",
  "_byte_suffix_B": "B",
  "_byte_suffix_KB": "KB",
  "_byte_suffix_MB": "MB",
  "_byte_suffix_GB": "GB",
  "_byte_suffix_TB": "TB",
  "_byte_suffix_PB": "PB",
  // Default date formats for various periods.
  // 
  // This should reflect official or de facto formatting universally accepted
  // in the country translation is being made for
  // Available format codes here:
  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Format_codes
  // 
  // This will be used when formatting date/time for particular granularity,
  // e.g. "_date_hour" will be shown whenever we need to show time as hours.
  // 
  // "date" is used as in default date format when showing standalone dates.
  "_date": "yyyy-MM-dd",
  "_date_millisecond": "mm:ss SSS",
  "_date_second": "HH:mm:ss",
  "_date_minute": "HH:mm",
  "_date_hour": "HH:mm",
  "_date_day": "MMM dd",
  "_date_week": "ww",
  "_date_month": "MMM",
  "_date_year": "yyyy",
  // Default duration formats for various base units.
  // 
  // This will be used by DurationFormatter to format numeric values into
  // duration.
  // 
  // Notice how each duration unit comes in several versions. This is to ensure
  // that each base unit is shown correctly.
  // 
  // For example, if we have baseUnit set to "second", meaning our duration is
  // in seconds.
  // 
  // If we pass in `50` to formatter, it will know that we have just 50 seconds
  // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
  // and the formatted result will be in like `"50"`.
  // 
  // If we pass in `70`, which is more than a minute, the formatter will switch
  // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
  // text.
  // 
  // Available codes here:
  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
  "_duration_millisecond": "SSS",
  "_duration_millisecond_second": "ss.SSS",
  "_duration_millisecond_minute": "mm:ss SSS",
  "_duration_millisecond_hour": "hh:mm:ss SSS",
  "_duration_millisecond_day": "d'd' mm:ss SSS",
  "_duration_millisecond_week": "d'd' mm:ss SSS",
  "_duration_millisecond_month": "M'm' dd'd' mm:ss SSS",
  "_duration_millisecond_year": "y'y' MM'm' dd'd' mm:ss SSS",
  "_duration_second": "ss",
  "_duration_second_minute": "mm:ss",
  "_duration_second_hour": "hh:mm:ss",
  "_duration_second_day": "d'd' hh:mm:ss",
  "_duration_second_week": "d'd' hh:mm:ss",
  "_duration_second_month": "M'm' dd'd' hh:mm:ss",
  "_duration_second_year": "y'y' MM'm' dd'd' hh:mm:ss",
  "_duration_minute": "mm",
  "_duration_minute_hour": "hh:mm",
  "_duration_minute_day": "d'd' hh:mm",
  "_duration_minute_week": "d'd' hh:mm",
  "_duration_minute_month": "M'm' dd'd' hh:mm",
  "_duration_minute_year": "y'y' MM'm' dd'd' hh:mm",
  "_duration_hour": "hh'h'",
  "_duration_hour_day": "d'd' hh'h'",
  "_duration_hour_week": "d'd' hh'h'",
  "_duration_hour_month": "M'm' dd'd' hh'h'",
  "_duration_hour_year": "y'y' MM'm' dd'd' hh'h'",
  "_duration_day": "d'd'",
  "_duration_day_week": "d'd'",
  "_duration_day_month": "M'm' dd'd'",
  "_duration_day_year": "y'y' MM'm' dd'd'",
  "_duration_week": "w'w'",
  "_duration_week_month": "w'w'",
  "_duration_week_year": "w'w'",
  "_duration_month": "M'm'",
  "_duration_month_year": "y'y' MM'm'",
  "_duration_year": "y'y'",
  // Era translations
  "_era_ad": "AD",
  "_era_bc": "BC",
  // Day part, used in 12-hour formats, e.g. 5 P.M.
  // Please note that these come in 3 variants:
  // * one letter (e.g. "A")
  // * two letters (e.g. "AM")
  // * two letters with dots (e.g. "A.M.")
  // 
  // All three need to to be translated even if they are all the same. Some
  // users might use one, some the other.
  "A": "",
  "P": "",
  "AM": "",
  "PM": "",
  "A.M.": "",
  "P.M.": "",
  // Date-related stuff.
  // 
  // When translating months, if there's a difference, use the form which is
  // best for a full date, e.g. as you would use it in "2018 January 1".
  // 
  // Note that May is listed twice. This is because in English May is the same
  // in both long and short forms, while in other languages it may not be the
  // case. Translate "May" to full word, while "May(short)" to shortened
  // version.
  // 
  // Should month names and weekdays be capitalized or not?
  // 
  // Rule of thumb is this: if the names should always be capitalized,
  // regardless of name position within date ("January", "21st January 2018",
  // etc.) use capitalized names. Otherwise enter all lowercase.
  // 
  // The date formatter will automatically capitalize names if they are the
  // first (or only) word in resulting date.
  "January": "",
  "February": "",
  "March": "",
  "April": "",
  "May": "",
  "June": "",
  "July": "",
  "August": "",
  "September": "",
  "October": "",
  "November": "",
  "December": "",
  "Jan": "",
  "Feb": "",
  "Mar": "",
  "Apr": "",
  "May(short)": "May",
  "Jun": "",
  "Jul": "",
  "Aug": "",
  "Sep": "",
  "Oct": "",
  "Nov": "",
  "Dec": "",
  // Weekdays.
  "Sunday": "",
  "Monday": "",
  "Tuesday": "",
  "Wednesday": "",
  "Thursday": "",
  "Friday": "",
  "Saturday": "",
  "Sun": "",
  "Mon": "",
  "Tue": "",
  "Wed": "",
  "Thu": "",
  "Fri": "",
  "Sat": "",
  // Date ordinal function.
  // 
  // This is used when adding number ordinal when formatting days in dates.
  // 
  // E.g. "January 1st", "February 2nd".
  // 
  // The function accepts day number, and returns a string to be added to the
  // day, like in default English translation, if we pass in 2, we will receive
  // "nd" back.
  "_dateOrd": function(day) {
    var res = "th";
    if (day < 11 || day > 13) {
      switch (day % 10) {
        case 1:
          res = "st";
          break;
        case 2:
          res = "nd";
          break;
        case 3:
          res = "rd";
          break;
      }
    }
    return res;
  },
  // Various chart controls.
  // Shown as a tooltip on zoom out button.
  "Zoom Out": "",
  // Timeline buttons
  "Play": "",
  "Stop": "",
  // Chart's Legend screen reader title.
  "Legend": "",
  // Legend's item screen reader indicator.
  "Click, tap or press ENTER to toggle": "",
  // Shown when the chart is busy loading something.
  "Loading": "",
  // Shown as the first button in the breadcrumb navigation, e.g.:
  // Home > First level > ...
  "Home": "",
  // Chart types.
  // Those are used as default screen reader titles for the main chart element
  // unless developer has set some more descriptive title.
  "Chart": "",
  "Serial chart": "",
  "X/Y chart": "",
  "Pie chart": "",
  "Gauge chart": "",
  "Radar chart": "",
  "Sankey diagram": "",
  "Flow diagram": "",
  "Chord diagram": "",
  "TreeMap chart": "",
  "Force directed tree": "",
  "Sliced chart": "",
  // Series types.
  // Used to name series by type for screen readers if they do not have their
  // name set.
  "Series": "",
  "Candlestick Series": "",
  "OHLC Series": "",
  "Column Series": "",
  "Line Series": "",
  "Pie Slice Series": "",
  "Funnel Series": "",
  "Pyramid Series": "",
  "X/Y Series": "",
  // Map-related stuff.
  "Map": "",
  "Press ENTER to zoom in": "",
  "Press ENTER to zoom out": "",
  "Use arrow keys to zoom in and out": "",
  "Use plus and minus keys on your keyboard to zoom in and out": "",
  // Export-related stuff.
  // These prompts are used in Export menu labels.
  // 
  // "Export" is the top-level menu item.
  // 
  // "Image", "Data", "Print" as second-level indicating type of export
  // operation.
  // 
  // Leave actual format untranslated, unless you absolutely know that they
  // would convey more meaning in some other way.
  "Export": "",
  "Image": "",
  "Data": "",
  "Print": "",
  "Press ENTER or use arrow keys to navigate": "",
  "Click, tap or press ENTER to open": "",
  "Click, tap or press ENTER to print.": "",
  "Click, tap or press ENTER to export as %1.": "",
  'To save the image, right-click this link and choose "Save picture as..."': "",
  'To save the image, right-click thumbnail on the left and choose "Save picture as..."': "",
  "(Press ESC to close this message)": "",
  "Image Export Complete": "",
  "Export operation took longer than expected. Something might have gone wrong.": "",
  "Saved from": "",
  "PNG": "",
  "JPG": "",
  "GIF": "",
  "SVG": "",
  "PDF": "",
  "JSON": "",
  "CSV": "",
  "XLSX": "",
  // Scrollbar-related stuff.
  // 
  // Scrollbar is a control which can zoom and pan the axes on the chart.
  // 
  // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
  // upper and lower (for vertical one).
  // 
  // Prompts change in relation to whether Scrollbar is vertical or horizontal.
  // 
  // The final section is used to indicate the current range of selection.
  "Use TAB to select grip buttons or left and right arrows to change selection": "",
  "Use left and right arrows to move selection": "",
  "Use left and right arrows to move left selection": "",
  "Use left and right arrows to move right selection": "",
  "Use TAB select grip buttons or up and down arrows to change selection": "",
  "Use up and down arrows to move selection": "",
  "Use up and down arrows to move lower selection": "",
  "Use up and down arrows to move upper selection": "",
  "From %1 to %2": "",
  "From %1": "",
  "To %1": "",
  // Data loader-related.
  "No parser available for file: %1": "",
  "Error parsing file: %1": "",
  "Unable to load file: %1": "",
  "Invalid date": "",
  // Common actions
  "Close": "",
  "Minimize": ""
};

// node_modules/@amcharts/amcharts4/.internal/core/utils/Language.js
var Language = (
  /** @class */
  function(_super) {
    __extends(Language2, _super);
    function Language2() {
      var _this = _super.call(this) || this;
      _this.adapter = new Adapter(_this);
      _this._locale = en_default;
      _this._defaultLocale = en_default;
      _this.className = "Language";
      if (hasValue(options.defaultLocale)) {
        _this.locale = options.defaultLocale;
      }
      _this.applyTheme();
      return _this;
    }
    Language2.prototype.getLocale = function(locale) {
      if (locale == null) {
        locale = this._locale;
      }
      return this.adapter.apply("locale", {
        locale
      }).locale;
    };
    Language2.prototype.translate = function(prompt, locale) {
      var rest = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        rest[_i - 2] = arguments[_i];
      }
      locale = this.getLocale(locale);
      var translation = prompt;
      var translations = this.getTranslations(locale);
      var value = translations[prompt];
      if (value === null) {
        translation = "";
      } else if (hasValue(value)) {
        if (value) {
          translation = value;
        }
      } else if (locale !== this._defaultLocale) {
        return this.translate.apply(this, __spread([prompt, this._defaultLocale], rest));
      }
      if (rest.length) {
        for (var len = rest.length, i = 0; i < len; ++i) {
          translation = translation.split("%" + (i + 1)).join(rest[i]);
        }
      }
      return this.adapter.apply("translate", {
        translation,
        locale
      }).translation;
    };
    Language2.prototype.translateAny = function(prompt, locale) {
      var rest = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        rest[_i - 2] = arguments[_i];
      }
      return this.translate.apply(this, __spread([prompt, locale], rest));
    };
    Language2.prototype.setTranslationAny = function(prompt, translation, locale) {
      var localeTarget = locale || this.locale;
      localeTarget[prompt] = translation;
    };
    Language2.prototype.translateEmpty = function(prompt, locale) {
      var rest = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        rest[_i - 2] = arguments[_i];
      }
      var translation = this.translate.apply(this, __spread([prompt, locale], rest));
      return translation == prompt ? "" : translation;
    };
    Language2.prototype.translateFunc = function(prompt, locale) {
      locale = this.getLocale(locale);
      var translations = this.getTranslations(locale);
      var value = translations[prompt];
      if (value != null) {
        return value;
      }
      if (locale !== this._defaultLocale) {
        return this.translateFunc(prompt, this._defaultLocale);
      }
      return function() {
        return "";
      };
    };
    Language2.prototype.translateAll = function(list, locale) {
      var _this = this;
      if (!this.isDefault()) {
        return map(list, function(x) {
          return _this.translate(x, locale);
        });
      } else {
        return list;
      }
    };
    Language2.prototype.isDefault = function() {
      return this._defaultLocale === this._locale;
    };
    Object.defineProperty(Language2.prototype, "locale", {
      /**
       * @return Locale definition
       */
      get: function() {
        return this._locale;
      },
      /**
       * Current locale.
       *
       * @param value  Locale definition (translations)
       */
      set: function(value) {
        if (this._locale != value) {
          this._locale = value;
          if (this.events.isEnabled("localechanged")) {
            var event_1 = {
              type: "localechanged",
              locale: value,
              target: this
            };
            this.events.dispatchImmediately("localechanged", event_1);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Language2.prototype.getTranslations = function(locale) {
      return this.adapter.apply("translations", {
        translations: locale,
        locale
      }).translations;
    };
    return Language2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/formatters/TextFormatter.js
var TextFormatter = (
  /** @class */
  function(_super) {
    __extends(TextFormatter2, _super);
    function TextFormatter2() {
      var _this = _super.call(this) || this;
      _this.adapter = new Adapter(_this);
      _this.className = "TextFormatter";
      _this.applyTheme();
      return _this;
    }
    TextFormatter2.prototype.debug = function() {
    };
    TextFormatter2.prototype.format = function(text, output) {
      if (!hasValue(output)) {
        output = "svg";
      }
      var formatted = "";
      text = this.escape(text);
      var styles = text.match(/\[([^\]]*?)\]/gm);
      if (!styles) {
        return this.wrap(text, "", output);
      }
      var texts = text.split(/\[[^\[\]]*\]/);
      for (var i = 0, len = texts.length; i < len; i++) {
        var t = texts[i];
        if (t === "") {
          continue;
        }
        t = this.adapter.apply("chunk", t);
        var s2 = "";
        if (i > 0) {
          s2 = styles[i - 1].replace("[", "").replace("]", "");
        }
        formatted += this.wrap(t, s2, output);
      }
      formatted = this.unescape(formatted);
      return this.cleanUp(formatted);
    };
    TextFormatter2.prototype.escape = function(text) {
      return text.replace(/\[\[/g, registry.getPlaceholder("1")).replace(/([^\/\]]{1})\]\]/g, "$1" + registry.getPlaceholder("2")).replace(/\]\]/g, registry.getPlaceholder("2")).replace(/\{\{/g, registry.getPlaceholder("3")).replace(/\}\}/g, registry.getPlaceholder("4")).replace(/\'\'/g, registry.getPlaceholder("5"));
    };
    TextFormatter2.prototype.unescape = function(text) {
      return text.replace(new RegExp(registry.getPlaceholder("1"), "g"), "[[").replace(new RegExp(registry.getPlaceholder("2"), "g"), "]]").replace(new RegExp(registry.getPlaceholder("3"), "g"), "{{").replace(new RegExp(registry.getPlaceholder("4"), "g"), "}}").replace(new RegExp(registry.getPlaceholder("5"), "g"), "''");
    };
    TextFormatter2.prototype.cleanUp = function(text) {
      return text.replace(/\[\[/g, "[").replace(/\]\]/g, "]").replace(/\{\{/g, "{").replace(/\}\}/g, "}").replace(/\'\'/g, "'");
    };
    TextFormatter2.prototype.wrap = function(text, style, output) {
      if (style === "" || style === "/") {
        style = "";
      }
      switch (output) {
        case "html":
          return this.wrapHtml(text, this.translateStyleShortcuts(style));
        default:
          return this.wrapSvg(text, this.translateStyleShortcuts(style));
      }
    };
    TextFormatter2.prototype.wrapSvg = function(text, style) {
      if (style === "") {
        return "<tspan>" + text + "</tspan>";
      } else {
        return "<tspan style='" + style + "'>" + text + "</tspan>";
      }
    };
    TextFormatter2.prototype.getSvgElement = function(text, style) {
      var element = new AMElement("tspan");
      element.textContent = text;
      if (style) {
        element.node.setAttribute("style", style);
      }
      return element;
    };
    TextFormatter2.prototype.wrapHtml = function(text, style) {
      if (style === "") {
        return "<span>" + text + "</span>";
      } else {
        return "<span style='" + this.styleSvgToHtml(style) + "'>" + text + "</span>";
      }
    };
    TextFormatter2.prototype.getHtmlElement = function(text, style) {
      var element = document.createElement("span");
      element.innerHTML = text;
      if (style) {
        element.setAttribute("style", style);
      }
      return element;
    };
    TextFormatter2.prototype.styleSvgToHtml = function(style) {
      style = style.replace(/fill:/, "color:");
      return style;
    };
    TextFormatter2.prototype.translateStyleShortcuts = function(style) {
      if (style == "" || style == "[ ]") {
        return "";
      }
      var cached = registry.getCache("translateStyleShortcuts_" + style);
      if (cached) {
        return cached;
      }
      var q = style.match(/('[^']*')|("[^"]*")/gi);
      if (q) {
        for (var i = 0; i < q.length; i++) {
          style = style.replace(q[i], q[i].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
        }
      }
      var b = style.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w]+)|(\/)/gi);
      if (!b) {
        return style;
      }
      for (var i = 0; i < b.length; i++) {
        if (b[i].match(/^bold$/i)) {
          b[i] = "font-weight:" + b[i];
        } else if (b[i] == "/") {
          b[i] = "";
        } else if (!b[i].match(/:/)) {
          b[i] = "fill:" + b[i];
        } else {
          b[i] = b[i].replace(/\+/g, " ");
        }
      }
      var res = b.join(";");
      registry.setCache("translateStyleShortcuts_" + style, res);
      return res;
    };
    TextFormatter2.prototype.chunk = function(text, quotedBlocks, noFormatting) {
      if (quotedBlocks === void 0) {
        quotedBlocks = false;
      }
      if (noFormatting === void 0) {
        noFormatting = false;
      }
      var res = [];
      text = this.escape(text);
      var chunks = quotedBlocks ? text.split("'") : [text];
      for (var i = 0; i < chunks.length; i++) {
        var chunk = chunks[i];
        if (chunk === "") {
          continue;
        }
        if (i % 2 === 0) {
          chunk = chunk.replace(/\]\[/g, "]" + PLACEHOLDER + "[");
          chunk = chunk.replace(/\[\]/g, "[ ]");
          var chunks2 = chunk.split(/[\[\]]+/);
          for (var i2 = 0; i2 < chunks2.length; i2++) {
            var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
            if (chunk2 === PLACEHOLDER) {
              continue;
            }
            if (chunk2 === "") {
              continue;
            }
            if (i2 % 2 === 0) {
              res.push({
                "type": "value",
                "text": this.adapter.apply("chunk", chunk2)
              });
            } else {
              res.push({
                "type": noFormatting ? "value" : "format",
                "text": "[" + chunk2 + "]"
              });
            }
          }
        } else {
          var chunks2 = chunk.split(/[\[\]]+/);
          for (var i2 = 0; i2 < chunks2.length; i2++) {
            var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
            if (chunk2 === "") {
              continue;
            }
            if (i2 % 2 === 0) {
              res.push({
                "type": "text",
                "text": chunk2
              });
            } else if (this.isImage(chunk2)) {
              res.push({
                "type": "image",
                "text": "[" + chunk2 + "]"
              });
            } else {
              res.push({
                "type": "format",
                "text": "[" + chunk2 + "]"
              });
            }
          }
        }
      }
      return res;
    };
    TextFormatter2.prototype.isImage = function(text) {
      return text.match(/img[ ]?:/) ? true : false;
    };
    return TextFormatter2;
  }(BaseObject)
);
var formatter;
function getTextFormatter() {
  if (formatter == null) {
    formatter = new TextFormatter();
  }
  return formatter;
}
registry.registeredClasses["TextFormatter"] = TextFormatter;

// node_modules/@amcharts/amcharts4/.internal/core/formatters/NumberFormatter.js
var NumberFormatter = (
  /** @class */
  function(_super) {
    __extends(NumberFormatter2, _super);
    function NumberFormatter2() {
      var _this = _super.call(this) || this;
      _this._negativeBase = 0;
      _this._numberFormat = "#,###.#####";
      _this._outputFormat = "svg";
      _this._smallNumberThreshold = 1;
      _this._forceLTR = false;
      _this.className = "NumberFormatter";
      _this.applyTheme();
      return _this;
    }
    NumberFormatter2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      if (this.language) {
        this.language.dispose();
      }
    };
    Object.defineProperty(NumberFormatter2.prototype, "language", {
      /**
       * @return Language
       */
      get: function() {
        if (!this._language) {
          if (this.sprite) {
            this._language = this.sprite.language;
          } else {
            this._language = new Language();
          }
        }
        return this._language;
      },
      /**
       * A reference to [[Language]] instance.
       *
       * Formatter will use language to translate various items, like number
       * suffixes, etc.
       *
       * @param value  Language
       */
      set: function(value) {
        this._language = value;
      },
      enumerable: true,
      configurable: true
    });
    NumberFormatter2.prototype.format = function(value, format, precision) {
      if (typeof format === "undefined" || isString(format) && format.toLowerCase() === "number") {
        format = this._numberFormat;
      }
      var formatted;
      var source = Number(value);
      if (isObject(format)) {
        try {
          if (this.intlLocales) {
            return new Intl.NumberFormat(this.intlLocales, format).format(source);
          } else {
            return new Intl.NumberFormat(void 0, format).format(source);
          }
        } catch (e) {
          return "Invalid";
        }
      } else {
        format = cleanFormat(format);
        var info = this.parseFormat(format, this.language);
        var details = void 0;
        if (source > this._negativeBase) {
          details = info.positive;
        } else if (source < this._negativeBase) {
          details = info.negative;
        } else {
          details = info.zero;
        }
        if (hasValue(precision) && !details.mod) {
          details = clone(details);
          details.decimals.active = source == 0 ? 0 : precision;
        }
        formatted = details.template.split(PLACEHOLDER).join(this.applyFormat(source, details));
      }
      if (this.forceLTR) {
        formatted = "‎" + formatted;
      }
      return formatted;
    };
    NumberFormatter2.prototype.parseFormat = function(format, language) {
      var _this = this;
      var cached = this.getCache(format);
      if (hasValue(cached)) {
        return cached;
      }
      var info = {
        "positive": {
          "thousands": {
            "active": -1,
            "passive": -1,
            "interval": -1,
            "separator": language.translateEmpty("_thousandSeparator")
          },
          "decimals": {
            "active": -1,
            "passive": -1,
            "separator": language.translateEmpty("_decimalSeparator")
          },
          "template": "",
          "source": "",
          "parsed": false
        },
        "negative": {
          "thousands": {
            "active": -1,
            "passive": -1,
            "interval": -1,
            "separator": language.translateEmpty("_thousandSeparator")
          },
          "decimals": {
            "active": -1,
            "passive": -1,
            "separator": language.translateEmpty("_decimalSeparator")
          },
          "template": "",
          "source": "",
          "parsed": false
        },
        "zero": {
          "thousands": {
            "active": -1,
            "passive": -1,
            "interval": -1,
            "separator": language.translateEmpty("_thousandSeparator")
          },
          "decimals": {
            "active": -1,
            "passive": -1,
            "separator": language.translateEmpty("_decimalSeparator")
          },
          "template": "",
          "source": "",
          "parsed": false
        }
      };
      format = format.replace("||", PLACEHOLDER2);
      var parts = format.split("|");
      info.positive.source = parts[0];
      if (typeof parts[2] === "undefined") {
        info.zero = info.positive;
      } else {
        info.zero.source = parts[2];
      }
      if (typeof parts[1] === "undefined") {
        info.negative = info.positive;
      } else {
        info.negative.source = parts[1];
      }
      each2(info, function(part, item) {
        if (item.parsed) {
          return;
        }
        if (typeof _this.getCache(item.source) !== "undefined") {
          info[part] = _this.getCache(item.source);
          return;
        }
        var partFormat = item.source;
        if (partFormat.toLowerCase() === "number") {
          partFormat = isString(_this._numberFormat) ? _this._numberFormat : "#,###.#####";
        }
        var chunks = getTextFormatter().chunk(partFormat, true);
        for (var i = 0; i < chunks.length; i++) {
          var chunk = chunks[i];
          chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
          if (chunk.type === "value") {
            var matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
            if (matches) {
              if (matches === null || matches[0] === "") {
                item.template += chunk.text;
              } else {
                var mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
                if (mods) {
                  item.mod = mods[0].toLowerCase();
                  item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;
                }
                var a = matches[0].split(".");
                if (a[0] === "") {
                } else {
                  item.thousands.active = (a[0].match(/0/g) || []).length;
                  item.thousands.passive = (a[0].match(/\#/g) || []).length + item.thousands.active;
                  var b = a[0].split(",");
                  if (b.length === 1) {
                  } else {
                    item.thousands.interval = getValue(b.pop()).length;
                    if (item.thousands.interval === 0) {
                      item.thousands.interval = -1;
                    }
                  }
                }
                if (typeof a[1] === "undefined") {
                } else {
                  item.decimals.active = (a[1].match(/0/g) || []).length;
                  item.decimals.passive = (a[1].match(/\#/g) || []).length + item.decimals.active;
                }
                item.template += chunk.text.split(matches[0]).join(PLACEHOLDER);
              }
            }
          } else {
            item.template += chunk.text;
          }
        }
        _this.setCache(item.source, item);
        item.parsed = true;
      });
      this.setCache(format, info);
      return info;
    };
    NumberFormatter2.prototype.applyFormat = function(value, details) {
      var negative = value < 0;
      value = Math.abs(value);
      var prefix = "", suffix = "";
      var mods = details.mod ? details.mod.split("") : [];
      if (mods.indexOf("b") !== -1) {
        var a_1 = this.applyPrefix(value, this.bytePrefixes, mods.indexOf("!") !== -1);
        value = a_1[0];
        prefix = a_1[1];
        suffix = a_1[2];
        if (details.modSpacing) {
          suffix = " " + suffix;
        }
      } else if (mods.indexOf("a") !== -1) {
        var a_2 = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf("!") !== -1);
        value = a_2[0];
        prefix = a_2[1];
        suffix = a_2[2];
        if (details.modSpacing) {
          suffix = " " + suffix;
        }
      } else if (mods.indexOf("p") !== -1) {
        var ol = Math.min(value.toString().length + 2, 21);
        value = parseFloat(value.toPrecision(ol));
        prefix = this.language.translate("_percentPrefix") || "";
        suffix = this.language.translate("_percentSuffix") || "";
        if (prefix == "" && suffix == "") {
          suffix = "%";
        }
      } else if (mods.indexOf("%") !== -1) {
        var ol = min(value.toString().length + 2, 21);
        value *= 100;
        value = parseFloat(value.toPrecision(ol));
        suffix = "%";
      } else if (mods.indexOf("‰") !== -1) {
        var ol = min(value.toString().length + 3, 21);
        value *= 1e3;
        value = parseFloat(value.toPrecision(ol));
        suffix = "‰";
      }
      if (mods.indexOf("e") !== -1) {
        var exp = void 0;
        if (details.decimals.passive >= 0) {
          exp = value.toExponential(details.decimals.passive).split("e");
        } else {
          exp = value.toExponential().split("e");
        }
        value = Number(exp[0]);
        suffix = "e" + exp[1];
        if (details.modSpacing) {
          suffix = " " + suffix;
        }
      } else if (details.decimals.passive === 0) {
        value = Math.round(value);
      } else if (details.decimals.passive > 0) {
        var d = Math.pow(10, details.decimals.passive);
        value = Math.round(value * d) / d;
      }
      var res = "";
      var a = numberToString(value).split(".");
      var ints = a[0];
      if (ints.length < details.thousands.active) {
        ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;
      }
      if (details.thousands.interval > 0) {
        var ip = [];
        var intsr = ints.split("").reverse().join("");
        for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {
          var c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");
          if (c !== "") {
            ip.unshift(c);
          }
        }
        ints = ip.join(details.thousands.separator);
      }
      res += ints;
      if (a.length === 1) {
        a.push("");
      }
      var decs = a[1];
      if (decs.length < details.decimals.active) {
        decs += Array(details.decimals.active - decs.length + 1).join("0");
      }
      if (decs !== "") {
        res += details.decimals.separator + decs;
      }
      if (res === "") {
        res = "0";
      }
      if (value !== 0 && negative && mods.indexOf("s") === -1) {
        res = "-" + res;
      }
      if (prefix) {
        res = prefix + res;
      }
      if (suffix) {
        res += suffix;
      }
      return res;
    };
    NumberFormatter2.prototype.applyPrefix = function(value, prefixes, force) {
      if (force === void 0) {
        force = false;
      }
      var newvalue = value;
      var prefix = "";
      var suffix = "";
      var applied = false;
      var k = 1;
      for (var i = 0, len = prefixes.length; i < len; i++) {
        if (prefixes[i].number <= value) {
          if (prefixes[i].number === 0) {
            newvalue = 0;
          } else {
            newvalue = value / prefixes[i].number;
            k = prefixes[i].number;
          }
          prefix = prefixes[i].prefix;
          suffix = prefixes[i].suffix;
          applied = true;
        }
      }
      if (!applied && force && prefixes.length && value != 0) {
        newvalue = value / prefixes[0].number;
        prefix = prefixes[0].prefix;
        suffix = prefixes[0].suffix;
        applied = true;
      }
      if (applied) {
        newvalue = parseFloat(newvalue.toPrecision(min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));
      }
      return [newvalue, prefix, suffix];
    };
    NumberFormatter2.prototype.invalidateSprite = function() {
      if (this.sprite) {
        this.sprite.invalidate();
      }
    };
    Object.defineProperty(NumberFormatter2.prototype, "numberFormat", {
      /**
       * @return A format to use for number formatting
       */
      get: function() {
        return this._numberFormat;
      },
      /**
       * Number format.
       *
       * @default "#,###.#####"
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
       * @param format  A format to use for number formatting
       */
      set: function(format) {
        this._numberFormat = format;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "intlLocales", {
      /**
       * @return Date format
       */
      get: function() {
        return this._intlLocales;
      },
      /**
       * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.
       *
       * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting
       * @param value Locales
       */
      set: function(value) {
        this._intlLocales = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "negativeBase", {
      /**
       * @return A format to use for number formatting
       */
      get: function() {
        return this._negativeBase;
      },
      /**
       * Negative base for negative numbers.
       *
       * @default 0
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
       * @param format  A format to use for number formatting
       */
      set: function(value) {
        this._negativeBase = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "bigNumberPrefixes", {
      /**
       * @return Prefixes for big numbers
       */
      get: function() {
        if (!hasValue(this._bigNumberPrefixes)) {
          this._bigNumberPrefixes = [
            { "number": 1e3, "suffix": this.language.translate("_big_number_suffix_3") },
            { "number": 1e6, "suffix": this.language.translate("_big_number_suffix_6") },
            { "number": 1e9, "suffix": this.language.translate("_big_number_suffix_9") },
            { "number": 1e12, "suffix": this.language.translate("_big_number_suffix_12") },
            { "number": 1e15, "suffix": this.language.translate("_big_number_suffix_15") },
            { "number": 1e18, "suffix": this.language.translate("_big_number_suffix_18") },
            { "number": 1e21, "suffix": this.language.translate("_big_number_suffix_21") },
            { "number": 1e24, "suffix": this.language.translate("_big_number_suffix_24") }
          ];
        }
        return this._bigNumberPrefixes;
      },
      /**
       * Prefixes for big numbers.
       *
       * It's an array of objects of number/prefix pairs.
       *
       * ```JSON
       * [
       *   { "number": 1e+3, "suffix": "K" },
       *   { "number": 1e+6, "suffix": "M" },
       *   { "number": 1e+9, "suffix": "G" },
       *   { "number": 1e+12, "suffix": "T" },
       *   { "number": 1e+15, "suffix": "P" },
       *   { "number": 1e+18, "suffix": "E" },
       *   { "number": 1e+21, "suffix": "Z" },
       *   { "number": 1e+24, "suffix": "Y" }
       * ]
       * ```
       *
       * If the number is bigger than the `number` ir will be converted to the
       * appropriate bigger number with prefix.
       *
       * E.g. as per above `1500` will be converted to `1.5K`.
       *
       * Please note that for this transformation to be enabled, you need to
       * enable it specific modifier in your format setting.
       *
       * The modifier for big/small number modification is "a":
       *
       * ```Text
       * {myfield.formatNumber("#,###.00a")}
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
       * @param prefixes  Prefixes for big numbers
       */
      set: function(prefixes) {
        this._bigNumberPrefixes = prefixes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "smallNumberPrefixes", {
      /**
       * @return Prefixes for small numbers
       */
      get: function() {
        if (!hasValue(this._smallNumberPrefixes)) {
          this._smallNumberPrefixes = [
            { "number": 1e-24, "suffix": this.language.translate("_small_number_suffix_24") },
            { "number": 1e-21, "suffix": this.language.translate("_small_number_suffix_21") },
            { "number": 1e-18, "suffix": this.language.translate("_small_number_suffix_18") },
            { "number": 1e-15, "suffix": this.language.translate("_small_number_suffix_15") },
            { "number": 1e-12, "suffix": this.language.translate("_small_number_suffix_12") },
            { "number": 1e-9, "suffix": this.language.translate("_small_number_suffix_9") },
            { "number": 1e-6, "suffix": this.language.translate("_small_number_suffix_6") },
            { "number": 1e-3, "suffix": this.language.translate("_small_number_suffix_3") }
          ];
        }
        return this._smallNumberPrefixes;
      },
      /**
       * Prefixes for big numbers.
       *
       * It's an array of objects of number/prefix pairs.
       *
       * ```JSON
       * [
       *   { "number": 1e-24, "suffix": "y" },
       *   { "number": 1e-21, "suffix": "z" },
       *   { "number": 1e-18, "suffix": "a" },
       *   { "number": 1e-15, "suffix": "f" },
       *   { "number": 1e-12, "suffix": "p" },
       *   { "number": 1e-9, "suffix": "n" },
       *   { "number": 1e-6, "suffix": "μ" },
       *   { "number": 1e-3, "suffix": "m" }
       * ]
       * ```
       *
       * If the number is smaller than the `number` ir will be converted to the
       * appropriate smaller number with prefix.
       *
       * E.g. as per above `0.0015` will be converted to `1.5m`.
       *
       * Please note that for this transformation to be enabled, you need to
       * enable it specific modifier in your format setting.
       *
       * The modifier for big/small number modification is "a":
       *
       * ```Text
       * {myfield.formatNumber("#,###.00a")}
       * ```
       *
       * IMPORTANT: The order of the suffixes is important. The list must start
       * from the smallest number and work towards bigger ones.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
       * @param prefixes  Prefixes for small numbers
       */
      set: function(prefixes) {
        this._smallNumberPrefixes = prefixes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "smallNumberThreshold", {
      /**
       * @return Small number threshold
       */
      get: function() {
        return this._smallNumberThreshold;
      },
      /**
       * Any number smaller than this will be considered "small" number, which will
       * trigger special formatting if "a" format modifier is used.
       *
       * @since 4.6.8
       * @param  value  Small number threshold
       */
      set: function(value) {
        this._smallNumberThreshold = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "bytePrefixes", {
      /**
       * @return Prefixes for byte-size formatting
       */
      get: function() {
        if (!hasValue(this._bytePrefixes)) {
          this._bytePrefixes = [
            { "number": 1, suffix: this.language.translate("_byte_suffix_B") },
            { "number": 1024, suffix: this.language.translate("_byte_suffix_KB") },
            { "number": 1048576, suffix: this.language.translate("_byte_suffix_MB") },
            { "number": 1073741824, suffix: this.language.translate("_byte_suffix_GB") },
            { "number": 1099511627776, suffix: this.language.translate("_byte_suffix_TB") },
            { "number": 1125899906842624, suffix: this.language.translate("_byte_suffix_PB") }
          ];
        }
        return this._bytePrefixes;
      },
      /**
       * Basically the same as `bigNumberPrefixes`, except base for calculation
       * is not thousand but byte (1024).
       *
       * The modifier is "b".
       *
       *  ```Text
       * {myfield.formatNumber("#,###.00b")}
       * ```
       *
       * The above `2048` will change to `2K`.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
       * @param prefixes  Prefixes for byte-size formatting
       */
      set: function(prefixes) {
        this._bytePrefixes = prefixes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "outputFormat", {
      /**
       * @ignore Exclude from docs
       * @return Output format
       */
      get: function() {
        return this._outputFormat;
      },
      /**
       * Ooutput format: "svg" or "html".
       *
       * @ignore Exclude from docs
       * @param value  Output format
       */
      set: function(outputFormat) {
        this._outputFormat = outputFormat.toLowerCase();
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NumberFormatter2.prototype, "forceLTR", {
      get: function() {
        return this._forceLTR;
      },
      set: function(value) {
        this._forceLTR = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    NumberFormatter2.prototype.escape = function(text) {
      return text.replace("||", PLACEHOLDER2);
    };
    NumberFormatter2.prototype.unescape = function(text) {
      return text.replace(PLACEHOLDER2, "|");
    };
    return NumberFormatter2;
  }(BaseObject)
);
registry.registeredClasses["NumberFormatter"] = NumberFormatter;

// node_modules/@amcharts/amcharts4/.internal/core/formatters/DateFormatter.js
var DateFormatter = (
  /** @class */
  function(_super) {
    __extends(DateFormatter2, _super);
    function DateFormatter2() {
      var _this = _super.call(this) || this;
      _this._dateFormat = "yyyy-MM-dd";
      _this._inputDateFormat = "yyyy-MM-dd";
      _this._utc = false;
      _this.timezoneMinutes = 0;
      _this._firstDayOfWeek = 1;
      _this.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      _this.monthsShort = ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      _this.weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      _this.weekdaysShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      _this._outputFormat = "svg";
      _this.capitalize = true;
      _this.className = "DateFormatter";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(DateFormatter2.prototype, "language", {
      /**
       * @return Language
       */
      get: function() {
        return this._language;
      },
      /**
       * A reference to [[Language]] object.
       *
       * @param  value  Language
       */
      set: function(value) {
        this._language = value;
        this.dateFormat = this._language.translate("_date");
      },
      enumerable: true,
      configurable: true
    });
    DateFormatter2.prototype.format = function(source, format, applyTimezone) {
      if (!this.language) {
        if (this.sprite) {
          this.language = this.sprite.language;
        } else {
          this.language = new Language();
        }
      }
      if (typeof format === "undefined" || format === "") {
        format = this._dateFormat;
      }
      var formatted;
      var date;
      if (isString(source)) {
        date = this.parse(source);
      } else {
        date = anyToDate(source);
      }
      if (isObject(format)) {
        try {
          if (this.intlLocales) {
            return new Intl.DateTimeFormat(this.intlLocales, format).format(date);
          } else {
            return new Intl.DateTimeFormat(void 0, format).format(date);
          }
        } catch (e) {
          return "Invalid";
        }
      } else {
        format = cleanFormat(format);
        var info = this.parseFormat(format);
        if (hasValue(this.timezoneOffset)) {
          date.setMinutes(date.getMinutes() + date.getTimezoneOffset() - this.timezoneOffset);
        } else if (hasValue(this.timezone) && applyTimezone !== false) {
          date = setTimezone(date, this.timezone);
        }
        if (!isNumber(date.getTime())) {
          return this.language.translate("Invalid date");
        }
        formatted = this.applyFormat(date, info, this.language);
        if (this.capitalize) {
          formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());
        }
      }
      return formatted;
    };
    DateFormatter2.prototype.parseFormat = function(format) {
      var cached = this.getCache(format);
      if (hasValue(cached)) {
        return cached;
      }
      var info = {
        "template": "",
        "parts": []
      };
      var chunks = getTextFormatter().chunk(format, true);
      for (var i = 0; i < chunks.length; i++) {
        var chunk = chunks[i];
        if (chunk.type === "value") {
          if (chunk.text.match(/^date$/i) && isString(this._dateFormat)) {
            chunk.text = this._dateFormat;
          }
          var matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
          if (matches) {
            for (var x = 0; x < matches.length; x++) {
              info.parts.push(matches[x]);
              chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
            }
          }
        }
        info.template += chunk.text;
      }
      this.setCache(format, info);
      return info;
    };
    DateFormatter2.prototype.applyFormat = function(date, info, language) {
      var res = info.template;
      var fullYear, month, weekday, day, hours, minutes, seconds, milliseconds, offset = date.getTimezoneOffset(), timestamp = date.getTime();
      if (this.utc) {
        fullYear = date.getUTCFullYear();
        month = date.getUTCMonth();
        weekday = date.getUTCDay();
        day = date.getUTCDate();
        hours = date.getUTCHours();
        minutes = date.getUTCMinutes();
        seconds = date.getUTCSeconds();
        milliseconds = date.getUTCMilliseconds();
      } else {
        fullYear = date.getFullYear();
        month = date.getMonth();
        weekday = date.getDay();
        day = date.getDate();
        hours = date.getHours();
        minutes = date.getMinutes();
        seconds = date.getSeconds();
        milliseconds = date.getMilliseconds();
      }
      for (var i = 0, len = info.parts.length; i < len; i++) {
        var value = "";
        switch (info.parts[i]) {
          case "G":
            value = language.translate(fullYear < 0 ? "_era_bc" : "_era_ad");
            break;
          case "yyyy":
            value = Math.abs(fullYear).toString();
            if (fullYear < 0) {
              value += language.translate("_era_bc");
            }
            break;
          case "yyy":
          case "yy":
          case "y":
            value = Math.abs(fullYear).toString().substr(-info.parts[i].length);
            if (fullYear < 0) {
              value += language.translate("_era_bc");
            }
            break;
          case "YYYY":
          case "YYY":
          case "YY":
          case "Y":
            var week = getWeek(date);
            var year = fullYear;
            if (week == 1 && weekday > 4) {
              year--;
            }
            if (info.parts[i] == "YYYY") {
              value = Math.abs(year).toString();
            } else {
              value = Math.abs(year).toString().substr(-info.parts[i].length);
            }
            if (year < 0) {
              value += language.translate("_era_bc");
            }
            break;
          case "u":
            break;
          case "q":
            value = "" + Math.ceil((date.getMonth() + 1) / 3);
            break;
          case "MMMMM":
            value = language.translate(this.months[month]).substr(0, 1);
            break;
          case "MMMM":
            value = language.translate(this.months[month]);
            break;
          case "MMM":
            value = language.translate(this.monthsShort[month]);
            break;
          case "MM":
            value = padString(month + 1, 2, "0");
            break;
          case "M":
            value = (month + 1).toString();
            break;
          case "ww":
            value = padString(getWeek(date, this.utc), 2, "0");
            break;
          case "w":
            value = getWeek(date, this.utc).toString();
            break;
          case "W":
            value = getMonthWeek(date, this.utc).toString();
            break;
          case "dd":
            value = padString(day, 2, "0");
            break;
          case "d":
            value = day.toString();
            break;
          case "DD":
          case "DDD":
            value = padString(getYearDay(date, this.utc).toString(), info.parts[i].length, "0");
            break;
          case "D":
            value = getYearDay(date, this.utc).toString();
            break;
          case "F":
            break;
          case "g":
            break;
          case "t":
            value = language.translateFunc("_dateOrd").call(this, day);
            break;
          case "E":
            value = (weekday || 7).toString();
            break;
          case "EE":
            value = padString((weekday || 7).toString(), 2, "0");
            break;
          case "EEE":
          case "eee":
            value = language.translate(this.weekdaysShort[weekday]);
            break;
          case "EEEE":
          case "eeee":
            value = language.translate(this.weekdays[weekday]);
            break;
          case "EEEEE":
          case "eeeee":
            value = language.translate(this.weekdays[weekday]).substr(0, 1);
            break;
          case "e":
          case "ee":
            value = (weekday - this.firstDayOfWeek + 1).toString();
            if (info.parts[i] == "ee") {
              value = padString(value, 2, "0");
            }
            break;
          case "a":
            if (hours >= 12) {
              value = language.translate("PM");
            } else {
              value = language.translate("AM");
            }
            break;
          case "aa":
            if (hours >= 12) {
              value = language.translate("P.M.");
            } else {
              value = language.translate("A.M.");
            }
            break;
          case "aaa":
            if (hours >= 12) {
              value = language.translate("P");
            } else {
              value = language.translate("A");
            }
            break;
          case "h":
            value = get12Hours(hours).toString();
            break;
          case "hh":
            value = padString(get12Hours(hours), 2, "0");
            break;
          case "H":
            value = hours.toString();
            break;
          case "HH":
            value = padString(hours, 2, "0");
            break;
          case "K":
            value = get12Hours(hours, 0).toString();
            break;
          case "KK":
            value = padString(get12Hours(hours, 0), 2, "0");
            break;
          case "k":
            value = (hours + 1).toString();
            break;
          case "kk":
            value = padString(hours + 1, 2, "0");
            break;
          case "m":
            value = minutes.toString();
            break;
          case "mm":
            value = padString(minutes, 2, "0");
            break;
          case "s":
            value = seconds.toString();
            break;
          case "ss":
            value = padString(seconds, 2, "0");
            break;
          case "S":
          case "SS":
          case "SSS":
            value = Math.round(milliseconds / 1e3 * Math.pow(10, info.parts[i].length)).toString();
            break;
          case "x":
            value = timestamp.toString();
            break;
          case "n":
          case "nn":
          case "nnn":
            value = padString(milliseconds, info.parts[i].length, "0");
            break;
          case "z":
            value = getTimeZone(date, false, false, this.utc);
            break;
          case "zz":
            value = getTimeZone(date, true, false, this.utc);
            break;
          case "zzz":
            value = getTimeZone(date, false, true, this.utc);
            break;
          case "zzzz":
            value = getTimeZone(date, true, true, this.utc);
            break;
          case "Z":
          case "ZZ":
            var tz = Math.abs(offset) / 60;
            var tzh = Math.floor(tz);
            var tzm = tz * 60 - tzh * 60;
            if (this.utc) {
              tzh = 0;
              tzm = 0;
            }
            if (info.parts[i] == "Z") {
              value = "GMT";
              value += offset > 0 ? "-" : "+";
              value += padString(tzh, 2) + ":" + padString(tzm, 2);
            } else {
              value = offset > 0 ? "-" : "+";
              value += padString(tzh, 2) + padString(tzm, 2);
            }
            break;
          case "i":
            value = date.toISOString();
            break;
          case "I":
            value = date.toUTCString();
            break;
        }
        res = res.replace(PLACEHOLDER, value);
      }
      return res;
    };
    DateFormatter2.prototype.parse = function(source, format) {
      if (!hasValue(format)) {
        format = this.inputDateFormat;
      }
      if (source instanceof Date) {
        return source;
      }
      if (typeof source === "number") {
        return new Date(source);
      }
      if (typeof source !== "string") {
        source = source.toString();
      }
      if (!this.language) {
        if (this.sprite) {
          this.language = this.sprite.language;
        } else {
          this.language = new Language();
        }
      }
      var res;
      var reg = "";
      format = cleanFormat(format);
      format = format.substr(0, source.length);
      var info = this.parseFormat(format);
      var parsedIndexes = {
        "year": -1,
        "year3": -1,
        "year2": -1,
        "year1": -1,
        "month": -1,
        "monthShort": -1,
        "monthLong": -1,
        "weekdayShort": -1,
        "weekdayLong": -1,
        "day": -1,
        "yearDay": -1,
        "week": -1,
        "hourBase0": -1,
        "hour12Base0": -1,
        "hourBase1": -1,
        "hour12Base1": -1,
        "minute": -1,
        "second": -1,
        "millisecond": -1,
        "millisecondDigits": -1,
        "am": -1,
        "zone": -1,
        "timestamp": -1,
        "iso": -1
      };
      var resValues = {
        "year": 1970,
        "month": 0,
        "day": 1,
        "hour": 0,
        "minute": 0,
        "second": 0,
        "millisecond": 0,
        "timestamp": null,
        "offset": 0,
        "utc": this.utc
      };
      var indexAdjust = 0, index = 0;
      for (var i = 0; i < info.parts.length; i++) {
        index = i + indexAdjust + 1;
        switch (info.parts[i]) {
          case "yyyy":
          case "YYYY":
            reg += "([0-9]{4})";
            parsedIndexes.year = index;
            break;
          case "yyy":
          case "YYY":
            reg += "([0-9]{3})";
            parsedIndexes.year3 = index;
            break;
          case "yy":
          case "YY":
            reg += "([0-9]{2})";
            parsedIndexes.year2 = index;
            break;
          case "y":
          case "Y":
            reg += "([0-9]{1})";
            parsedIndexes.year1 = index;
            break;
          case "MMMM":
            reg += "(" + this.getStringList(this.months).join("|") + ")";
            parsedIndexes.monthLong = index;
            break;
          case "MMM":
            reg += "(" + this.getStringList(this.monthsShort).join("|") + ")";
            parsedIndexes.monthShort = index;
            break;
          case "MM":
          case "M":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.month = index;
            break;
          case "ww":
          case "w":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.week = index;
            break;
          case "dd":
          case "d":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.day = index;
            break;
          case "DDD":
          case "DD":
          case "D":
            reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
            parsedIndexes.yearDay = index;
            break;
          case "dddd":
            reg += "(" + this.getStringList(this.weekdays).join("|") + ")";
            parsedIndexes.weekdayLong = index;
            break;
          case "ddd":
            reg += "(" + this.getStringList(this.weekdaysShort).join("|") + ")";
            parsedIndexes.weekdayShort = index;
            break;
          case "aaa":
          case "aa":
          case "a":
            reg += "(" + this.getStringList(["AM", "PM", "A.M.", "P.M.", "A", "P"]).join("|") + ")";
            parsedIndexes.am = index;
            break;
          case "hh":
          case "h":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.hour12Base1 = index;
            break;
          case "HH":
          case "H":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.hourBase0 = index;
            break;
          case "KK":
          case "K":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.hour12Base0 = index;
            break;
          case "kk":
          case "k":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.hourBase1 = index;
            break;
          case "mm":
          case "m":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.minute = index;
            break;
          case "ss":
          case "s":
            reg += "([0-9]{2}|[0-9]{1})";
            parsedIndexes.second = index;
            break;
          case "SSS":
          case "SS":
          case "S":
            reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
            parsedIndexes.millisecond = index;
            parsedIndexes.millisecondDigits = info.parts[i].length;
            break;
          case "nnn":
          case "nn":
          case "n":
            reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
            parsedIndexes.millisecond = index;
            break;
          case "x":
            reg += "([0-9]{1,})";
            parsedIndexes.timestamp = index;
            break;
          case "Z":
            reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";
            parsedIndexes.zone = index;
            break;
          case "ZZ":
            reg += "([\\-+]+[0-9]{2}[0-9]{2})";
            parsedIndexes.zone = index;
            break;
          case "i":
            reg += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2}).?([0-9]{0,3})([zZ]|[+-][0-9]{2}:?[0-9]{2}|$)";
            parsedIndexes.iso = index;
            indexAdjust += 7;
            break;
          case "G":
          case "YYYY":
          case "YYY":
          case "YY":
          case "Y":
          case "MMMMM":
          case "W":
          case "EEEEE":
          case "EEEE":
          case "EEE":
          case "EE":
          case "E":
          case "eeeee":
          case "eeee":
          case "eee":
          case "ee":
          case "e":
          case "zzzz":
          case "zzz":
          case "zz":
          case "z":
          case "t":
            indexAdjust--;
            break;
        }
        reg += "[^0-9]*";
      }
      var regex = new RegExp(reg);
      var matches = source.match(regex);
      if (matches) {
        if (parsedIndexes.year > -1) {
          resValues.year = parseInt(matches[parsedIndexes.year]);
        }
        if (parsedIndexes.year3 > -1) {
          var val = parseInt(matches[parsedIndexes.year3]);
          val += 1e3;
          resValues.year = val;
        }
        if (parsedIndexes.year2 > -1) {
          var val = parseInt(matches[parsedIndexes.year2]);
          if (val > 50) {
            val += 1e3;
          } else {
            val += 2e3;
          }
          resValues.year = val;
        }
        if (parsedIndexes.year1 > -1) {
          var val = parseInt(matches[parsedIndexes.year1]);
          val = Math.floor((/* @__PURE__ */ new Date()).getFullYear() / 10) * 10 + val;
          resValues.year = val;
        }
        if (parsedIndexes.monthLong > -1) {
          resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);
        }
        if (parsedIndexes.monthShort > -1) {
          resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);
        }
        if (parsedIndexes.month > -1) {
          resValues.month = parseInt(matches[parsedIndexes.month]) - 1;
        }
        if (parsedIndexes.week > -1 && parsedIndexes.day === -1) {
          resValues.month = 0;
          resValues.day = getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this.utc);
        }
        if (parsedIndexes.day > -1) {
          resValues.day = parseInt(matches[parsedIndexes.day]);
        }
        if (parsedIndexes.yearDay > -1) {
          resValues.month = 0;
          resValues.day = parseInt(matches[parsedIndexes.yearDay]);
        }
        if (parsedIndexes.hourBase0 > -1) {
          resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);
        }
        if (parsedIndexes.hourBase1 > -1) {
          resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;
        }
        if (parsedIndexes.hour12Base0 > -1) {
          var val = parseInt(matches[parsedIndexes.hour12Base0]);
          if (val == 11) {
            val = 0;
          }
          if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {
            val += 12;
          }
          resValues.hour = val;
        }
        if (parsedIndexes.hour12Base1 > -1) {
          var val = parseInt(matches[parsedIndexes.hour12Base1]);
          if (val == 12) {
            val = 0;
          }
          if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {
            val += 12;
          }
          resValues.hour = val;
        }
        if (parsedIndexes.minute > -1) {
          resValues.minute = parseInt(matches[parsedIndexes.minute]);
        }
        if (parsedIndexes.second > -1) {
          resValues.second = parseInt(matches[parsedIndexes.second]);
        }
        if (parsedIndexes.millisecond > -1) {
          var val = parseInt(matches[parsedIndexes.millisecond]);
          if (parsedIndexes.millisecondDigits == 2) {
            val *= 10;
          } else if (parsedIndexes.millisecondDigits == 1) {
            val *= 100;
          }
          resValues.millisecond = val;
        }
        if (parsedIndexes.timestamp > -1) {
          resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);
          var ts = new Date(resValues.timestamp);
          resValues.year = ts.getUTCFullYear();
          resValues.month = ts.getUTCMonth();
          resValues.day = ts.getUTCDate();
          resValues.hour = ts.getUTCHours();
          resValues.minute = ts.getUTCMinutes();
          resValues.second = ts.getUTCSeconds();
          resValues.millisecond = ts.getUTCMilliseconds();
        }
        if (parsedIndexes.zone > -1) {
          resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);
        }
        if (parsedIndexes.iso > -1) {
          resValues.year = toNumber(matches[parsedIndexes.iso + 0]);
          resValues.month = toNumber(matches[parsedIndexes.iso + 1]) - 1;
          resValues.day = toNumber(matches[parsedIndexes.iso + 2]);
          resValues.hour = toNumber(matches[parsedIndexes.iso + 3]);
          resValues.minute = toNumber(matches[parsedIndexes.iso + 4]);
          resValues.second = toNumber(matches[parsedIndexes.iso + 5]);
          resValues.millisecond = toNumber(matches[parsedIndexes.iso + 6]);
          if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {
            resValues.utc = true;
          } else if (matches[parsedIndexes.iso + 7] != "") {
            resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);
          }
        }
        if (resValues.utc) {
          res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));
        } else {
          res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);
        }
      } else {
        res = new Date(source);
      }
      return res;
    };
    DateFormatter2.prototype.resolveTimezoneOffset = function(date, zone) {
      var value = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
      if (value) {
        var match = getValue(zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/));
        var dir = match[1];
        var hour = match[2];
        var minute = match[3];
        var offset = parseInt(hour) * 60 + parseInt(minute);
        if (dir == "+") {
          offset *= -1;
        }
        var originalOffset = (date || /* @__PURE__ */ new Date()).getTimezoneOffset();
        var diff = offset - originalOffset;
        return diff;
      }
      return 0;
    };
    DateFormatter2.prototype.resolveMonth = function(value) {
      var month = this.months.indexOf(value);
      if (month > -1) {
        return month;
      }
      if (this.language && !this.language.isDefault()) {
        month = this.language.translateAll(this.months).indexOf(value);
        if (month > -1) {
          return month;
        }
      }
      return 0;
    };
    DateFormatter2.prototype.resolveShortMonth = function(value) {
      var month = this.monthsShort.indexOf(value);
      if (month > -1) {
        return month;
      }
      month = this.months.indexOf(value);
      if (month > -1) {
        return month;
      }
      if (this.language && !this.language.isDefault()) {
        month = this.language.translateAll(this.monthsShort).indexOf(value);
        if (month > -1) {
          return month;
        }
      }
      return 0;
    };
    DateFormatter2.prototype.isAm = function(value) {
      var list = this.getStringList(["AM", "A.M.", "A"]);
      return list.indexOf(value.toUpperCase()) > -1;
    };
    DateFormatter2.prototype.invalidateSprite = function() {
      if (this.sprite) {
        this.sprite.invalidate();
      }
    };
    DateFormatter2.prototype.getStringList = function(list) {
      var res = [];
      for (var i = 0; i < list.length; i++) {
        if (this.language) {
          res.push(escapeForRgex(this.language.translate(list[i])));
        } else {
          res.push(escapeForRgex(list[i]));
        }
      }
      return res;
    };
    Object.defineProperty(DateFormatter2.prototype, "dateFormat", {
      /**
       * @return Date format
       */
      get: function() {
        return this._dateFormat;
      },
      /**
       * Date format to use.
       *
       * If format is not supplied in-line in the string, this setting will be
       * used.
       *
       * @default "yyyy-MM-dd"
       * @param value Date format
       */
      set: function(value) {
        this._dateFormat = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "inputDateFormat", {
      /**
       * @return Date format
       */
      get: function() {
        return this._inputDateFormat;
      },
      /**
       * Date format to use when parsing dates.
       *
       * @default "yyyy-MM-dd"
       * @param value Date format
       */
      set: function(value) {
        this._inputDateFormat = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "intlLocales", {
      /**
       * @return Date format
       */
      get: function() {
        return this._intlLocales;
      },
      /**
       * Locales if you are using date formats in `Intl.DateTimeFormatOptions` syntax.
       *
       * @param value Locales
       */
      set: function(value) {
        this._intlLocales = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "utc", {
      /**
       * @return Use UTC?
       */
      get: function() {
        return this._utc;
      },
      /**
       * Should formatter use UTC functions?
       *
       * If UTC is used, all date/time values will be independent on client's
       * time zone.
       *
       * @param value Use UTC?
       */
      set: function(value) {
        this._utc = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "timezoneOffset", {
      /**
       * @return Offset (minutes)
       */
      get: function() {
        return this._timezoneOffset;
      },
      /**
       * If set, will apply specific offset in minutes before formatting the date
       * text.
       *
       * The value is a number of minutes from target time zone to UTC.
       *
       * E.g. `300` will recalculate Dates in "GMT-5" time zone.
       *
       * @param  value  Offset (minutes)
       */
      set: function(value) {
        if (this._timezoneOffset != value) {
          this._timezoneOffset = value;
          this.invalidateSprite();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "timezone", {
      /**
       * @return Timezone
       */
      get: function() {
        return this._timezone;
      },
      /**
       * If set, will format date/time in specific time zone.
       *
       * The value should be named time zone, e.g.:
       * `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`.
       *
       * @since 4.10.1
       * @param  value  Timezone
       */
      set: function(value) {
        if (this._timezone != value) {
          this._timezone = value;
          this.timezoneMinutes = getTimezoneMinutes(value);
          this.invalidateSprite();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "firstDayOfWeek", {
      /**
       * @return First day of week
       */
      get: function() {
        return this._firstDayOfWeek;
      },
      /**
       * First day of the week:
       *
       * * 0 - Sunday
       * * 1 - Monday
       * * 2 - Tuesday
       *
       * Etc.
       *
       * @param value First day of week
       */
      set: function(value) {
        this._firstDayOfWeek = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateFormatter2.prototype, "outputFormat", {
      /**
       * @ignore Exclude from docs
       * @return Format
       */
      get: function() {
        return this._outputFormat;
      },
      /**
       * Output format for the formatted date.
       *
       * @ignore Exclude from docs
       * @param value  Format
       */
      set: function(value) {
        this._outputFormat = value.toLowerCase();
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    return DateFormatter2;
  }(BaseObject)
);
registry.registeredClasses["DateFormatter"] = DateFormatter;

// node_modules/@amcharts/amcharts4/.internal/core/formatters/DurationFormatter.js
var DurationFormatter = (
  /** @class */
  function(_super) {
    __extends(DurationFormatter2, _super);
    function DurationFormatter2() {
      var _this = _super.call(this) || this;
      _this._negativeBase = 0;
      _this._baseUnit = "second";
      _this._outputFormat = "svg";
      _this._unitValues = {
        "millisecond": 1,
        "second": 1e3,
        "minute": 6e4,
        "hour": 36e5,
        "day": 864e5,
        "week": 6048e5,
        "month": 2592e6,
        "year": 31536e6
      };
      _this._unitAliases = {
        "Y": "y",
        "D": "d",
        "H": "h",
        "K": "h",
        "k": "h",
        "n": "S"
      };
      _this.className = "DurationFormatter";
      _this.applyTheme();
      return _this;
    }
    DurationFormatter2.prototype.format = function(value, format, base) {
      if (!this.language) {
        if (this.sprite) {
          this.language = this.sprite.language;
        } else {
          this.language = new Language();
        }
      }
      var baseUnit = base || this._baseUnit;
      if (typeof format === "undefined" || format === "") {
        if (hasValue(this.durationFormat)) {
          format = this.durationFormat;
        } else {
          format = this.getFormat(toNumber(value), null, baseUnit);
        }
      }
      format = cleanFormat(format);
      var info = this.parseFormat(format, baseUnit);
      var source = Number(value);
      var details;
      if (source > this._negativeBase) {
        details = info.positive;
      } else if (source < this._negativeBase) {
        details = info.negative;
      } else {
        details = info.zero;
      }
      var formatted = this.applyFormat(source, details);
      if (details.color !== "") {
        if (this._outputFormat === "svg") {
          formatted = "<tspan fill='" + details.color + "'>" + formatted + "</tspan>";
        } else if (this._outputFormat === "html") {
          formatted = "<span style='color: " + details.color + ";'>" + formatted + "</span>";
        }
      }
      return formatted;
    };
    DurationFormatter2.prototype.parseFormat = function(format, base) {
      var _this = this;
      var cached = this.getCache(format);
      if (hasValue(cached)) {
        return cached;
      }
      var baseUnit = base || this._baseUnit;
      var info = {
        "positive": {
          "color": "",
          "template": "",
          "parts": [],
          "source": "",
          "baseUnit": baseUnit,
          "parsed": false,
          "absolute": false
        },
        "negative": {
          "color": "",
          "template": "",
          "parts": [],
          "source": "",
          "baseUnit": baseUnit,
          "parsed": false,
          "absolute": false
        },
        "zero": {
          "color": "",
          "template": "",
          "parts": [],
          "source": "",
          "baseUnit": baseUnit,
          "parsed": false,
          "absolute": false
        }
      };
      format = format.replace("||", PLACEHOLDER2);
      var parts = format.split("|");
      info.positive.source = parts[0];
      if (typeof parts[2] === "undefined") {
        info.zero = info.positive;
      } else {
        info.zero.source = parts[2];
      }
      if (typeof parts[1] === "undefined") {
        info.negative = info.positive;
      } else {
        info.negative.source = parts[1];
      }
      each2(info, function(part, item) {
        if (item.parsed) {
          return;
        }
        if (typeof _this.getCache(item.source) !== "undefined") {
          info[part] = _this.getCache(item.source);
          return;
        }
        var partFormat = item.source;
        var dirs = [];
        dirs = item.source.match(/^\[([^\]]*)\]/);
        if (dirs && dirs.length && dirs[0] !== "") {
          partFormat = item.source.substr(dirs[0].length);
          item.color = dirs[1];
        }
        var chunks = getTextFormatter().chunk(partFormat, true);
        for (var i = 0; i < chunks.length; i++) {
          var chunk = chunks[i];
          chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
          if (chunk.type === "value") {
            if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {
              item.absolute = true;
              chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");
            }
            var matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
            if (matches) {
              for (var x = 0; x < matches.length; x++) {
                if (!hasValue(matches[x])) {
                  matches[x] = _this._unitAliases[matches[x]];
                }
                item.parts.push(matches[x]);
                chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
              }
            }
          }
          item.template += chunk.text;
        }
        _this.setCache(item.source, item);
        item.parsed = true;
      });
      this.setCache(format, info);
      return info;
    };
    DurationFormatter2.prototype.applyFormat = function(value, details) {
      var negative = !details.absolute && value < this._negativeBase;
      value = Math.abs(value);
      var tstamp = this.toTimeStamp(value, details.baseUnit);
      var res = details.template;
      for (var i = 0, len = details.parts.length; i < len; i++) {
        var part = details.parts[i];
        var unit = this.toTimeUnit(part.substr(0, 1));
        var digits = part.length;
        var ints = Math.floor(tstamp / this._unitValues[unit]);
        res = res.replace(PLACEHOLDER, padString(ints, digits, "0"));
        tstamp -= ints * this._unitValues[unit];
      }
      if (negative) {
        res = "-" + res;
      }
      return res;
    };
    DurationFormatter2.prototype.toTimeStamp = function(value, baseUnit) {
      return value * this._unitValues[baseUnit];
    };
    DurationFormatter2.prototype.toTimeUnit = function(code) {
      switch (code) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
      }
      ;
    };
    DurationFormatter2.prototype.invalidateSprite = function() {
      if (this.sprite) {
        this.sprite.invalidate();
      }
    };
    Object.defineProperty(DurationFormatter2.prototype, "baseUnit", {
      /**
       * @return Base unit
       */
      get: function() {
        return this._baseUnit;
      },
      /**
       * Base unit the values are in.
       *
       * A base unit will be used to recalculate the numeric value to millisecond
       * timestamps.
       *
       * Available options:
       *
       * * "millisecond"
       * * "second"
       * * "minute"
       * * "hour"
       * * "day"
       * * "week"
       * * "month"
       * * "year"
       *
       * @default "s"
       * @param baseUnit  A base unit
       */
      set: function(baseUnit) {
        this._baseUnit = baseUnit;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DurationFormatter2.prototype, "outputFormat", {
      /**
       * Getter for output format.
       *
       * @ignore Exclude from docs
       * @return Output format
       */
      get: function() {
        return this._outputFormat;
      },
      /**
       * Setter for output format: "svg" or "html.
       *
       * @ignore Exclude from docs
       * @param value  Output format
       */
      set: function(outputFormat) {
        this._outputFormat = outputFormat.toLowerCase();
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    DurationFormatter2.prototype.getFormat = function(value, maxValue, baseUnit) {
      if (hasValue(this.durationFormat)) {
        return this.durationFormat;
      }
      if (!baseUnit) {
        baseUnit = this.baseUnit;
      }
      if (hasValue(maxValue) && value != maxValue) {
        value = Math.abs(value);
        maxValue = Math.abs(maxValue);
        var maxUnit = this.getValueUnit(max(value, maxValue), baseUnit);
        return this.durationFormats[baseUnit][maxUnit];
      } else {
        var unit = this.getValueUnit(value, baseUnit);
        return this.durationFormats[baseUnit][unit];
      }
    };
    DurationFormatter2.prototype.getValueUnit = function(value, baseUnit) {
      if (!baseUnit) {
        baseUnit = this.baseUnit;
      }
      var currentUnit;
      var ms = this.getMilliseconds(value, baseUnit);
      eachContinue2(this._unitValues, function(key, val) {
        if (key == baseUnit || currentUnit) {
          var num = ms / val;
          if (num <= 1) {
            if (!currentUnit) {
              currentUnit = key;
            }
            return false;
          }
          currentUnit = key;
        }
        return true;
      });
      return currentUnit;
    };
    DurationFormatter2.prototype.getMilliseconds = function(value, baseUnit) {
      if (!baseUnit) {
        baseUnit = this.baseUnit;
      }
      return value * this._unitValues[baseUnit];
    };
    Object.defineProperty(DurationFormatter2.prototype, "durationFormat", {
      /**
       * @return Format
       */
      get: function() {
        return this._durationFormat;
      },
      /**
       * If set, this format will be used instead of the one determined dynamically
       * based on the basedUnit and range of values.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Available fomatting codes
       * @param value  Format
       */
      set: function(value) {
        if (this._durationFormat != value) {
          this._durationFormat = value;
          this.invalidateSprite();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DurationFormatter2.prototype, "durationFormats", {
      /**
       * @return Formats
       */
      get: function() {
        if (!this._durationFormats) {
          this._durationFormats = {
            "millisecond": {
              "millisecond": this.language.translate("_duration_millisecond"),
              "second": this.language.translate("_duration_millisecond_second"),
              "minute": this.language.translate("_duration_millisecond_minute"),
              "hour": this.language.translate("_duration_millisecond_hour"),
              "day": this.language.translate("_duration_millisecond_day"),
              "week": this.language.translate("_duration_millisecond_week"),
              "month": this.language.translate("_duration_millisecond_month"),
              "year": this.language.translate("_duration_millisecond_year")
            },
            "second": {
              "second": this.language.translate("_duration_second"),
              "minute": this.language.translate("_duration_second_minute"),
              "hour": this.language.translate("_duration_second_hour"),
              "day": this.language.translate("_duration_second_day"),
              "week": this.language.translate("_duration_second_week"),
              "month": this.language.translate("_duration_second_month"),
              "year": this.language.translate("_duration_second_year")
            },
            "minute": {
              "minute": this.language.translate("_duration_minute"),
              "hour": this.language.translate("_duration_minute_hour"),
              "day": this.language.translate("_duration_minute_day"),
              "week": this.language.translate("_duration_minute_week"),
              "month": this.language.translate("_duration_minute_month"),
              "year": this.language.translate("_duration_minute_year")
            },
            "hour": {
              "hour": this.language.translate("_duration_hour"),
              "day": this.language.translate("_duration_hour_day"),
              "week": this.language.translate("_duration_hour_week"),
              "month": this.language.translate("_duration_hour_month"),
              "year": this.language.translate("_duration_hour_year")
            },
            "day": {
              "day": this.language.translate("_duration_day"),
              "week": this.language.translate("_duration_day_week"),
              "month": this.language.translate("_duration_day_month"),
              "year": this.language.translate("_duration_day_year")
            },
            "week": {
              "week": this.language.translate("_duration_week"),
              "month": this.language.translate("_duration_week_month"),
              "year": this.language.translate("_duration_week_year")
            },
            "month": {
              "month": this.language.translate("_duration_month"),
              "year": this.language.translate("_duration_month_year")
            },
            "year": {
              "year": this.language.translate("_duration_year")
            }
          };
        }
        return this._durationFormats;
      },
      /**
       * Duration formats for various combination of base units.
       *
       * @param value  Formats
       */
      set: function(value) {
        this._durationFormats = value;
        this.invalidateSprite();
      },
      enumerable: true,
      configurable: true
    });
    return DurationFormatter2;
  }(BaseObject)
);
registry.registeredClasses["DurationFormatter"] = DurationFormatter;

// node_modules/@amcharts/amcharts4/.internal/core/export/ExportCSS.js
var rules2 = new Dictionary();
function ExportCSS_default(element, prefix) {
  var newPrefix = prefix ? prefix : "amexport";
  var colorSet = new InterfaceColorSet();
  var counter = rules2.insertKeyIfEmpty(newPrefix, function() {
    var disposer = new MultiDisposer([
      /*new StyleRule(`.${newPrefix}-menu`, {
                      "opacity": "0.3",
                      "transition": "all 100ms ease-in-out",
                  }),
      
                  new StyleRule(`div:hover .${newPrefix}-menu, .${newPrefix}-menu.active`, {
                      "opacity": "0.9",
                  }),*/
      new StyleRule(element, "." + newPrefix + "-menu *", {
        "box-sizing": "border-box"
      }),
      new StyleRule(element, "." + newPrefix + "-menu-level-0", {
        "position": "absolute",
        "top": "5px",
        "right": "5px"
      }),
      new StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-left", {
        "right": "auto",
        "left": "5px"
      }),
      new StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-right", {
        "right": "5px",
        "left": "auto"
      }),
      new StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-top", {
        "top": "5px",
        "bottom": "auto"
      }),
      new StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-bottom", {
        "top": "auto",
        "bottom": "5px"
      }),
      new StyleRule(element, "." + newPrefix + "-item." + newPrefix + "-item-level-0", {
        "opacity": "0.3",
        "width": "30px",
        "min-height": "30px",
        "transition": "all 100ms ease-in-out"
      }),
      new StyleRule(element, "div:hover > div > ." + newPrefix + "-menu ." + newPrefix + "-item." + newPrefix + "-item-level-0, ." + newPrefix + "-item." + newPrefix + "-item-level-0.active", {
        "opacity": "0.9"
      }),
      new StyleRule(element, "." + newPrefix + "-item." + newPrefix + "-item-level-0 > a", {
        "padding": "0",
        "text-align": "center",
        "overflow": "hidden"
      }),
      new StyleRule(element, "." + newPrefix + "-item." + newPrefix + "-item-level-0:before", {
        "display": "block"
      }),
      new StyleRule(element, "." + newPrefix + "-item", {
        "position": "relative",
        "display": "block",
        "opacity": "0",
        "z-index": "1",
        "border-radius": "3px",
        "background-color": colorSet.getFor("secondaryButton").hex,
        "padding": "0",
        "margin": "1px 1px 0 0",
        "color": colorSet.getFor("secondaryButton").alternative.hex,
        "transition": "all 100ms ease-in-out, opacity 0.5s ease 0.5s"
      }),
      new StyleRule(element, "." + newPrefix + "-left ." + newPrefix + "-item", {
        "margin": "1px 0 0 1px"
      }),
      new StyleRule(element, "." + newPrefix + "-item:hover, ." + newPrefix + "-item.active", {
        "background": colorSet.getFor("secondaryButtonHover").hex,
        "color": colorSet.getFor("secondaryButtonText").hex
      }),
      new StyleRule(element, "." + newPrefix + "-item > ." + newPrefix + "-menu", {
        "position": "absolute",
        "top": "-1px",
        "right": "0",
        "margin-right": "100%"
      }),
      new StyleRule(element, "." + newPrefix + "-left ." + newPrefix + "-item > ." + newPrefix + "-menu", {
        "left": "0",
        "right": "auto",
        "margin-left": "100%",
        "margin-right": "auto"
      }),
      new StyleRule(element, "." + newPrefix + "-right ." + newPrefix + "-item > ." + newPrefix + "-menu", {
        "left": "auto",
        "right": "0",
        "margin-left": "auto",
        "margin-right": "100%"
      }),
      new StyleRule(element, "." + newPrefix + "-top ." + newPrefix + "-item > ." + newPrefix + "-menu", {
        "top": "-1px",
        "bottom": "auto"
      }),
      new StyleRule(element, "." + newPrefix + "-bottom ." + newPrefix + "-item > ." + newPrefix + "-menu", {
        "top": "auto",
        "bottom": "0"
      }),
      new StyleRule(element, "." + newPrefix + "-item > ." + newPrefix + "-menu", {
        "display": "none"
      }),
      new StyleRule(element, "." + newPrefix + "-item:hover > ." + newPrefix + "-menu, ." + newPrefix + "-item.active > ." + newPrefix + "-menu", {
        "display": "block"
      }),
      new StyleRule(element, "." + newPrefix + "-item:hover > ." + newPrefix + "-menu > ." + newPrefix + "-item, ." + newPrefix + "-item.active > ." + newPrefix + "-menu > ." + newPrefix + "-item", {
        "opacity": "1"
      }),
      new StyleRule(element, "." + newPrefix + "-menu", {
        "display": "block",
        "list-style": "none",
        "margin": "0",
        "padding": "0"
      }),
      new StyleRule(element, "." + newPrefix + "-label", {
        "display": "block",
        "cursor": "default",
        "padding": "0.5em 1em"
      }),
      new StyleRule(element, "." + newPrefix + "-icon", {
        "display": "block",
        "cursor": "default",
        "padding": "0.2em 0.4em",
        "width": "1.2em",
        "height": "1.2em",
        "min-width": "32px",
        "min-height": "32px",
        "margin": "auto auto",
        "border-radius": "3px"
      }),
      new StyleRule(element, "." + newPrefix + "-item-level-0 > ." + newPrefix + "-icon", {
        "padding": "0.1em 0.2em"
      }),
      new StyleRule(element, "." + newPrefix + "-clickable", {
        "cursor": "pointer"
      })
    ]);
    return new CounterDisposer(function() {
      rules2.removeKey(newPrefix);
      disposer.dispose();
    });
  });
  return counter.increment();
}

// node_modules/@amcharts/amcharts4/.internal/core/utils/Validatable.js
var Validatable = (
  /** @class */
  function(_super) {
    __extends(Validatable2, _super);
    function Validatable2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._validateDisposer = null;
      return _this;
    }
    Validatable2.prototype.invalidate = function() {
      if (this._validateDisposer === null) {
        this._validateDisposer = registry.events.on("exitframe", this.validate, this);
      }
    };
    Validatable2.prototype.validate = function() {
      if (this._validateDisposer !== null) {
        this._validateDisposer.dispose();
        this._validateDisposer = null;
      }
    };
    Validatable2.prototype.dispose = function() {
      if (this._validateDisposer !== null) {
        this._validateDisposer.dispose();
        this._validateDisposer = null;
      }
      _super.prototype.dispose.call(this);
    };
    return Validatable2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/export/ExportMenu.js
var ExportMenu = (
  /** @class */
  function(_super) {
    __extends(ExportMenu2, _super);
    function ExportMenu2() {
      var _this = _super.call(this) || this;
      _this.adapter = new Adapter(_this);
      _this.closeDelay = 1e3;
      _this.closeOnClick = true;
      _this._language = new MutableValueDisposer();
      _this._menuTag = "ul";
      _this._itemTag = "li";
      _this._labelTag = "a";
      _this._iconTag = "img";
      _this._classPrefix = "amexport";
      _this._defaultStyles = true;
      _this._align = "right";
      _this._verticalAlign = "top";
      _this._tabindex = 0;
      _this._ignoreNextClose = false;
      _this._items = [
        {
          "label": "...",
          "menu": [
            {
              "label": "Image",
              "menu": [
                { "type": "png", "label": "PNG" },
                { "type": "jpg", "label": "JPG" },
                { "type": "svg", "label": "SVG" },
                { "type": "pdf", "label": "PDF" }
              ]
            },
            {
              "label": "Data",
              "menu": [
                { "type": "json", "label": "JSON" },
                { "type": "csv", "label": "CSV" },
                { "type": "xlsx", "label": "XLSX" },
                { "type": "html", "label": "HTML" },
                { "type": "pdfdata", "label": "PDF" }
              ]
            },
            {
              "label": "Print",
              "type": "print"
            }
          ]
        }
      ];
      _this.className = "ExportMenu";
      _this._disposers.push(_this._language);
      _this.invalidate();
      _this.applyTheme();
      return _this;
    }
    ExportMenu2.prototype.validate = function() {
      this.draw();
      _super.prototype.validate.call(this);
    };
    ExportMenu2.prototype.draw = function() {
      var _this = this;
      if (!this._element) {
        this._element = this.createMenuElement(0);
      } else {
        this._element.innerHTML = "";
        this._element.className = this.getMenuItemClass(0);
      }
      if (this.defaultStyles) {
        this._element.style.display = "none";
      }
      getValue(this._container).appendChild(this._element);
      var items = this.adapter.apply("items", {
        items: this._items
      }).items;
      for (var len = items.length, i = 0; i < len; i++) {
        this.drawBranch(this._element, items[i], 0);
      }
      this._element = this.adapter.apply("menuElement", {
        menuElement: this._element
      }).menuElement;
      this._disposers.push(getInteraction().body.events.on("down", function(ev) {
        if (!ev.pointer.touch) {
          _this._ignoreNextClose = false;
        }
        _this.close();
      }));
      this._disposers.push(getInteraction().body.events.on("keydown", function(ev) {
        var key = keyboard.getEventKey(ev.event);
        switch (key) {
          case "esc":
            _this.close();
            break;
          case "up":
          case "down":
          case "left":
          case "right":
            if (_this._currentSelection) {
              ev.event.preventDefault();
            }
            _this.moveSelection(key);
            break;
        }
      }));
      if (this.defaultStyles) {
        this.loadDefaultCSS();
      }
    };
    ExportMenu2.prototype.drawBranch = function(container, branch, level) {
      var _this = this;
      branch = this.adapter.apply("branch", {
        branch,
        level
      }).branch;
      if (branch.unsupported === true) {
        return;
      }
      if (!branch.ascendants) {
        branch.ascendants = new List();
      }
      var type = branch.type;
      var element = this.createItemElement(level, type);
      var label;
      if (branch.icon) {
        label = this.createIconElement(level, type);
        label.src = branch.icon;
        if (branch.label || branch.title) {
          label.title = branch.title || branch.label;
        }
      } else if (branch.svg) {
        label = this.createSvgElement(level, type, branch.svg);
        if (branch.label || branch.title) {
          label.title = branch.title || branch.label;
        }
      } else {
        label = this.createLabelElement(level, type);
        label.innerHTML = branch.label ? this.language.translate(branch.label) : "";
        if (branch.title) {
          label.title = branch.title;
        }
      }
      var readerLabel = this.getReaderLabel(branch, label.innerHTML);
      label.setAttribute("aria-label", readerLabel);
      element.appendChild(label);
      branch.interactions = getInteraction().getInteraction(element);
      branch.element = element;
      if (this.typeClickable(type)) {
        branch.interactions.events.on("hit", function(ev) {
          if (_this.events.isEnabled("hit") && !_this.isDisposed()) {
            var event_1 = {
              "type": "hit",
              "event": ev.event,
              "target": _this,
              "branch": branch
            };
            _this.events.dispatchImmediately("hit", event_1);
          }
        });
        branch.interactions.events.on("keyup", function(ev) {
          if (keyboard.isKey(ev.event, "enter")) {
            if (_this.events.isEnabled("enter")) {
              var event_2 = {
                "type": "enter",
                "event": ev.event,
                "target": _this,
                "branch": branch
              };
              _this.events.dispatchImmediately("enter", event_2);
            }
          }
        });
      }
      {
        var submenu_1 = this.getSubMenu(branch);
        if (submenu_1 != null) {
          branch.interactions.events.on("keyup", function(ev) {
            if (keyboard.isKey(ev.event, "enter")) {
              _this.selectBranch(submenu_1[0]);
              _this.setFocus(submenu_1[0]);
            }
          });
          branch.interactions.events.on("hit", function(ev) {
            _this.selectBranch(branch);
          });
        }
      }
      branch.interactions.events.on("over", function(ev) {
        if (ev.pointer.touch) {
          _this._ignoreNextClose = true;
        }
        _this.selectBranch(branch);
        if (_this.events.isEnabled("over")) {
          var event_3 = {
            "type": "over",
            "event": ev.event,
            "target": _this,
            "branch": branch
          };
          _this.events.dispatchImmediately("over", event_3);
        }
      });
      branch.interactions.events.on("out", function(ev) {
        if (_this.isDisposed()) {
          return;
        }
        if (!ev.pointer.touch) {
          _this.delayUnselectBranch(branch);
        }
        if (_this.events.isEnabled("out")) {
          var event_4 = {
            "type": "out",
            "event": ev.event,
            "target": _this,
            "branch": branch
          };
          _this.events.dispatchImmediately("out", event_4);
        }
      });
      branch.interactions.events.on("focus", function(ev) {
        _this.selectBranch(branch);
      });
      branch.interactions.events.on("blur", function(ev) {
        _this.delayUnselectBranch(branch);
      });
      var local_level = level + 1;
      if (branch.menu) {
        var submenu = this.createMenuElement(local_level);
        branch.submenuElement = submenu;
        for (var len = branch.menu.length, i = 0; i < len; i++) {
          var ascendants = new List();
          branch.menu[i].ascendants = ascendants;
          if (branch.ascendants.length) {
            ascendants.copyFrom(branch.ascendants);
          }
          ascendants.push(branch);
          this.drawBranch(submenu, branch.menu[i], local_level);
        }
        if (submenu.innerHTML == "") {
          return;
        }
        element.appendChild(submenu);
      }
      if (branch.hidden) {
        this.hideBranch(branch);
      }
      if (branch.id) {
        element.setAttribute("id", branch.id);
      }
      if (branch.color) {
        element.style.backgroundColor = branch.color.hex;
      }
      container.appendChild(element);
    };
    ExportMenu2.prototype.createMenuElement = function(level) {
      var element = document.createElement(this.menuTag);
      element.className = this.getMenuItemClass(level);
      if (level === 0) {
        element.setAttribute("role", "menubar");
      } else {
        element.setAttribute("role", "menu");
      }
      return element;
    };
    ExportMenu2.prototype.getMenuItemClass = function(level) {
      var className = this.classPrefix + "-menu " + this.classPrefix + "-menu-level-" + level;
      if (level === 0) {
        className += " " + this.classPrefix + "-menu-root " + this.classPrefix + "-" + this.align + " " + this.classPrefix + "-" + this.verticalAlign;
      }
      return this.adapter.apply("menuClass", {
        className,
        level
      }).className;
    };
    ExportMenu2.prototype.createItemElement = function(level, type) {
      var element = document.createElement(this.itemTag);
      var className = this.classPrefix + "-item " + this.classPrefix + "-item-level-" + level + " " + this.classPrefix + "-item-" + (type || "blank");
      element.className = this.adapter.apply("itemClass", {
        className,
        level,
        type
      }).className;
      element.setAttribute("role", "menuitem");
      element.setAttribute("tabindex", this.tabindex.toString());
      return element;
    };
    ExportMenu2.prototype.createLabelElement = function(level, type) {
      var element = document.createElement(this.labelTag);
      var className = this.classPrefix + "-label " + this.classPrefix + "-label-level-" + level + " " + this.classPrefix + "-item-" + (type || "blank");
      if (this.typeClickable(type)) {
        className += " " + this.classPrefix + "-clickable";
      }
      element.className = this.adapter.apply("labelClass", {
        className,
        level,
        type
      }).className;
      return element;
    };
    ExportMenu2.prototype.createIconElement = function(level, type) {
      var element = document.createElement(this.iconTag);
      var className = this.classPrefix + "-icon " + this.classPrefix + "-icon-level-" + level + " " + this.classPrefix + "-item-" + (type || "blank");
      if (this.typeClickable(type)) {
        className += " " + this.classPrefix + "-clickable";
      }
      element.className = this.adapter.apply("labelClass", {
        className,
        level,
        type
      }).className;
      element.setAttribute("tabindex", this.tabindex.toString());
      element.setAttribute("role", "menuitem");
      return element;
    };
    ExportMenu2.prototype.createSvgElement = function(level, type, svg) {
      var parser = new DOMParser();
      var element = parser.parseFromString(svg, "image/svg+xml").documentElement;
      var className = this.classPrefix + "-icon " + this.classPrefix + "-icon-level-" + level + " " + this.classPrefix + "-item-" + (type || "blank");
      if (this.typeClickable(type)) {
        className += " " + this.classPrefix + "-clickable";
      }
      element.setAttribute("class", this.adapter.apply("labelClass", {
        className,
        level,
        type
      }).className);
      element.setAttribute("tabindex", this.tabindex.toString());
      element.setAttribute("role", "menuitem");
      return element;
    };
    ExportMenu2.prototype.dispose = function() {
      if (!this._disposed) {
        _super.prototype.dispose.call(this);
        if (this._element && this._element.parentNode) {
          this._element.parentNode.removeChild(this._element);
        }
      }
    };
    ExportMenu2.prototype.typeClickable = function(type) {
      return hasValue(type);
    };
    ExportMenu2.prototype.hasSubMenu = function(branch) {
      return branch.menu && branch.menu.length ? true : false;
    };
    ExportMenu2.prototype.getSubMenu = function(branch) {
      if (branch.menu && branch.menu.length) {
        return branch.menu;
      }
    };
    ExportMenu2.prototype.getReaderLabel = function(branch, label) {
      label = stripTags(label);
      if (branch.ascendants.length == 0) {
        label = label == "..." ? this.language.translate("Export") : label;
        label += " [" + this.language.translate("Press ENTER or use arrow keys to navigate") + "]";
      } else if (this.hasSubMenu(branch)) {
        label += " [" + this.language.translate("Click, tap or press ENTER to open") + "]";
      } else if (branch.type == "print") {
        label = this.language.translate("Click, tap or press ENTER to print.");
      } else if (this.typeClickable(branch.type)) {
        label = this.language.translate("Click, tap or press ENTER to export as %1.", void 0, label);
      }
      return this.adapter.apply("rederLabel", {
        label,
        branch
      }).label;
    };
    Object.defineProperty(ExportMenu2.prototype, "container", {
      /**
       * @return Container
       */
      get: function() {
        return this._container;
      },
      /**
       * Getters and setters
       */
      /**
       * An HTML container to place the Menu in.
       *
       * A container must be an HTML element, because menu itself is HTML, and
       * cannot be placed into SVG.
       *
       * @param container Reference to container element
       * @todo Check if menu is already build. If it is, just move it to a new container
       */
      set: function(container) {
        this._container = container;
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "items", {
      /**
       * @return Menu items
       */
      get: function() {
        return this._items;
      },
      /**
       * A list of menu items. Can be nested.
       *
       * @param items  Menu items
       */
      set: function(items) {
        this._items = items;
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "tag", {
      /**
       * Sets main menu tag to place menu in.
       *
       * This also sets up how menu items are built.
       *
       * If you set this to "ul", menu items will be wrapped into `<li>` tags.
       *
       * If set to "div", menu items will be wrapped in `<div>` tags.
       *
       * @default "ul"
       * @param tag Tag to use for menu
       */
      set: function(tag) {
        this._menuTag = tag;
        this._itemTag = tag == "ul" ? "li" : "div";
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "menuTag", {
      /**
       * Returns current menu tag.
       *
       * @ignore Exclude from docs
       * @return Menu tag (item that contains sub-items)
       */
      get: function() {
        return this.adapter.apply("menuTag", {
          tag: this._menuTag
        }).tag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "itemTag", {
      /**
       * Returns tag to wrap items into.
       *
       * @ignore Exclude from docs
       * @return Item tag
       */
      get: function() {
        return this.adapter.apply("itemTag", {
          tag: this._itemTag
        }).tag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "labelTag", {
      /**
       * Returns menu label tag.
       *
       * @ignore Exclude from docs
       * @return Label tag
       */
      get: function() {
        return this.adapter.apply("labelTag", {
          tag: this._labelTag
        }).tag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "iconTag", {
      /**
       * Returns icon tag.
       *
       * @ignore Exclude from docs
       * @return Icon tag
       */
      get: function() {
        return this.adapter.apply("iconTag", {
          tag: this._iconTag
        }).tag;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "align", {
      /**
       * @return Horizontal alignment
       */
      get: function() {
        return this.adapter.apply("align", {
          align: this._align
        }).align;
      },
      /**
       * A horizontal alignment for the menu placement.
       *
       * @param value Horizontal alignment
       */
      set: function(value) {
        this._align = value;
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "verticalAlign", {
      /**
       * @return Vertical alignment
       */
      get: function() {
        return this.adapter.apply("verticalAlign", {
          verticalAlign: this._verticalAlign
        }).verticalAlign;
      },
      /**
       * A vertical alignment for the menu placement.
       *
       * @param value Vertical alignment
       */
      set: function(value) {
        this._verticalAlign = value;
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "classPrefix", {
      /**
       * @return Class name prefix
       */
      get: function() {
        return this.adapter.apply("classPrefix", {
          classPrefix: this._classPrefix
        }).classPrefix;
      },
      /**
       * Class name prefix.
       *
       * @default "amexport"
       * @param value Class name prefix
       */
      set: function(value) {
        this._classPrefix = value;
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "defaultStyles", {
      /**
       * @return Should ExportMenu load its own CSS?
       */
      get: function() {
        return this.adapter.apply("defaultStyles", {
          defaultStyles: this._defaultStyles
        }).defaultStyles;
      },
      /**
       * Indicates whether [[ExportMenu]] should load external CSS to style itself.
       *
       * If set to `false`, the menu will not be styled, and will rely on some
       * external CSS.
       *
       * @default true
       * @param Should ExportMenu load its own CSS?
       */
      set: function(value) {
        if (this._defaultStyles != value) {
          this._defaultStyles = value;
          if (value) {
            this.loadDefaultCSS();
          }
        }
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    ExportMenu2.prototype.loadDefaultCSS = function() {
      this._disposers.push(ExportCSS_default(getShadowRoot(this.container), this.classPrefix));
      if (this._element) {
        this._element.style.display = "";
      }
    };
    Object.defineProperty(ExportMenu2.prototype, "tabindex", {
      /**
       * @return Tab index
       */
      get: function() {
        return this.adapter.apply("tabindex", {
          tabindex: this._tabindex
        }).tabindex;
      },
      /**
       * A tab index for the menu.
       *
       * Tab index will influence the order in which elements on the chart and
       * the whole page are selected when pressing TAB key.
       *
       * @param value Tab index
       */
      set: function(value) {
        this._tabindex = value;
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExportMenu2.prototype, "language", {
      /**
       * @return A [[Language]] instance to be used
       */
      get: function() {
        var _this = this;
        var language = this._language.get();
        if (language == null) {
          language = new Language();
          this._language.set(language, language.events.on("localechanged", function(ev) {
            _this.invalidate();
          }));
        }
        return language;
      },
      /**
       * A [[Language]] instance.
       *
       * @param value An instance of [[Language]]
       */
      set: function(value) {
        var _this = this;
        this._language.set(value, value.events.on("localechanged", function(ev) {
          _this.invalidate();
        }));
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    ExportMenu2.prototype.close = function() {
      var _this = this;
      if (this.isDisposed()) {
        return;
      }
      if (this._ignoreNextClose) {
        this._ignoreNextClose = false;
        return;
      }
      if (this.closeOnClick) {
        this._element.style.pointerEvents = "none";
        setTimeout(function() {
          _this._element.style.pointerEvents = "auto";
        }, 100);
      }
      if (this._currentSelection) {
        this.setBlur(this._currentSelection);
        this._currentSelection = void 0;
      }
      if (this._element) {
        var items = this._element.getElementsByClassName("active");
        for (var len = items.length, i = len - 1; i >= 0; i--) {
          if (items[i]) {
            removeClass(items[i], "active");
          }
        }
      }
      this.events.dispatchImmediately("closed", {
        type: "closed",
        target: this
      });
    };
    ExportMenu2.prototype.selectBranch = function(branch) {
      var _this = this;
      if (this.isDisposed()) {
        return;
      }
      if (branch.closeTimeout) {
        this.removeDispose(branch.closeTimeout);
        branch.closeTimeout = void 0;
      }
      addClass(branch.element, "active");
      if (branch.submenuElement) {
        branch.submenuElement.setAttribute("aria-expanded", "true");
      }
      if (this._currentSelection && this._currentSelection !== branch && this._currentSelection.ascendants) {
        each3(concat(fromArray([this._currentSelection]), this._currentSelection.ascendants.iterator()), function(ascendant) {
          if (!branch.ascendants.contains(ascendant) && branch !== ascendant) {
            _this.unselectBranch(ascendant, true);
          }
        });
      }
      each3(branch.ascendants.iterator(), function(ascendant) {
        if (ascendant.closeTimeout) {
          _this.removeDispose(ascendant.closeTimeout);
          ascendant.closeTimeout = void 0;
        }
        addClass(ascendant.element, "active");
      });
      this._currentSelection = branch;
      if (this.events.isEnabled("branchselected")) {
        var event_5 = {
          type: "branchselected",
          target: this,
          branch
        };
        this.events.dispatchImmediately("branchselected", event_5);
      }
    };
    ExportMenu2.prototype.unselectBranch = function(branch, simple) {
      if (this.isDisposed()) {
        return;
      }
      removeClass(branch.element, "active");
      if (branch.submenuElement) {
        branch.submenuElement.removeAttribute("aria-expanded");
      }
      if (this._currentSelection == branch) {
        this._currentSelection = void 0;
      }
      if (this.events.isEnabled("branchunselected")) {
        var event_6 = {
          type: "branchunselected",
          target: this,
          branch
        };
        this.events.dispatchImmediately("branchunselected", event_6);
      }
    };
    ExportMenu2.prototype.delayUnselectBranch = function(branch, simple) {
      var _this = this;
      if (this.isDisposed()) {
        return;
      }
      if (branch.closeTimeout) {
        this.removeDispose(branch.closeTimeout);
        branch.closeTimeout = void 0;
      }
      branch.closeTimeout = this.setTimeout(function() {
        _this.unselectBranch(branch, simple);
      }, this.closeDelay);
      if (simple !== true && branch.ascendants) {
        each3(branch.ascendants.iterator(), function(ascendant) {
          _this.delayUnselectBranch(ascendant, true);
        });
      }
    };
    ExportMenu2.prototype.moveSelection = function(key) {
      if (this.isDisposed()) {
        return;
      }
      if (!this._currentSelection) {
        return;
      }
      var newSelection;
      if (key == "up") {
        newSelection = this.getPrevSibling(this._currentSelection);
      } else if (key == "down") {
        newSelection = this.getNextSibling(this._currentSelection);
      } else if (key == "left" && this.align == "right" || key == "right" && this.align == "left") {
        var menu = this.getSubMenu(this._currentSelection);
        if (menu != null) {
          newSelection = menu[0];
        }
      } else if (key == "right" && this.align == "right" || key == "left" && this.align == "left") {
        newSelection = this.getParentItem(this._currentSelection);
      }
      if (newSelection && newSelection !== this._currentSelection) {
        this.selectBranch(newSelection);
        this.setFocus(newSelection);
        this._currentSelection = newSelection;
      }
    };
    ExportMenu2.prototype.getSiblings = function(branch) {
      var parent = this.getParentItem(branch);
      if (parent && parent.menu) {
        return parent.menu;
      } else {
        return [];
      }
    };
    ExportMenu2.prototype.getParentItem = function(branch) {
      if (branch.ascendants && branch.ascendants.length) {
        return branch.ascendants.getIndex(branch.ascendants.length - 1);
      } else {
        return void 0;
      }
    };
    ExportMenu2.prototype.getNextSibling = function(branch) {
      var siblings = this.getSiblings(branch);
      if (siblings.length > 1) {
        var next = siblings.indexOf(branch) + 1;
        next = siblings.length == next ? 0 : next;
        return siblings[next].unsupported ? this.getNextSibling(siblings[next]) : siblings[next];
      } else {
        return branch;
      }
    };
    ExportMenu2.prototype.getPrevSibling = function(branch) {
      var siblings = this.getSiblings(branch);
      if (siblings.length > 1) {
        var prev = siblings.indexOf(branch) - 1;
        prev = prev == -1 ? siblings.length - 1 : prev;
        return siblings[prev].unsupported ? this.getPrevSibling(siblings[prev]) : siblings[prev];
      } else {
        return branch;
      }
    };
    ExportMenu2.prototype.setFocus = function(branch) {
      if (branch.interactions) {
        try {
          branch.interactions.element.focus();
        } catch (e) {
        }
      }
    };
    ExportMenu2.prototype.setBlur = function(branch) {
      if (branch.interactions) {
        try {
          branch.interactions.element.blur();
        } catch (e) {
        }
      }
    };
    ExportMenu2.prototype.hideBranch = function(branch) {
      branch.element.style.display = "none";
    };
    ExportMenu2.prototype.showBranch = function(branch) {
      branch.element.style.display = "";
    };
    Object.defineProperty(ExportMenu2.prototype, "element", {
      /**
       * The main element o fthe menu - usually `<ul>`.
       *
       * @since 4.10.6
       * @return Menu element
       */
      get: function() {
        return this._element;
      },
      enumerable: true,
      configurable: true
    });
    return ExportMenu2;
  }(Validatable)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Net.js
var Net_exports = {};
__export(Net_exports, {
  load: () => load,
  readBlob: () => readBlob
});
function load(url, target, options2) {
  return new Promise(function(success, error) {
    var isBlob = hasValue(options2) && options2.responseType == "blob";
    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
      if (xhr.status === 200) {
        var response = void 0;
        var blob_1;
        if (isBlob) {
          blob_1 = xhr.response;
          readBlob(blob_1).then(function(response2) {
            var output2 = {
              xhr,
              error: false,
              response: response2,
              blob: blob_1,
              type: xhr.getResponseHeader("Content-Type"),
              target
            };
            success(output2);
          });
          return;
        } else {
          response = xhr.responseText || xhr.response;
        }
        var output = {
          xhr,
          error: false,
          response,
          blob: blob_1,
          type: xhr.getResponseHeader("Content-Type"),
          target
        };
        success(output);
      } else {
        error({
          xhr,
          error: true,
          type: xhr.getResponseHeader("Content-Type"),
          target
        });
      }
    };
    xhr.onerror = function() {
      error({
        xhr,
        error: true,
        type: xhr.getResponseHeader("Content-Type"),
        target
      });
    };
    xhr.open("GET", url, true);
    if (options2 && options2.withCredentials) {
      xhr.withCredentials = true;
    }
    if (hasValue(options2)) {
      if (hasValue(options2.requestHeaders)) {
        for (var i = 0; i < options2.requestHeaders.length; i++) {
          var header = options2.requestHeaders[i];
          xhr.setRequestHeader(header.key, header.value);
        }
      }
      if (hasValue(options2.responseType)) {
        xhr.responseType = options2.responseType;
      }
    }
    xhr.send();
  });
}
function readBlob(blob) {
  return new Promise(function(success, error) {
    var reader = new FileReader();
    reader.onload = function(event) {
      success(reader.result);
    };
    reader.onerror = function(e) {
      error(e);
    };
    reader.readAsText(blob);
  });
}

// node_modules/@amcharts/amcharts4/.internal/core/export/Export.js
var pdfmakePromise;
function _pdfmake() {
  return __awaiter(this, void 0, void 0, function() {
    var a, pdfmake, vfs_fonts, global;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, Promise.all([
            import(
              /* webpackChunkName: "pdfmake" */
              "./pdfmake-N3VMU6M7.js"
            ),
            import(
              /* webpackChunkName: "pdfmake" */
              "./vfs_fonts-W7WQTPF3.js"
            )
          ])];
        case 1:
          a = _a.sent();
          pdfmake = a[0].default || a[0];
          vfs_fonts = a[1].default || a[1];
          global = window;
          global.pdfMake = global.pdfMake || {};
          global.pdfMake.vfs = vfs_fonts;
          pdfmake.vfs = vfs_fonts;
          return [2, pdfmake];
      }
    });
  });
}
var fontFamilySrcRegexp = /src: ([^;]+);/;
function supportsBlobUri() {
  return window.navigator.msSaveOrOpenBlob != null;
}
function blobToDataUri(blob) {
  return new Promise(function(resolve, reject) {
    var f = new FileReader();
    f.onload = function(e) {
      resolve(f.result);
    };
    f.onerror = function(e) {
      reject(e);
    };
    f.readAsDataURL(blob);
  });
}
function getCssRules(s2) {
  return __awaiter(this, void 0, void 0, function() {
    var sheet, e_1;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          sheet = s2.sheet;
          _a.label = 1;
        case 1:
          _a.trys.push([1, 2, , 4]);
          return [2, sheet.cssRules];
        case 2:
          e_1 = _a.sent();
          return [4, new Promise(function(success, error) {
            s2.addEventListener("load", function() {
              success(sheet.cssRules);
            }, true);
            s2.addEventListener("error", function(e) {
              error(e);
            }, true);
            setTimeout(function() {
              error(new Error("Timeout while waiting for <style> to load"));
            }, 1e4);
          })];
        case 3:
          return [2, _a.sent()];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function loadStylesheet(doc, url, f) {
  return __awaiter(this, void 0, void 0, function() {
    var response, e_2, s2, rules3;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          _a.trys.push([0, 2, , 3]);
          return [4, load(url)];
        case 1:
          response = _a.sent();
          return [3, 3];
        case 2:
          e_2 = _a.sent();
          console.error("Failed to load stylesheet", url, e_2);
          return [
            2
            /*return*/
          ];
        case 3:
          s2 = doc.createElement("style");
          s2.textContent = response.response;
          if (options.nonce != "") {
            s2.setAttribute("nonce", options.nonce);
          }
          doc.head.appendChild(s2);
          _a.label = 4;
        case 4:
          _a.trys.push([4, , 7, 8]);
          return [4, getCssRules(s2)];
        case 5:
          rules3 = _a.sent();
          return [4, eachStylesheet(doc, url, rules3, f)];
        case 6:
          _a.sent();
          return [3, 8];
        case 7:
          doc.head.removeChild(s2);
          return [
            7
            /*endfinally*/
          ];
        case 8:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function eachStylesheet(doc, topUrl, rules3, f) {
  return __awaiter(this, void 0, void 0, function() {
    var promises, length, i, rule, url;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          promises = [];
          length = rules3.length;
          for (i = 0; i < length; i++) {
            rule = rules3[i];
            if (rule.type === CSSRule.IMPORT_RULE) {
              url = rule.href;
              if (url) {
                url = joinUrl(topUrl, url);
                promises.push(loadStylesheet(doc, url, f));
              }
            } else {
              f(topUrl, rule);
            }
          }
          if (!promises.length)
            return [3, 2];
          return [4, Promise.all(promises)];
        case 1:
          _a.sent();
          _a.label = 2;
        case 2:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function eachStylesheets(f) {
  return __awaiter(this, void 0, void 0, function() {
    var iframe, doc_1;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          iframe = document.createElement("iframe");
          iframe.src = "about:blank";
          iframe.setAttribute("title", "");
          document.head.appendChild(iframe);
          _a.label = 1;
        case 1:
          _a.trys.push([1, , 3, 4]);
          doc_1 = iframe.contentDocument;
          return [4, Promise.all(map(document.styleSheets, function(sheet) {
            var url = sheet.href;
            if (url == null) {
              return eachStylesheet(doc_1, location.href, sheet.cssRules, f);
            } else {
              url = joinUrl(location.href, url);
              return loadStylesheet(doc_1, url, f);
            }
          }))];
        case 2:
          _a.sent();
          return [3, 4];
        case 3:
          document.head.removeChild(iframe);
          return [
            7
            /*endfinally*/
          ];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
var Export = (
  /** @class */
  function(_super) {
    __extends(Export2, _super);
    function Export2(container) {
      var _this = _super.call(this) || this;
      _this.adapter = new Adapter(_this);
      _this._formatOptions = new Dictionary();
      _this._extraSprites = [];
      _this._validateSprites = [];
      _this.dataFieldsOrder = [];
      _this._dynamicDataFields = true;
      _this._removedObjects = new List();
      _this._hiddenObjects = [];
      _this._objectsAlreadyHidden = false;
      _this._filePrefix = "amCharts";
      _this.useWebFonts = true;
      _this.useRetina = true;
      _this.useSimplifiedExport = true;
      _this.timeoutDelay = 2e3;
      _this._exportRunning = false;
      _this._prevHasData = false;
      _this._container = container;
      _this.className = "Export";
      _this._formatOptions.setKey("png", {});
      _this._formatOptions.setKey("jpg", {
        quality: 0.8
      });
      _this._formatOptions.setKey("gif", {});
      _this._formatOptions.setKey("svg", {});
      _this._formatOptions.setKey("pdf", {
        fontSize: 14,
        imageFormat: "png",
        align: "left",
        addURL: true,
        addColumnNames: true
      });
      _this._formatOptions.setKey("json", {
        indent: 2,
        useLocale: true
      });
      _this._formatOptions.setKey("csv", {
        addColumnNames: true,
        emptyAs: "",
        addBOM: true
      });
      _this._formatOptions.setKey("xlsx", {
        addColumnNames: true,
        useLocale: true,
        emptyAs: ""
      });
      _this._formatOptions.setKey("html", {
        addColumnNames: true,
        emptyAs: ""
      });
      _this._formatOptions.setKey("pdfdata", {
        fontSize: 14,
        imageFormat: "png",
        addURL: true,
        addColumnNames: true,
        emptyAs: ""
      });
      _this._formatOptions.setKey("print", {
        delay: 500,
        printMethod: "iframe"
      });
      _this.adapter.add("options", function(arg) {
        var formatOptions = _this._formatOptions.getKey(arg.type);
        if (arg.options) {
          arg.options = merge(formatOptions, arg.options);
        } else {
          arg.options = formatOptions;
        }
        return arg;
      });
      _this.applyTheme();
      _this.dispatchImmediately("inited");
      return _this;
    }
    Object.defineProperty(Export2.prototype, "menu", {
      /**
       * @return ExportMenu instance
       */
      get: function() {
        return this._menu;
      },
      /**
       * An instance of [[ExportMenu]].
       *
       * To add an export menu to a chart, set this to a new instance of
       * [[ExportMenu]].
       *
       * ```TypeScript
       * chart.exporting.menu = new am4core.ExportMenu();
       * ```
       * ```JavaScript
       * chart.exporting.menu = new am4core.ExportMenu();
       * ```
       * ```JSON
       * {
       *   // ...
       *   "exporting": {
       *     "menu": {}
       *   }
       * }
       * ```
       *
       * @param menu  ExportMenu instance
       */
      set: function(menu) {
        var _this = this;
        if (this._menu) {
          this.removeDispose(this._menu);
        }
        this._menu = menu;
        this._menu.container = this.container;
        this._menu.language = this._language;
        this._menu.adapter.add("branch", function(arg) {
          arg.branch.unsupported = !_this.typeSupported(arg.branch.type);
          return arg;
        });
        this._menu.events.on("hit", function(ev) {
          _this.export(ev.branch.type, ev.branch.options);
          _this.menu.close();
        });
        this._menu.events.on("enter", function(ev) {
          _this.export(ev.branch.type, ev.branch.options);
          _this.menu.close();
        });
        this._menu.events.on("over", function(ev) {
          _this._disablePointers();
        });
        this._menu.events.on("out", function(ev) {
          setTimeout(function() {
            _this._releasePointers();
          }, 10);
        });
        this.dispatchImmediately("menucreated");
        this._menu.adapter.add("classPrefix", function(obj) {
          obj.classPrefix = options.classNamePrefix + obj.classPrefix;
          return obj;
        });
        this._disposers.push(this._menu);
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.typeSupported = function(type) {
      var supported = true;
      var options2 = this.getFormatOptions(type);
      if (hasValue(options2) && options2.disabled) {
        supported = false;
      } else if (type === "pdf") {
      } else if (type === "xlsx") {
        supported = this._hasData() ? true : false;
      } else if (type == "print" && !window.print) {
        supported = false;
      } else if (["json", "csv", "html", "pdfdata"].indexOf(type) !== -1 && !this._hasData()) {
        supported = false;
      }
      return this.adapter.apply("supported", {
        supported,
        type
      }).supported;
    };
    Export2.prototype._hasData = function() {
      return this.data && this.data.length;
    };
    Export2.prototype._getFunction = function(type) {
      switch (type) {
        case "png":
        case "gif":
        case "jpg":
          return this.getImage;
        case "svg":
          return this.getSVG;
        case "pdf":
        case "pdfdata":
          return this.getPDF;
        case "xlsx":
          return this.getExcel;
        case "csv":
          return this.getCSV;
        case "json":
          return this.getJSON;
        case "html":
          return this.getHTML;
        case "print":
          return this.getPrint;
        default:
          return this.unsupported;
      }
    };
    Export2.prototype.export = function(type, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var event_1, func, data, event_2, event_3;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (type == "custom") {
                this.handleCustom(options2);
                return [2, true];
              }
              this._exportRunning = true;
              if (this.events.isEnabled("exportstarted")) {
                event_1 = {
                  "type": "exportstarted",
                  "target": this,
                  "format": type,
                  "options": options2
                };
                this.events.dispatchImmediately("exportstarted", event_1);
              }
              this.showPreloader();
              if (this.timeoutDelay) {
                this.hideTimeout();
                this._timeoutTimeout = this.setTimeout(function() {
                  if (_this.events.isEnabled("exporttimedout")) {
                    var event_4 = {
                      "type": "exporttimedout",
                      "target": _this,
                      "format": type,
                      "options": options2
                    };
                    _this.events.dispatchImmediately("exporttimedout", event_4);
                  }
                  _this.showTimeout();
                }, this.timeoutDelay);
              }
              this.hideNonExportableSprites();
              func = this._getFunction(type);
              options2 = this.adapter.apply("options", {
                options: options2,
                type
              }).options;
              func = this.adapter.apply("exportFunction", {
                func,
                type,
                options: options2
              }).func;
              return [4, func.call(this, type, options2)];
            case 1:
              data = _a.sent();
              this._exportRunning = false;
              this._releasePointers();
              this.restoreNonExportableSprites();
              if (data) {
                if (this.events.isEnabled("exportfinished")) {
                  event_2 = {
                    "type": "exportfinished",
                    "target": this,
                    "format": type,
                    "options": options2
                  };
                  this.events.dispatchImmediately("exportfinished", event_2);
                }
                this.hidePreloader();
                this.hideTimeout();
                if (this.menu) {
                  this.menu.close();
                }
                if (type === "print") {
                  return [2, this.print(data, options2, this.adapter.apply("title", {
                    title: this.title,
                    options: options2
                  }).title)];
                } else {
                  if (type == "pdfdata") {
                    return [2, this.download(data, this.filePrefix + ".pdf")];
                  }
                  return [2, this.download(data, this.filePrefix + "." + type, options2 && options2.addBOM)];
                }
              } else {
                if (this.events.isEnabled("error")) {
                  event_3 = {
                    "type": "error",
                    "target": this,
                    "format": type,
                    "options": options2
                  };
                  this.events.dispatchImmediately("error", event_3);
                }
                return [2, false];
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.unsupported = function(type, options2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, ""];
        });
      });
    };
    Export2.prototype.handleCustom = function(options2) {
      if (hasValue(options2) && hasValue(options2.callback)) {
        options2.callback.call(options2.callbackTarget || this, options2);
      }
    };
    Export2.prototype.getPrint = function(type, options2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, this.getImage("png", options2)];
        });
      });
    };
    Export2.prototype.getFontFamilies = function() {
      return __awaiter(this, void 0, void 0, function() {
        var DOMURL, blobs, promises, a;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              DOMURL = this.getDOMURL();
              blobs = [];
              promises = [];
              return [4, eachStylesheets(function(topUrl, rule) {
                if (rule.type === CSSRule.FONT_FACE_RULE) {
                  var cssText_1 = rule.cssText;
                  var src = fontFamilySrcRegexp.exec(cssText_1);
                  if (src !== null) {
                    var urls = src[1].split(/ *, */).map(function(url) {
                      return __awaiter(_this, void 0, void 0, function() {
                        var a2, after, fullUrl, response, url_1, e_3;
                        return __generator(this, function(_a2) {
                          switch (_a2.label) {
                            case 0:
                              a2 = /^url\(["']?([^"'\)]+)["']?\)([^,]*)$/.exec(url);
                              if (!(a2 === null))
                                return [3, 1];
                              return [2, url];
                            case 1:
                              after = a2[2];
                              fullUrl = joinUrl(topUrl, a2[1]);
                              if (this.webFontFilter && !fullUrl.match(this.webFontFilter)) {
                                return [2, null];
                              }
                              _a2.label = 2;
                            case 2:
                              _a2.trys.push([2, 7, , 8]);
                              return [4, load(fullUrl, void 0, { responseType: "blob" })];
                            case 3:
                              response = _a2.sent();
                              if (!supportsBlobUri())
                                return [3, 4];
                              url_1 = DOMURL.createObjectURL(response.blob);
                              blobs.push(url_1);
                              return [3, 6];
                            case 4:
                              return [4, blobToDataUri(response.blob)];
                            case 5:
                              url_1 = _a2.sent();
                              _a2.label = 6;
                            case 6:
                              return [2, 'url("' + url_1 + '")' + after];
                            case 7:
                              e_3 = _a2.sent();
                              console.error("Failed to load font", fullUrl, e_3);
                              return [2, null];
                            case 8:
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    });
                    promises.push(Promise.all(urls).then(function(a2) {
                      a2 = a2.filter(function(x) {
                        return x != null;
                      });
                      if (a2.length === 0) {
                        return "";
                      } else {
                        return cssText_1.replace(fontFamilySrcRegexp, "src: " + a2.join(", ") + ";");
                      }
                    }));
                  }
                }
              })];
            case 1:
              _a.sent();
              return [4, Promise.all(promises)];
            case 2:
              a = _a.sent();
              return [2, {
                blobs,
                cssText: a.filter(function(x) {
                  return !!x;
                }).join("\n")
              }];
          }
        });
      });
    };
    Export2.prototype.getImage = function(type, options2, includeExtras) {
      return __awaiter(this, void 0, void 0, function() {
        var prehidden, canvas, newCanvas, uri, e_4, data, data;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              prehidden = this._objectsAlreadyHidden;
              if (!prehidden) {
                this.hideNonExportableSprites();
              }
              if (!hasValue(options2)) {
                options2 = this.getFormatOptions(type);
              }
              return [4, this.awaitValidSprites()];
            case 1:
              _a.sent();
              return [4, this.simplifiedImageExport()];
            case 2:
              if (!_a.sent())
                return [3, 10];
              canvas = void 0;
              _a.label = 3;
            case 3:
              _a.trys.push([3, 7, , 9]);
              return [4, this.getCanvas(options2)];
            case 4:
              canvas = _a.sent();
              if (!(includeExtras !== false))
                return [3, 6];
              return [4, this.addExtras(canvas, options2)];
            case 5:
              newCanvas = _a.sent();
              this.disposeCanvas(canvas);
              canvas = newCanvas;
              _a.label = 6;
            case 6:
              uri = canvas.toDataURL(this.getContentType(type), options2.quality);
              this.disposeCanvas(canvas);
              if (!prehidden) {
                this.restoreNonExportableSprites();
              }
              return [2, uri];
            case 7:
              e_4 = _a.sent();
              console.error(e_4.message + "\n" + e_4.stack);
              warn("Simple export failed, falling back to advanced export");
              if (canvas) {
                this.disposeCanvas(canvas);
              }
              return [4, this.getImageAdvanced(type, options2, includeExtras)];
            case 8:
              data = _a.sent();
              if (!prehidden) {
                this.restoreNonExportableSprites();
              }
              return [2, data];
            case 9:
              return [3, 12];
            case 10:
              return [4, this.getImageAdvanced(type, options2, includeExtras)];
            case 11:
              data = _a.sent();
              if (!prehidden) {
                this.restoreNonExportableSprites();
              }
              return [2, data];
            case 12:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.addExtras = function(canvas, options2, advanced) {
      return __awaiter(this, void 0, void 0, function() {
        var middleLeft_1, middleTop_1, middleWidth_1, middleHeight_1, extraRight_1, extraBottom_1, extras, newCanvas, ctx_1, background, left_1, top_1, right_1, bottom_1;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!this.extraSprites.length)
                return [3, 2];
              middleLeft_1 = 0;
              middleTop_1 = 0;
              middleWidth_1 = canvas.width;
              middleHeight_1 = canvas.height;
              extraRight_1 = 0;
              extraBottom_1 = 0;
              return [4, Promise.all(map(this.extraSprites, function(extraSprite) {
                return __awaiter(_this, void 0, void 0, function() {
                  var extra, extraCanvas, extraWidth, extraHeight;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        if (extraSprite instanceof Sprite) {
                          extra = {
                            sprite: extraSprite,
                            position: "bottom"
                          };
                        } else {
                          extra = extraSprite;
                        }
                        extra.position = extra.position || "bottom";
                        extra.marginTop = extra.marginTop || 0;
                        extra.marginRight = extra.marginRight || 0;
                        extra.marginBottom = extra.marginBottom || 0;
                        extra.marginLeft = extra.marginLeft || 0;
                        if (!advanced)
                          return [3, 2];
                        return [4, extra.sprite.exporting.getCanvasAdvanced(options2)];
                      case 1:
                        extraCanvas = _a2.sent();
                        return [3, 4];
                      case 2:
                        return [4, extra.sprite.exporting.getCanvas(options2)];
                      case 3:
                        extraCanvas = _a2.sent();
                        _a2.label = 4;
                      case 4:
                        extraWidth = extraCanvas.width + extra.marginLeft + extra.marginRight;
                        extraHeight = extraCanvas.height + extra.marginTop + extra.marginBottom;
                        if (extra.position == "top") {
                          middleWidth_1 = extra.crop ? middleHeight_1 : max(middleWidth_1, extraWidth);
                          middleTop_1 += extraHeight;
                        } else if (extra.position == "right") {
                          middleHeight_1 = extra.crop ? middleHeight_1 : max(middleHeight_1, extraHeight);
                          extraRight_1 += extraWidth;
                        } else if (extra.position == "left") {
                          middleHeight_1 = extra.crop ? middleHeight_1 : max(middleHeight_1, extraHeight);
                          middleLeft_1 += extraWidth;
                        } else if (extra.position === "bottom") {
                          middleWidth_1 = extra.crop ? middleHeight_1 : max(middleWidth_1, extraWidth);
                          extraBottom_1 += extraHeight;
                        }
                        return [2, {
                          canvas: extraCanvas,
                          position: extra.position,
                          left: extra.marginLeft,
                          top: extra.marginTop,
                          width: extraWidth,
                          height: extraHeight
                        }];
                    }
                  });
                });
              }))];
            case 1:
              extras = _a.sent();
              newCanvas = this.getDisposableCanvas();
              newCanvas.width = middleLeft_1 + middleWidth_1 + extraRight_1;
              newCanvas.height = middleTop_1 + middleHeight_1 + extraBottom_1;
              ctx_1 = newCanvas.getContext("2d");
              background = this.backgroundColor || this.findBackgroundColor(this.sprite.dom);
              if (background) {
                ctx_1.fillStyle = background.toString();
                ctx_1.fillRect(0, 0, newCanvas.width, newCanvas.height);
              }
              left_1 = middleLeft_1;
              top_1 = middleTop_1;
              right_1 = left_1 + middleWidth_1;
              bottom_1 = top_1 + middleHeight_1;
              each(extras, function(extra) {
                if (extra.position == "top") {
                  top_1 -= extra.height;
                  ctx_1.drawImage(extra.canvas, middleLeft_1 + extra.left, top_1 + extra.top);
                } else if (extra.position == "right") {
                  ctx_1.drawImage(extra.canvas, right_1 + extra.left, middleTop_1 + extra.top);
                  right_1 += extra.width;
                } else if (extra.position == "left") {
                  left_1 -= extra.width;
                  ctx_1.drawImage(extra.canvas, left_1 + extra.left, middleTop_1 + extra.top);
                } else if (extra.position === "bottom") {
                  ctx_1.drawImage(extra.canvas, middleLeft_1 + extra.left, bottom_1 + extra.top);
                  bottom_1 += extra.height;
                }
                _this.disposeCanvas(extra.canvas);
              });
              ctx_1.drawImage(canvas, middleLeft_1, middleTop_1);
              return [2, newCanvas];
            case 2:
              return [2, canvas];
          }
        });
      });
    };
    Export2.prototype.getCanvas = function(options2) {
      return __awaiter(this, void 0, void 0, function() {
        var background, DOMURL, url, blobs, canvas, width2, height2, font, fontSize, scale, pixelRatio, ctx, promises, a, data, svg, img;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!hasValue(options2)) {
                options2 = {};
              }
              background = this.backgroundColor || this.findBackgroundColor(this.sprite.dom);
              DOMURL = this.getDOMURL();
              url = null;
              blobs = null;
              _a.label = 1;
            case 1:
              _a.trys.push([1, , 4, 5]);
              width2 = this.sprite.pixelWidth;
              height2 = this.sprite.pixelHeight;
              font = findFont(this.sprite.dom);
              fontSize = findFontSize(this.sprite.dom);
              scale = options2.scale || 1;
              pixelRatio = this.getPixelRatio(options2);
              scale = this.getAdjustedScale(width2 * pixelRatio, height2 * pixelRatio, scale, options2);
              canvas = this.getDisposableCanvas();
              canvas.style.width = width2 * scale + "px";
              canvas.style.height = height2 * scale + "px";
              canvas.width = width2 * scale;
              canvas.height = height2 * scale;
              ctx = canvas.getContext("2d");
              if (background) {
                ctx.fillStyle = background.toString();
                ctx.fillRect(0, 0, width2 * scale, height2 * scale);
              }
              promises = [];
              if (this.useWebFonts) {
                promises.push(this.getFontFamilies().then(function(fonts) {
                  blobs = fonts.blobs;
                  return fonts.cssText;
                }));
              }
              promises.push(this.imagesToDataURI(this.sprite.dom, options2));
              promises.push(this.prepForeignObjects(this.sprite.dom, options2));
              return [4, Promise.all(promises)];
            case 2:
              a = _a.sent();
              data = this.normalizeSVG("<style>" + a[0] + "</style>" + this.serializeElement(this.sprite.paper.defs) + this.serializeElement(this.sprite.dom), options2, width2, height2, scale, font, fontSize);
              svg = new Blob([data], { type: "image/svg+xml" });
              url = DOMURL.createObjectURL(svg);
              return [4, this.loadNewImage(url, width2 * scale * pixelRatio, height2 * scale * pixelRatio, "anonymous")];
            case 3:
              img = _a.sent();
              ctx.drawImage(img, 0, 0);
              return [3, 5];
            case 4:
              if (url !== null) {
                DOMURL.revokeObjectURL(url);
              }
              if (blobs !== null) {
                each(blobs, function(url2) {
                  DOMURL.revokeObjectURL(url2);
                });
              }
              this.restoreRemovedObjects();
              return [
                7
                /*endfinally*/
              ];
            case 5:
              return [2, canvas];
          }
        });
      });
    };
    Export2.prototype.getCanvasAdvanced = function(options2) {
      return __awaiter(this, void 0, void 0, function() {
        var background, canvg, width2, height2, font, fontSize, scale, pixelRatio, data, canvas, config;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!hasValue(options2)) {
                options2 = {};
              }
              return [4, this.imagesToDataURI(this.sprite.dom, options2)];
            case 1:
              _a.sent();
              background = this.backgroundColor || this.findBackgroundColor(this.sprite.dom);
              return [4, this.canvg];
            case 2:
              canvg = _a.sent();
              width2 = this.sprite.pixelWidth;
              height2 = this.sprite.pixelHeight;
              font = findFont(this.sprite.dom);
              fontSize = findFontSize(this.sprite.dom);
              scale = options2.scale || 1;
              pixelRatio = this.getPixelRatio(options2);
              scale = this.getAdjustedScale(width2 * pixelRatio, height2 * pixelRatio, scale, options2);
              data = this.normalizeSVG(this.serializeElement(this.sprite.paper.defs) + this.serializeElement(this.sprite.dom), options2, width2, height2, scale, font, fontSize, background);
              canvas = this.getDisposableCanvas();
              canvas.style.width = width2 * pixelRatio * scale + "px";
              canvas.style.height = height2 * pixelRatio * scale + "px";
              canvas.width = width2 * pixelRatio * scale;
              canvas.height = height2 * pixelRatio * scale;
              config = {
                //ignoreDimensions: true,
                useCORS: true
              };
              if (pixelRatio != 1) {
                config.ignoreDimensions = true;
                config.scaleWidth = width2 * pixelRatio * scale;
                config.scaleHeight = height2 * pixelRatio * scale;
              }
              return [4, canvg.fromString(canvas.getContext("2d"), data, config).render()];
            case 3:
              _a.sent();
              return [2, canvas];
          }
        });
      });
    };
    Export2.prototype.getImageAdvanced = function(type, options2, includeExtras) {
      return __awaiter(this, void 0, void 0, function() {
        var prehidden, canvas, uri;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              prehidden = this._objectsAlreadyHidden;
              if (!prehidden) {
                this.hideNonExportableSprites();
              }
              if (!hasValue(options2)) {
                options2 = this.getFormatOptions(type);
              }
              return [4, this.getCanvasAdvanced(options2)];
            case 1:
              canvas = _a.sent();
              if (!(includeExtras !== false))
                return [3, 3];
              return [4, this.addExtras(canvas, options2, true)];
            case 2:
              canvas = _a.sent();
              _a.label = 3;
            case 3:
              uri = canvas.toDataURL(this.getContentType(type), options2.quality);
              this.disposeCanvas(canvas);
              if (!prehidden) {
                this.restoreNonExportableSprites();
              }
              return [2, uri];
          }
        });
      });
    };
    Export2.prototype.getDisposableCanvas = function() {
      var canvas = document.createElement("canvas");
      canvas.style.position = "fixed";
      canvas.style.top = "-10000px";
      document.body.appendChild(canvas);
      return canvas;
    };
    Export2.prototype.disposeCanvas = function(canvas) {
      if (document.body.contains(canvas)) {
        document.body.removeChild(canvas);
      }
    };
    Export2.prototype.getPixelRatio = function(options2) {
      return this.useRetina ? getPixelRatio() : 1;
    };
    Export2.prototype.getAdjustedScale = function(width2, height2, scale, options2) {
      if (!options2) {
        return scale;
      }
      var adjWidth = width2 * scale;
      var adjHeight = width2 * scale;
      var widthScale;
      var heightScale;
      if (options2.maxWidth && adjWidth > options2.maxWidth) {
        widthScale = options2.maxWidth / width2;
      }
      if (options2.maxHeight && adjHeight > options2.maxHeight) {
        heightScale = options2.maxHeight / height2;
      }
      if (widthScale || heightScale) {
        return min(widthScale, heightScale);
      }
      if (options2.minWidth && adjWidth < options2.minWidth) {
        widthScale = options2.minWidth / width2;
      }
      if (options2.minHeight && adjHeight < options2.minHeight) {
        heightScale = options2.minHeight / height2;
      }
      if (widthScale || heightScale) {
        return max(widthScale, heightScale);
      }
      return scale;
    };
    Export2.prototype.imagesToDataURI = function(el, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var images, promises, count, i, image, href;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              images = el.querySelectorAll("image");
              if (!images.length)
                return [3, 2];
              promises = [];
              for (count = images.length, i = 0; i < count; i++) {
                image = images[i];
                href = image.getAttributeNS(Export2.XLINK, "href");
                if (!href) {
                  continue;
                }
                if (href.indexOf("data:image") !== -1) {
                } else {
                  if (href.indexOf(".svg") !== -1) {
                    promises.push(this.svgToDataURI(image, options2));
                  } else {
                    promises.push(this.imageToDataURI(image, options2));
                  }
                }
              }
              return [4, Promise.all(promises)];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.prepForeignObjects = function(el, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var objects, count, i;
        return __generator(this, function(_a) {
          objects = el.querySelectorAll("foreignObject");
          if (objects.length) {
            for (count = objects.length, i = 0; i < count; i++) {
              this.temporarilyRemoveObject(objects[i]);
            }
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    Export2.prototype.imageToDataURI = function(el, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var img, canvas, uri, e_5;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 3]);
              return [4, this.loadNewImage(el.getAttributeNS(Export2.XLINK, "href"), null, null, "anonymous")];
            case 1:
              img = _a.sent();
              canvas = document.createElement("canvas");
              canvas.width = img.width;
              canvas.height = img.height;
              canvas.getContext("2d").drawImage(img, 0, 0);
              try {
                uri = canvas.toDataURL();
                el.setAttribute("href", uri);
                return [2, uri];
              } catch (e) {
                if (options2.keepTainted !== false) {
                  this.temporarilyRemoveObject(el);
                }
                return [2, void 0];
              }
              return [3, 3];
            case 2:
              e_5 = _a.sent();
              if (!options2 || options2.keepTainted !== false) {
                this.temporarilyRemoveObject(el);
              }
              return [2, void 0];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.svgToDataURI = function(el, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var href, data, charset, uri, e_6;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              href = el.getAttributeNS(Export2.XLINK, "href");
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, , 4]);
              return [4, load(href)];
            case 2:
              data = _a.sent();
              charset = this.adapter.apply("charset", {
                charset: "base64",
                type: "svg",
                options: options2
              }).charset;
              uri = this.adapter.apply("svgToDataURI", {
                data: "data:" + this.getContentType("svg") + ";" + charset + "," + btoa(data.response),
                options: options2
              }).data;
              el.setAttributeNS(Export2.XLINK, "href", uri);
              return [2, uri];
            case 3:
              e_6 = _a.sent();
              if (!options2 || options2.keepTainted !== false) {
                this.temporarilyRemoveObject(el);
              }
              return [2, void 0];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.temporarilyRemoveObject = function(el, placeholder) {
      var parent = el.parentElement || el.parentNode;
      if (!placeholder) {
        placeholder = this.sprite.paper.add("g").node;
      }
      parent.insertBefore(placeholder, el);
      if (el.textContent) {
      }
      parent.removeChild(el);
      this._removedObjects.push({
        "element": el,
        "placeholder": placeholder
      });
    };
    Export2.prototype.restoreRemovedObjects = function() {
      var obj;
      while (true) {
        obj = this._removedObjects.pop();
        if (!obj) {
          break;
        }
        var parent_1 = obj.placeholder.parentElement || obj.placeholder.parentNode;
        parent_1.insertBefore(obj.element, obj.placeholder);
      }
    };
    Export2.prototype.simplifiedImageExport = function() {
      return __awaiter(this, void 0, void 0, function() {
        var cache2, canvas, ctx, DOMURL, svg, url, img, e_7, e_8;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (this.useSimplifiedExport === false) {
                return [2, false];
              }
              cache2 = registry.getCache("simplifiedImageExport");
              if (cache2 === false || cache2 === true) {
                return [2, cache2];
              }
              _a.label = 1;
            case 1:
              _a.trys.push([1, 6, , 7]);
              canvas = document.createElement("canvas");
              canvas.width = 1;
              canvas.height = 1;
              ctx = canvas.getContext("2d");
              DOMURL = this.getDOMURL();
              svg = new Blob([this.normalizeSVG("<g></g>", {}, 1, 1)], { type: "image/svg+xml" });
              url = DOMURL.createObjectURL(svg);
              img = void 0;
              _a.label = 2;
            case 2:
              _a.trys.push([2, 4, , 5]);
              return [4, this.loadNewImage(url, 1, 1)];
            case 3:
              img = _a.sent();
              return [3, 5];
            case 4:
              e_7 = _a.sent();
              return [2, false];
            case 5:
              ctx.drawImage(img, 0, 0);
              DOMURL.revokeObjectURL(url);
              try {
                registry.setCache("simplifiedImageExport", true);
                return [2, true];
              } catch (e) {
                registry.setCache("simplifiedImageExport", false);
                return [2, false];
              }
              return [3, 7];
            case 6:
              e_8 = _a.sent();
              registry.setCache("simplifiedImageExport", false);
              return [2, false];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.loadNewImage = function(url, width2, height2, crossOrigin) {
      return new Promise(function(success, error) {
        var image;
        if (width2 && height2) {
          image = new Image(width2, height2);
        } else {
          image = new Image();
        }
        if (crossOrigin) {
          image.setAttribute("crossOrigin", crossOrigin);
        }
        image.onload = function() {
          success(image);
        };
        function onerror() {
          if (crossOrigin) {
            var currentHref = image.src;
            image.onerror = function() {
              error(new Error('Loading image "' + url + '" failed'));
            };
            image.removeAttribute("crossorigin");
            image.src = "";
            image.src = currentHref;
          } else {
            error(new Error('Loading image "' + url + '" failed'));
          }
        }
        image.onabort = onerror;
        image.onerror = onerror;
        image.src = url;
      });
    };
    Export2.prototype.getDOMURL = function() {
      return self.URL || self.webkitURL || self;
    };
    Export2.prototype.getSVG = function(type, options2, encodeURI) {
      if (encodeURI === void 0) {
        encodeURI = true;
      }
      return __awaiter(this, void 0, void 0, function() {
        var prehidden, width2, height2, font, fontSize, scale, pixelRatio, svg, charset, uri;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              prehidden = this._objectsAlreadyHidden;
              if (!prehidden) {
                this.hideNonExportableSprites();
              }
              if (!hasValue(options2)) {
                options2 = this.getFormatOptions("svg");
              }
              return [4, this.awaitValidSprites()];
            case 1:
              _a.sent();
              width2 = this.sprite.pixelWidth;
              height2 = this.sprite.pixelHeight;
              font = findFont(this.sprite.dom);
              fontSize = findFontSize(this.sprite.dom);
              scale = options2.scale || 1;
              pixelRatio = this.getPixelRatio(options2);
              scale = this.getAdjustedScale(width2 * pixelRatio, height2 * pixelRatio, scale, options2);
              svg = this.normalizeSVG(this.serializeElement(this.sprite.paper.defs) + this.serializeElement(this.sprite.dom), options2, width2, height2, scale, font, fontSize);
              charset = this.adapter.apply("charset", {
                charset: "charset=utf-8",
                type: "svg",
                options: options2
              }).charset;
              uri = this.adapter.apply("getSVG", {
                data: encodeURI ? "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(svg) : svg,
                options: options2
              }).data;
              if (!prehidden) {
                this.restoreNonExportableSprites();
              }
              return [2, uri];
          }
        });
      });
    };
    Export2.prototype.normalizeSVG = function(svg, options2, width2, height2, scale, font, fontSize, background) {
      var dimParams = "";
      if (width2) {
        dimParams += 'width="' + Math.round(width2 * (scale || 1)) + 'px" ';
      }
      if (height2) {
        dimParams += 'height="' + Math.round(height2 * (scale || 1)) + 'px" ';
      }
      var styleParams = "";
      if (font) {
        styleParams += "font-family: " + font.replace(/"/g, "") + ";";
      }
      if (fontSize) {
        styleParams += "font-size: " + fontSize + ";";
      }
      if (scale) {
        dimParams += 'viewBox="0 0 ' + width2 + " " + height2 + '" ';
      }
      var fos = [];
      var ms = svg.match(/<foreignObject[\s\S]*<\/foreignObject>/gi);
      if (ms) {
        for (var i = 0; i < ms.length; i++) {
          svg = svg.replace(ms[i], PLACEHOLDER);
          fos.push(ms[i]);
        }
      }
      if (!svg.match(/<svg/)) {
        svg = '<?xml version="1.0" encoding="utf-8"?><svg ' + dimParams + ' style="' + styleParams + '" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + svg + "</svg>";
      } else {
        if (dimParams !== "") {
          svg = svg.replace(/(<svg[^>]*)width="[^"]*"/, "$1");
          svg = svg.replace(/(<svg[^>]*)height="[^"]*"/, "$1");
          svg = svg.replace(/(<svg)/, "$1" + dimParams);
        }
      }
      if (background) {
        svg = svg.replace(/(<svg[^>]*>)/, '$1<rect width="100%" height="100%" fill="' + background.rgba + '"/>');
      }
      if (isInternetExplorer()) {
        svg = svg.replace(/<feColorMatrix [^\/>]*\/>/gi, "");
      }
      var reg = new RegExp("url\\(" + escapeForRgex(getBaseURI()), "g");
      svg = svg.replace(reg, "url(#");
      svg = svg.replace(/url\(&quot;([^)]*)&quot;\)/gm, "url($1)");
      if (fos.length) {
        for (var i = 0; i < fos.length; i++) {
          svg = svg.replace(PLACEHOLDER, fos[i]);
        }
      }
      svg = this.adapter.apply("normalizeSVG", {
        data: svg,
        options: options2
      }).data;
      return svg;
    };
    Export2.prototype.serializeElement = function(element) {
      return new XMLSerializer().serializeToString(element);
    };
    Export2.prototype.getPDF = function(type, options2) {
      return __awaiter(this, void 0, void 0, function() {
        function addFont(font) {
          var paths = {};
          paths.normal = font.normal.path;
          vfs[font.normal.path] = font.normal.bytes;
          if (font.bold) {
            paths.bold = font.bold.path;
            vfs[font.bold.path] = font.bold.bytes;
          } else {
            paths.bold = font.normal.path;
          }
          if (font.italics) {
            paths.italics = font.italics.path;
            vfs[font.italics.path] = font.italics.bytes;
          } else {
            paths.italics = font.normal.path;
          }
          if (font.bolditalics) {
            paths.bolditalics = font.bolditalics.path;
            vfs[font.bolditalics.path] = font.bolditalics.bytes;
          } else {
            paths.bolditalics = font.normal.path;
          }
          fonts[font.name] = paths;
        }
        var image, pdfmake, defaultMargins, doc, title, extraMargin, _a, _b, _c, fonts, vfs;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.getImage(options2.imageFormat || "png", options2)];
            case 1:
              image = _d.sent();
              return [4, this.pdfmake];
            case 2:
              pdfmake = _d.sent();
              defaultMargins = [30, 30, 30, 30];
              doc = {
                pageSize: options2.pageSize || "A4",
                pageOrientation: options2.pageOrientation || "portrait",
                pageMargins: options2.pageMargins || defaultMargins,
                defaultStyle: {
                  font: options2.font ? options2.font.name : void 0
                },
                //header: <any>[],
                content: []
              };
              title = this.adapter.apply("title", {
                title: this.title,
                options: options2
              }).title;
              extraMargin = 0;
              if (title) {
                doc.content.push({
                  text: title,
                  fontSize: options2.fontSize || 14,
                  bold: true,
                  margin: [0, 0, 0, 15]
                });
                extraMargin += 50;
              }
              if (options2.addURL) {
                doc.content.push({
                  text: this.language.translate("Saved from") + ": " + document.location.href,
                  fontSize: options2.fontSize,
                  margin: [0, 0, 0, 15]
                });
                extraMargin += 50;
              }
              if (type != "pdfdata") {
                doc.content.push({
                  image,
                  alignment: options2.align || "left",
                  fit: this.getPageSizeFit(doc.pageSize, doc.pageMargins, extraMargin)
                });
              }
              if (!(type == "pdfdata" || options2.addData))
                return [3, 4];
              _b = (_a = doc.content).push;
              _c = {};
              return [4, this.getPDFData("pdf", options2)];
            case 3:
              _b.apply(_a, [(_c.table = _d.sent(), _c.fontSize = options2.fontSize || 14, _c)]);
              _d.label = 4;
            case 4:
              doc = this.adapter.apply("pdfmakeDocument", {
                doc,
                options: options2
              }).doc;
              fonts = null;
              vfs = null;
              if (options2.font) {
                fonts = {};
                vfs = {};
                addFont(options2.font);
                if (options2.extraFonts) {
                  each(options2.extraFonts, addFont);
                }
              }
              return [4, new Promise(function(success, error) {
                pdfmake.createPdf(doc, null, fonts, vfs).getDataUrl(function(uri) {
                  success(uri);
                });
              })];
            case 5:
              return [2, _d.sent()];
          }
        });
      });
    };
    Export2.prototype.getPDFData = function(type, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var content, dataFields, data, dataFieldsOrder_1, len, i;
        var _this = this;
        return __generator(this, function(_a) {
          content = {
            "body": []
          };
          dataFields = this.adapter.apply("formatDataFields", {
            dataFields: this.dataFields,
            format: "pdf"
          }).dataFields;
          data = this.data;
          if (options2.pivot) {
            dataFieldsOrder_1 = this.adapter.apply("dataFieldsOrder", {
              dataFieldsOrder: this.dataFieldsOrder,
              format: "pdfdata"
            }).dataFieldsOrder;
            eachOrdered(dataFields, function(key, val) {
              var dataRow = [];
              if (options2.addColumnNames) {
                dataRow.push(val);
              }
              for (var len2 = data.length, i2 = 0; i2 < len2; i2++) {
                var dataValue = data[i2][key];
                dataRow.push(_this.convertToSpecialFormat(key, dataValue, options2, true));
              }
              content.body.push(_this.getPDFDataRow(dataRow, options2, void 0, true));
            }, function(a, b) {
              var ai = dataFieldsOrder_1.indexOf(a);
              var bi = dataFieldsOrder_1.indexOf(b);
              if (ai > bi) {
                return 1;
              } else if (ai < bi) {
                return -1;
              }
              return 0;
            });
          } else {
            if (options2.addColumnNames) {
              content.body.push(this.getPDFDataRow(dataFields, options2, void 0, true));
              content.headerRows = 1;
            }
            for (len = data.length, i = 0; i < len; i++) {
              content.body.push(this.getPDFDataRow(data[i], options2, dataFields));
            }
          }
          return [2, this.adapter.apply("pdfmakeTable", {
            table: content,
            options: options2
          }).table];
        });
      });
    };
    Export2.prototype.getPDFDataRow = function(row, options2, dataFields, asIs) {
      var _this = this;
      if (asIs === void 0) {
        asIs = false;
      }
      var items = [];
      if (!dataFields) {
        dataFields = row;
      }
      var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
        dataFieldsOrder: this.dataFieldsOrder,
        format: "pdfdata"
      }).dataFieldsOrder;
      eachOrdered(dataFields, function(key, name) {
        var value = _this.convertEmptyValue(key, row[key], options2);
        var item = asIs ? value : _this.convertToSpecialFormat(key, value, options2);
        item = "" + item;
        items.push(item);
      }, function(a, b) {
        var ai = dataFieldsOrder.indexOf(a);
        var bi = dataFieldsOrder.indexOf(b);
        if (ai > bi) {
          return 1;
        } else if (ai < bi) {
          return -1;
        }
        return 0;
      });
      return items;
    };
    Export2.prototype.getPageSizeFit = function(pageSize, margins, extraMargin) {
      if (extraMargin === void 0) {
        extraMargin = 0;
      }
      var newMargins = [0, 0, 0, 0];
      if (typeof margins == "number") {
        newMargins = [margins, margins, margins, margins];
      } else if (margins.length == 2) {
        newMargins = [margins[0], margins[1], margins[0], margins[1]];
      } else if (margins.length == 4) {
        newMargins = margins;
      }
      var sizes = {
        "4A0": [4767.87, 6740.79],
        "2A0": [3370.39, 4767.87],
        A0: [2383.94, 3370.39],
        A1: [1683.78, 2383.94],
        A2: [1190.55, 1683.78],
        A3: [841.89, 1190.55],
        A4: [595.28, 841.89],
        A5: [419.53, 595.28],
        A6: [297.64, 419.53],
        A7: [209.76, 297.64],
        A8: [147.4, 209.76],
        A9: [104.88, 147.4],
        A10: [73.7, 104.88],
        B0: [2834.65, 4008.19],
        B1: [2004.09, 2834.65],
        B2: [1417.32, 2004.09],
        B3: [1000.63, 1417.32],
        B4: [708.66, 1000.63],
        B5: [498.9, 708.66],
        B6: [354.33, 498.9],
        B7: [249.45, 354.33],
        B8: [175.75, 249.45],
        B9: [124.72, 175.75],
        B10: [87.87, 124.72],
        C0: [2599.37, 3676.54],
        C1: [1836.85, 2599.37],
        C2: [1298.27, 1836.85],
        C3: [918.43, 1298.27],
        C4: [649.13, 918.43],
        C5: [459.21, 649.13],
        C6: [323.15, 459.21],
        C7: [229.61, 323.15],
        C8: [161.57, 229.61],
        C9: [113.39, 161.57],
        C10: [79.37, 113.39],
        RA0: [2437.8, 3458.27],
        RA1: [1729.13, 2437.8],
        RA2: [1218.9, 1729.13],
        RA3: [864.57, 1218.9],
        RA4: [609.45, 864.57],
        SRA0: [2551.18, 3628.35],
        SRA1: [1814.17, 2551.18],
        SRA2: [1275.59, 1814.17],
        SRA3: [907.09, 1275.59],
        SRA4: [637.8, 907.09],
        EXECUTIVE: [521.86, 756],
        FOLIO: [612, 936],
        LEGAL: [612, 1008],
        LETTER: [612, 792],
        TABLOID: [792, 1224]
      };
      var fitSize = sizes[pageSize];
      fitSize[0] -= newMargins[0] + newMargins[2];
      fitSize[1] -= newMargins[1] + newMargins[3] + extraMargin;
      return fitSize;
    };
    Export2.prototype.getExcel = function(type, options2) {
      return __awaiter(this, void 0, void 0, function() {
        var XLSX, wbOptions, sheetName, wb, data, dataFields, dataFieldsOrder_2, len, i, uri;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!hasValue(options2)) {
                options2 = this.getFormatOptions("xlsx");
              }
              return [4, this.xlsx];
            case 1:
              XLSX = _a.sent();
              wbOptions = this.adapter.apply("xlsxWorkbookOptions", {
                xlsx: XLSX,
                options: {
                  bookType: "xlsx",
                  bookSST: false,
                  type: "base64"
                }
              }).options;
              sheetName = this.normalizeExcelSheetName(this.adapter.apply("xlsxSheetName", {
                xlsx: XLSX,
                name: this.title || this.language.translate("Data")
              }).name);
              wb = {
                SheetNames: [sheetName],
                Sheets: {}
              };
              data = [];
              dataFields = this.adapter.apply("formatDataFields", {
                dataFields: this.dataFields,
                format: "xslx"
              }).dataFields;
              if (options2.pivot) {
                dataFieldsOrder_2 = this.adapter.apply("dataFieldsOrder", {
                  dataFieldsOrder: this.dataFieldsOrder,
                  format: "xlsx"
                }).dataFieldsOrder;
                eachOrdered(dataFields, function(key, val) {
                  var dataRow = [];
                  if (options2.addColumnNames) {
                    dataRow.push(val);
                  }
                  for (var len2 = _this.data.length, i2 = 0; i2 < len2; i2++) {
                    var dataValue = _this.data[i2][key];
                    dataRow.push(_this.convertToSpecialFormat(key, dataValue, options2, true));
                  }
                  data.push(_this.getExcelRow(dataRow, options2, void 0, true));
                }, function(a, b) {
                  var ai = dataFieldsOrder_2.indexOf(a);
                  var bi = dataFieldsOrder_2.indexOf(b);
                  if (ai > bi) {
                    return 1;
                  } else if (ai < bi) {
                    return -1;
                  }
                  return 0;
                });
              } else {
                if (options2.addColumnNames) {
                  data.push(this.getExcelRow(dataFields, options2, void 0, true));
                }
                for (len = this.data.length, i = 0; i < len; i++) {
                  data.push(this.getExcelRow(this.data[i], options2, dataFields));
                }
              }
              wb.Sheets[sheetName] = XLSX.utils.aoa_to_sheet(data);
              wb = this.adapter.apply("xlsxWorkbook", {
                xlsx: XLSX,
                workbook: wb,
                options: options2
              }).workbook;
              uri = this.adapter.apply("getExcel", {
                data: "data:" + this.getContentType(type) + ";base64," + XLSX.write(wb, wbOptions),
                options: options2
              }).data;
              return [2, uri];
          }
        });
      });
    };
    Export2.prototype.normalizeExcelSheetName = function(name) {
      name = name.replace(/([:\\\/?*\[\]]+)/g, " ");
      return truncateWithEllipsis(name, 31, "...", true);
    };
    Export2.prototype.getExcelRow = function(row, options2, dataFields, asIs) {
      var _this = this;
      if (asIs === void 0) {
        asIs = false;
      }
      var items = [];
      if (!dataFields) {
        dataFields = row;
      }
      var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
        dataFieldsOrder: this.dataFieldsOrder,
        format: "xlsx"
      }).dataFieldsOrder;
      eachOrdered(dataFields, function(key, name) {
        var value = _this.convertEmptyValue(key, row[key], options2);
        var item = asIs ? value : _this.convertToSpecialFormat(key, value, options2, true);
        items.push(item);
      }, function(a, b) {
        var ai = dataFieldsOrder.indexOf(a);
        var bi = dataFieldsOrder.indexOf(b);
        if (ai > bi) {
          return 1;
        } else if (ai < bi) {
          return -1;
        }
        return 0;
      });
      return items;
    };
    Export2.prototype.getCSV = function(type, options2, encodeURI) {
      if (encodeURI === void 0) {
        encodeURI = true;
      }
      return __awaiter(this, void 0, void 0, function() {
        var csv, dataFields, br, data, dataFieldsOrder_3, len, i, row, charset, uri;
        var _this = this;
        return __generator(this, function(_a) {
          if (!hasValue(options2)) {
            options2 = this.getFormatOptions("csv");
          }
          csv = "";
          dataFields = this.adapter.apply("formatDataFields", {
            dataFields: this.dataFields,
            format: "csv"
          }).dataFields;
          br = "";
          data = this.data;
          if (options2.pivot) {
            dataFieldsOrder_3 = this.adapter.apply("dataFieldsOrder", {
              dataFieldsOrder: this.dataFieldsOrder,
              format: "csv"
            }).dataFieldsOrder;
            eachOrdered(dataFields, function(key, val) {
              var dataRow = [];
              if (options2.addColumnNames) {
                dataRow.push(val);
              }
              for (var len2 = data.length, i2 = 0; i2 < len2; i2++) {
                var dataValue = data[i2][key];
                dataRow.push(_this.convertToSpecialFormat(key, dataValue, options2, true));
              }
              csv += br + _this.getCSVRow(dataRow, options2, void 0, true);
              br = "\n";
            }, function(a, b) {
              var ai = dataFieldsOrder_3.indexOf(a);
              var bi = dataFieldsOrder_3.indexOf(b);
              if (ai > bi) {
                return -1;
              } else if (ai < bi) {
                return 1;
              }
              return 0;
            });
          } else {
            for (len = data.length, i = 0; i < len; i++) {
              row = this.getCSVRow(data[i], options2, dataFields);
              if (options2.reverse) {
                csv = row + br + csv;
              } else {
                csv += br + row;
              }
              br = "\n";
            }
            if (options2.addColumnNames) {
              csv = this.getCSVRow(dataFields, options2, void 0, true) + br + csv;
            }
          }
          charset = this.adapter.apply("charset", {
            charset: "charset=utf-8",
            type,
            options: options2
          }).charset;
          uri = this.adapter.apply("getCSV", {
            data: encodeURI ? "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(csv) : csv,
            options: options2
          }).data;
          return [2, uri];
        });
      });
    };
    Export2.prototype.getCSVRow = function(row, options2, dataFields, asIs) {
      var _this = this;
      if (asIs === void 0) {
        asIs = false;
      }
      var separator = options2.separator || ",";
      var items = [];
      if (!dataFields) {
        dataFields = row;
      }
      var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
        dataFieldsOrder: this.dataFieldsOrder,
        format: "csv"
      }).dataFieldsOrder;
      eachOrdered(dataFields, function(key, name) {
        var value = _this.convertEmptyValue(key, row[key], options2);
        var item = asIs ? value : _this.convertToSpecialFormat(key, value, options2);
        item = "" + item;
        item = item.replace(/"/g, '""');
        if (options2.forceQuotes || item.search(new RegExp('"|\n|' + separator, "g")) >= 0) {
          item = '"' + item + '"';
        }
        items.push(item);
      }, function(a, b) {
        var ai = dataFieldsOrder.indexOf(a);
        var bi = dataFieldsOrder.indexOf(b);
        if (ai > bi) {
          return 1;
        } else if (ai < bi) {
          return -1;
        }
        return 0;
      });
      return items.join(separator);
    };
    Export2.prototype.getHTML = function(type, options2, encodeURI) {
      if (encodeURI === void 0) {
        encodeURI = true;
      }
      return __awaiter(this, void 0, void 0, function() {
        var html, dataFields, data, dataFieldsOrder_4, len, i, charset, uri;
        var _this = this;
        return __generator(this, function(_a) {
          if (!hasValue(options2)) {
            options2 = this.getFormatOptions("html");
          }
          html = "<table>";
          if (options2.tableClass) {
            html = '<table class="' + options2.tableClass + '">';
          }
          dataFields = this.adapter.apply("formatDataFields", {
            dataFields: this.dataFields,
            format: "html"
          }).dataFields;
          data = this.data;
          if (options2.pivot) {
            dataFieldsOrder_4 = this.adapter.apply("dataFieldsOrder", {
              dataFieldsOrder: this.dataFieldsOrder,
              format: "html"
            }).dataFieldsOrder;
            html += "\n<tbody>";
            eachOrdered(dataFields, function(key, val) {
              var dataRow = [];
              if (options2.addColumnNames) {
                dataRow.push(val);
              }
              for (var len2 = data.length, i2 = 0; i2 < len2; i2++) {
                var dataValue = data[i2][key];
                dataRow.push(_this.convertToSpecialFormat(key, dataValue, options2, true));
              }
              html += "\n" + _this.getHTMLRow(dataRow, options2, void 0, true);
            }, function(a, b) {
              var ai = dataFieldsOrder_4.indexOf(a);
              var bi = dataFieldsOrder_4.indexOf(b);
              if (ai > bi) {
                return -1;
              } else if (ai < bi) {
                return 1;
              }
              return 0;
            });
            html += "\n</tbody>";
          } else {
            if (options2.addColumnNames) {
              html += "\n<thead>\n" + this.getHTMLRow(dataFields, options2, void 0, true, true) + "\n</thead>";
            }
            html += "\n<tbody>";
            for (len = data.length, i = 0; i < len; i++) {
              html += "\n" + this.getHTMLRow(data[i], options2, dataFields);
            }
            html += "\n</tbody>";
          }
          html += "\n</table>";
          charset = this.adapter.apply("charset", {
            charset: "charset=utf-8",
            type,
            options: options2
          }).charset;
          uri = this.adapter.apply("getHTML", {
            data: encodeURI ? "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(html) : html,
            options: options2
          }).data;
          return [2, uri];
        });
      });
    };
    Export2.prototype.getHTMLRow = function(row, options2, dataFields, asIs, headerRow) {
      var _this = this;
      if (asIs === void 0) {
        asIs = false;
      }
      if (headerRow === void 0) {
        headerRow = false;
      }
      var html = "	<tr>";
      if (options2.rowClass) {
        html = '	<tr class="' + options2.rowClass + '">';
      }
      if (!dataFields) {
        dataFields = row;
      }
      var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
        dataFieldsOrder: this.dataFieldsOrder,
        format: "html"
      }).dataFieldsOrder;
      var tag = headerRow ? "th" : "td";
      var first = true;
      eachOrdered(dataFields, function(key, name) {
        var value = _this.convertEmptyValue(key, row[key], options2);
        var item = asIs ? value : _this.convertToSpecialFormat(key, value, options2);
        item = "" + item;
        item = item.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
          return "&#" + i.charCodeAt(0) + ";";
        });
        var useTag = tag;
        if (options2.pivot && first) {
          useTag = "th";
        }
        if (options2.cellClass) {
          html += "\n		<" + useTag + ' class="' + options2.cellClass + '">' + item + "</" + useTag + ">";
        } else {
          html += "\n		<" + useTag + ">" + item + "</" + useTag + ">";
        }
        first = false;
      }, function(a, b) {
        var ai = dataFieldsOrder.indexOf(a);
        var bi = dataFieldsOrder.indexOf(b);
        if (ai > bi) {
          return 1;
        } else if (ai < bi) {
          return -1;
        }
        return 0;
      });
      html += "\n	</tr>";
      return html;
    };
    Export2.prototype.getJSON = function(type, options2, encodeURI) {
      if (encodeURI === void 0) {
        encodeURI = true;
      }
      return __awaiter(this, void 0, void 0, function() {
        var data, dataFields, sourceData, _loop_1, len, i, json, charset, uri;
        var _this = this;
        return __generator(this, function(_a) {
          if (!hasValue(options2)) {
            options2 = this.getFormatOptions("json");
          }
          dataFields = this.adapter.apply("formatDataFields", {
            dataFields: this.dataFields,
            format: "json"
          }).dataFields;
          if (!this._dynamicDataFields) {
            data = [];
            sourceData = this.data;
            _loop_1 = function(len2, i2) {
              var value = sourceData[i2];
              if (typeof value == "object") {
                var newValue_1 = {};
                each2(value, function(field, item) {
                  if (hasValue(dataFields[field])) {
                    newValue_1[dataFields[field]] = _this.convertToSpecialFormat(field, item, options2);
                  }
                });
                data.push(newValue_1);
              }
            };
            for (len = sourceData.length, i = 0; i < len; i++) {
              _loop_1(len, i);
            }
          } else {
            data = this.data;
          }
          json = JSON.stringify(data, function(key, value) {
            if (typeof value == "object") {
              each2(value, function(field, item) {
                value[field] = _this.convertToSpecialFormat(field, item, options2);
              });
            }
            return value;
          }, options2.indent);
          charset = this.adapter.apply("charset", {
            charset: "charset=utf-8",
            type,
            options: options2
          }).charset;
          uri = this.adapter.apply("getJSON", {
            data: encodeURI ? "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(json) : json,
            options: options2
          }).data;
          return [2, uri];
        });
      });
    };
    Export2.prototype.convertToSpecialFormat = function(field, value, options2, keepOriginal) {
      if (typeof value == "number") {
        if (this.isDateField(field)) {
          value = new Date(value);
        } else if (this.isDurationField(field)) {
          return this.durationFormatter.format(value, this.durationFormat);
        } else if (this.isNumberField(field) && this.numberFormat) {
          return this.numberFormatter.format(value, this.numberFormat);
        }
      }
      if (value instanceof Date) {
        if (options2.useTimestamps) {
          value = value.getTime();
        } else if (options2.useLocale) {
          if (!keepOriginal) {
            value = value.toLocaleString();
          }
        } else {
          value = this.dateFormatter.format(value, this.dateFormat);
        }
      } else if (isString(value) && this.isDateField(field) && this.dateFormat) {
        value = this.dateFormatter.format(this.dateFormatter.parse(value), this.dateFormat);
      }
      return value;
    };
    Export2.prototype.convertEmptyValue = function(field, value, options2) {
      return hasValue(value) ? value : options2.emptyAs;
    };
    Export2.prototype.download = function(uri, fileName, addBOM) {
      if (addBOM === void 0) {
        addBOM = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var parts, contentType, decoded, blob_1, chars, i, charCode, blob, link_1, parts, contentType, decoded, blob_2, url_2, chars, i, charCode, blob, url_3, link, parts, contentType, iframe, idoc;
        return __generator(this, function(_a) {
          if (this.msBlobDownloadSupport()) {
            parts = uri.split(";");
            contentType = parts.shift().replace(/data:/, "");
            uri = decodeURIComponent(parts.join(";").replace(/^[^,]*,/, ""));
            if (["image/svg+xml", "application/json", "text/csv"].indexOf(contentType) == -1) {
              try {
                decoded = atob(uri);
                uri = decoded;
              } catch (e) {
                return [2, false];
              }
            } else {
              blob_1 = new Blob([uri], { type: contentType });
              window.navigator.msSaveBlob(blob_1, fileName);
              return [2, true];
            }
            chars = new Array(uri.length);
            for (i = 0; i < uri.length; ++i) {
              charCode = uri.charCodeAt(i);
              chars[i] = charCode;
            }
            blob = new Blob([new Uint8Array(chars)], { type: contentType });
            window.navigator.msSaveBlob(blob, fileName);
          } else if (this.blobDownloadSupport()) {
            link_1 = document.createElement("a");
            link_1.download = fileName;
            document.body.appendChild(link_1);
            parts = uri.split(";");
            contentType = parts.shift().replace(/data:/, "");
            uri = decodeURIComponent(parts.join(";").replace(/^[^,]*,/, ""));
            if (["image/svg+xml", "application/json", "text/csv", "text/html"].indexOf(contentType) == -1) {
              try {
                decoded = atob(uri);
                uri = decoded;
              } catch (e) {
                return [2, false];
              }
            } else {
              if (addBOM) {
                uri = "\uFEFF" + uri;
              }
              blob_2 = new Blob([uri], { type: contentType });
              url_2 = window.URL.createObjectURL(blob_2);
              link_1.href = url_2;
              link_1.download = fileName;
              link_1.click();
              setTimeout(function() {
                document.body.removeChild(link_1);
                window.URL.revokeObjectURL(url_2);
              }, 100);
              return [2, true];
            }
            chars = new Array(uri.length);
            for (i = 0; i < uri.length; ++i) {
              charCode = uri.charCodeAt(i);
              chars[i] = charCode;
            }
            if (addBOM) {
              chars = [239, 187, 191].concat(chars);
            }
            blob = new Blob([new Uint8Array(chars)], { type: contentType });
            url_3 = window.URL.createObjectURL(blob);
            link_1.href = url_3;
            link_1.download = fileName;
            document.body.appendChild(link_1);
            link_1.click();
            document.body.removeChild(link_1);
            setTimeout(function() {
              window.URL.revokeObjectURL(url_3);
            }, 100);
          } else if (this.linkDownloadSupport()) {
            link = document.createElement("a");
            link.download = fileName;
            link.href = uri;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          } else if (this.legacyIE()) {
            parts = uri.match(/^data:(.*);[ ]*([^,]*),(.*)$/);
            if (parts.length === 4) {
              if (parts[2] == "base64") {
                if (parts[1].match(/^image\//)) {
                  this.showModal('<img src="' + uri + '" style="float: left; max-width: 50%; max-height: 80%; margin: 0 1em 0.5em 0; border: 1px solid #eee;" /><p>' + this.language.translate('To save the image, right-click thumbnail on the left and choose "Save picture as..."') + '</p><p style="text-align: center;"><small>' + this.language.translate("(Press ESC to close this message)") + "</small></p>", this.language.translate("Image Export Complete"));
                }
              } else {
                contentType = void 0;
                if (fileName.match(/\.svg$/)) {
                  contentType = "image/svg+xml";
                } else {
                  contentType = "text/plain";
                  fileName += ".txt";
                }
                iframe = document.createElement("iframe");
                iframe.width = "1px";
                iframe.height = "1px";
                iframe.style.display = "none";
                document.body.appendChild(iframe);
                idoc = iframe.contentDocument;
                idoc.open(contentType, "replace");
                idoc.write(decodeURIComponent(parts[3]));
                idoc.close();
                idoc.execCommand("SaveAs", true, fileName);
                document.body.removeChild(iframe);
              }
            }
          } else {
            window.location.href = uri;
          }
          return [2, true];
        });
      });
    };
    Export2.prototype.downloadSupport = function() {
      return this.linkDownloadSupport() || this.msBlobDownloadSupport();
    };
    Export2.prototype.linkDownloadSupport = function() {
      var cache2 = registry.getCache("linkDownloadSupport");
      if (cache2 === false || cache2 === true) {
        return cache2;
      }
      var a = document.createElement("a");
      var res = typeof a.download !== "undefined";
      registry.setCache("linkDownloadSupport", res);
      return res;
    };
    Export2.prototype.blobDownloadSupport = function() {
      return hasValue(window.Blob);
    };
    Export2.prototype.msBlobDownloadSupport = function() {
      return hasValue(window.navigator.msSaveOrOpenBlob);
    };
    Export2.prototype.legacyIE = function() {
      var div = document.createElement("div");
      div.innerHTML = "<!--[if lt IE 10]><i></i><![endif]-->";
      return div.getElementsByTagName("i").length == 1;
    };
    Export2.prototype.print = function(data, options2, title) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          if (options2.printMethod == "css") {
            return [2, this.printViaCSS(data, options2, title)];
          } else {
            return [2, this.printViaIframe(data, options2, title)];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    Export2.prototype.printViaCSS = function(data, options2, title) {
      return __awaiter(this, void 0, void 0, function() {
        var scroll, rule, originalTitle, img, isIOS;
        return __generator(this, function(_a) {
          scroll = document.documentElement.scrollTop || document.body.scrollTop;
          rule = new StyleRule(getShadowRoot(this.container), "body > *", {
            "display": "none",
            "position": "fixed",
            "visibility": "hidden",
            "opacity": "0",
            "clipPath": "polygon(0px 0px,0px 0px,0px 0px,0px 0px);"
          });
          if (title && document && document.title) {
            originalTitle = document.title;
            document.title = title;
          }
          img = new Image();
          img.src = data;
          img.style.maxWidth = "100%";
          img.style.display = "block";
          img.style.position = "relative";
          img.style.visibility = "visible";
          img.style.opacity = "1";
          img.style.clipPath = "none";
          document.body.appendChild(img);
          this.setTimeout(function() {
            window.print();
          }, 50);
          isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          if (isIOS && options2.delay < 1e3) {
            options2.delay = 1e3;
          } else if (options2.delay < 100) {
            options2.delay = 100;
          }
          this.setTimeout(function() {
            document.body.removeChild(img);
            rule.dispose();
            if (originalTitle) {
              document.title = document.title;
            }
            document.documentElement.scrollTop = document.body.scrollTop = scroll;
          }, options2.delay || 500);
          return [2, true];
        });
      });
    };
    Export2.prototype.printViaIframe = function(data, options2, title) {
      return __awaiter(this, void 0, void 0, function() {
        var iframe, img, isIOS;
        return __generator(this, function(_a) {
          iframe = document.createElement("iframe");
          iframe.style.visibility = "hidden";
          document.body.appendChild(iframe);
          iframe.contentWindow.document.open();
          iframe.contentWindow.document.close();
          img = new Image();
          img.src = data;
          img.style.maxWidth = "100%";
          img.style.height = "auto";
          if (title) {
            iframe.contentWindow.document.title = title;
          }
          iframe.contentWindow.document.body.appendChild(img);
          iframe.load = function() {
            iframe.contentWindow.document.body.appendChild(img);
          };
          this.setTimeout(function() {
            try {
              if (!iframe.contentWindow.document.execCommand("print", false, null)) {
                iframe.contentWindow.print();
              }
            } catch (e) {
              iframe.contentWindow.print();
            }
          }, options2.delay || 50);
          isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          if (isIOS && options2.delay < 1e3) {
            options2.delay = 1e3;
          } else if (options2.delay < 100) {
            options2.delay = 100;
          }
          this.setTimeout(function() {
            document.body.removeChild(iframe);
          }, options2.delay + 50 || 100);
          return [2, true];
        });
      });
    };
    Export2.prototype.findBackgroundColor = function(element) {
      var opacity = 1, currentColor = getComputedStyle2(element, "background-color");
      if (currentColor.match(/[^,]*,[^,]*,[^,]*,[ ]?0/) || currentColor == "transparent") {
        opacity = 0;
      }
      if (opacity == 0) {
        var parent_2 = element.parentElement;
        if (parent_2) {
          return this.findBackgroundColor(parent_2);
        } else {
          return color("#fff");
        }
      } else {
        return color(currentColor, opacity);
      }
    };
    Object.defineProperty(Export2.prototype, "container", {
      /**
       * @return Reference
       */
      get: function() {
        return this.adapter.apply("container", {
          container: this._container
        }).container;
      },
      /**
       * A reference to a container to be used to place [[ExportMenu]] in.
       *
       * @param value Reference
       */
      set: function(value) {
        this._container = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "sprite", {
      /**
       * @return Sprite
       */
      get: function() {
        return this.adapter.apply("sprite", {
          sprite: this._sprite
        }).sprite;
      },
      /**
       * A reference to [[Sprite]] to export. Can be any Sprite, including some
       * internal elements.
       *
       * @param value Sprite
       */
      set: function(value) {
        this._sprite = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "extraSprites", {
      /**
       * @return Sprite
       */
      get: function() {
        return this.adapter.apply("extraSprites", {
          extraSprites: this._extraSprites
        }).extraSprites;
      },
      /**
       * An array of extra [[Sprite]] elements to include in export.
       *
       * It can be used to export any external elements, or even other charts.
       *
       * E.g.:
       *
       * ```TypeScript
       * chart.exporting.extraSprites.push(chart2);
       * ```
       * ```JavaScript
       * chart.exporting.extraSprites.push(chart2);
       * ```
       *
       * IMPORTANT: This setting is ignored when exporting to SVG format.
       *
       * @since 4.2.0
       * @param value Sprite
       */
      set: function(value) {
        this._extraSprites = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "validateSprites", {
      /**
       * @return Sprite
       */
      get: function() {
        return this.adapter.apply("validateSprites", {
          validateSprites: this._validateSprites
        }).validateSprites;
      },
      /**
       * An array of [[Sprite]] elements that need to be valid before export
       * commences.
       *
       * If any of those elements is not completely ready when export is triggered,
       * the export will wait until they are (their `validated` event triggers)
       * before going through with the export opertaion.
       *
       * This is useful if you need to modify chart appearance for the export.
       *
       * E.g.:
       *
       * ```TypeScript
       * // Add watermark
       * let watermark = chart.createChild(am4core.Label);
       * watermark.text = "Copyright (C) 2019";
       * watermark.disabled = true;
       *
       * // Add watermark to validated sprites
       * chart.exporting.validateSprites.push(watermark);
       *
       * // Enable watermark on export
       * chart.exporting.events.on("exportstarted", function(ev) {
       *   watermark.disabled = false;
       * });
       *
       * // Disable watermark when export finishes
       * chart.exporting.events.on("exportfinished", function(ev) {
       *   watermark.disabled = true;
       * });
       * ```
       * ```JavaScript
       * // Add watermark
       * var watermark = chart.createChild(am4core.Label);
       * watermark.text = "Copyright (C) 2019";
       * watermark.disabled = true;
       *
       * // Add watermark to validated sprites
       * chart.exporting.validateSprites.push(watermark);
       *
       * // Enable watermark on export
       * chart.exporting.events.on("exportstarted", function(ev) {
       *   watermark.disabled = false;
       * });
       *
       * // Disable watermark when export finishes
       * chart.exporting.events.on("exportfinished", function(ev) {
       *   watermark.disabled = true;
       * });
       * ```
       *
       * @since 4.6.8
       * @param value Sprite
       */
      set: function(value) {
        this._validateSprites = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "data", {
      /**
       * @return Data
       */
      get: function() {
        return this.adapter.apply("data", {
          data: this._data
        }).data;
      },
      /**
       * Data to export.
       *
       * @param value Data
       */
      set: function(value) {
        this._data = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "dataFields", {
      /**
       * @return Field names `{ field: fieldName }`
       */
      get: function() {
        if (!this._dataFields) {
          this.generateDataFields();
        }
        return this.adapter.apply("dataFields", {
          dataFields: this._dataFields
        }).dataFields;
      },
      /**
       * Data fields in `{ field: fieldName }` format. Those are used for
       * exporting in data formats to name the columns.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/exporting/#Changing_order_and_names_of_columns} for examples and details
       * @param value Field names
       */
      set: function(value) {
        this._dataFields = value;
        this._dynamicDataFields = false;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.handleDataUpdated = function() {
      if (this._dynamicDataFields) {
        this._dataFields = void 0;
      }
      var hasData = this.data.length > 0;
      if (this._prevHasData != hasData) {
        this._prevHasData = hasData;
        if (this.menu) {
          this.menu.invalidate();
        }
      }
    };
    Object.defineProperty(Export2.prototype, "dateFormatter", {
      /**
       * @return A DateFormatter instance
       */
      get: function() {
        if (!this._dateFormatter) {
          this._dateFormatter = new DateFormatter();
          this._dateFormatter.language = this.language;
        }
        return this.adapter.apply("dateFormatter", {
          dateFormatter: this._dateFormatter
        }).dateFormatter;
      },
      /**
       * A [[DateFormatter]] to use when formatting dates when exporting data.
       *
       * @param value DateFormatter instance
       */
      set: function(value) {
        this._dateFormatter = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "dateFormat", {
      /**
       * @return Date format
       */
      get: function() {
        return this.adapter.apply("dateFormat", {
          dateFormat: this._dateFormat
        }).dateFormat;
      },
      /**
       * A date format to use for exporting dates. Will use [[DateFormatter]]
       * format if not set.
       *
       * @param value Date format
       */
      set: function(value) {
        this._dateFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "dateFields", {
      /**
       * @return Date field list
       */
      get: function() {
        if (!this._dateFields) {
          this._dateFields = new List();
        }
        return this.adapter.apply("dateFields", {
          dateFields: this._dateFields
        }).dateFields;
      },
      /**
       * A list of fields that hold date values.
       *
       * @param value Date field list
       */
      set: function(value) {
        this._dateFields = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "numberFormatter", {
      /**
       * @return A NumberFormatter instance
       */
      get: function() {
        if (!this._numberFormatter) {
          this._numberFormatter = new NumberFormatter();
          this._numberFormatter.language = this.language;
        }
        return this.adapter.apply("numberFormatter", {
          numberFormatter: this._numberFormatter
        }).numberFormatter;
      },
      /**
       * A [[NumberFormatter]] to use when formatting dates when exporting data.
       *
       * @since 4.5.15
       * @param value NumberFormatter instance
       */
      set: function(value) {
        this._numberFormatter = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "numberFormat", {
      /**
       * @return Number format
       */
      get: function() {
        return this.adapter.apply("numberFormat", {
          numberFormat: this._numberFormat
        }).numberFormat;
      },
      /**
       * A number format to use for exporting dates. Will use [[NumberFormatter]]
       * format if not set.
       *
       * @since 4.5.15
       * @param value Number format
       */
      set: function(value) {
        this._numberFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "numberFields", {
      /**
       * @return Number field list
       */
      get: function() {
        if (!this._numberFields) {
          this._numberFields = new List();
        }
        return this.adapter.apply("numberFields", {
          numberFields: this._numberFields
        }).numberFields;
      },
      /**
       * A list of fields that hold number values.
       *
       * @since 4.5.15
       * @param value Number field list
       */
      set: function(value) {
        this._numberFields = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "durationFormatter", {
      /**
       * @return A DurationFormatter instance
       */
      get: function() {
        if (!this._durationFormatter) {
          this._durationFormatter = new DurationFormatter();
          this._durationFormatter.language = this.language;
        }
        return this.adapter.apply("durationFormatter", {
          durationFormatter: this._durationFormatter
        }).durationFormatter;
      },
      /**
       * A [[DurationFormatter]] to use when formatting duration values when
       * exporting data.
       *
       * @param value  DurationFormatter instance
       */
      set: function(value) {
        this._durationFormatter = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "durationFormat", {
      /**
       * @return Duration format
       */
      get: function() {
        return this.adapter.apply("durationFormat", {
          durationFormat: this._durationFormat
        }).durationFormat;
      },
      /**
       * A format to use when formatting values from `durationFields`.
       * Will use [[DurationFormatter]] format if not set.
       *
       * @param value Duration format
       */
      set: function(value) {
        this._durationFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "durationFields", {
      /**
       * @return Duration field list
       */
      get: function() {
        if (!this._durationFields) {
          this._durationFields = new List();
        }
        return this.adapter.apply("durationFields", {
          durationFields: this._durationFields
        }).durationFields;
      },
      /**
       * A list of fields that hold duration values.
       *
       * @param value Duration field list
       */
      set: function(value) {
        this._durationFields = value;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.generateDataFields = function() {
      var _this = this;
      this._dataFields = {};
      if (this.data.length) {
        each(this.data, function(row) {
          each2(row, function(key, value) {
            if (!hasValue(_this._dataFields[key])) {
              _this._dataFields[key] = _this.adapter.apply("dataFieldName", {
                name: key,
                field: key
              }).name;
            }
          });
        });
      }
    };
    Export2.prototype.isDateField = function(field) {
      return this.adapter.apply("isDateField", {
        isDateField: this.dateFields.contains(field),
        field
      }).isDateField;
    };
    Export2.prototype.isNumberField = function(field) {
      return this.adapter.apply("isNumberField", {
        isNumberField: this.numberFields.contains(field),
        field
      }).isNumberField;
    };
    Export2.prototype.isDurationField = function(field) {
      return this.adapter.apply("isDurationField", {
        isDurationField: this.durationFields.contains(field),
        field
      }).isDurationField;
    };
    Export2.prototype.getContentType = function(type) {
      var contentType = "";
      switch (type) {
        case "png":
        case "gif":
          contentType = "image/" + type;
          break;
        case "jpg":
          contentType = "image/jpeg";
          break;
        case "svg":
          contentType = "image/svg+xml";
          break;
        case "csv":
          contentType = "text/csv";
          break;
        case "json":
          contentType = "application/json";
          break;
        case "html":
          contentType = "text/html";
          break;
        case "pdf":
        case "pdfdata":
          contentType = "application/pdf";
          break;
        case "xlsx":
          contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
          break;
      }
      return this.adapter.apply("contentType", {
        contentType,
        type
      }).contentType;
    };
    Object.defineProperty(Export2.prototype, "filePrefix", {
      /**
       * @return File prefix
       */
      get: function() {
        return this.adapter.apply("filePrefix", {
          filePrefix: this._filePrefix
        }).filePrefix;
      },
      /**
       * A file prefix to be used for all exported formats.
       *
       * Export will apply format-related extension to it. E.g. if this is set to
       * "myExport", the file name of the PNG exported image will be "myExport.png".
       *
       * @param value File prefix
       */
      set: function(value) {
        this._filePrefix = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "backgroundColor", {
      /**
       * @return Background color
       */
      get: function() {
        return this.adapter.apply("backgroundColor", {
          backgroundColor: this._backgroundColor
        }).backgroundColor;
      },
      /**
       * A background color to be used for exported images. If set, this will
       * override the automatically acquired background color.
       *
       * @param value Color
       */
      set: function(value) {
        this._backgroundColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "title", {
      /**
       * @return Title
       */
      get: function() {
        return this.adapter.apply("title", {
          title: this._title
        }).title;
      },
      /**
       * A title to be used when printing.
       *
       * @param value Title
       */
      set: function(value) {
        this._title = value;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.showPreloader = function() {
      var preloader = this.preloader;
      if (preloader) {
        preloader.progress = 0.5;
        preloader.label.text = "...";
      }
    };
    Export2.prototype.hidePreloader = function() {
      var preloader = this.preloader;
      if (preloader) {
        preloader.progress = 1;
      }
    };
    Object.defineProperty(Export2.prototype, "preloader", {
      /**
       * Returns a an instance of [[Preloader]] associated with the Sprite being
       * exported.
       *
       * @return Preloader
       */
      get: function() {
        return this._sprite && this._sprite.parent && this._sprite.parent.preloader ? this._sprite.parent.preloader : void 0;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.showTimeout = function() {
      this.showModal(this.adapter.apply("timeoutMessage", {
        message: this.language.translate("Export operation took longer than expected. Something might have gone wrong.")
      }).message);
    };
    Export2.prototype.hideTimeout = function() {
      if (this._timeoutTimeout) {
        this.removeDispose(this._timeoutTimeout);
        this._timeoutTimeout = null;
      }
      this.hideModal();
    };
    Object.defineProperty(Export2.prototype, "language", {
      /**
       * @return A [[Language]] instance to be used
       */
      get: function() {
        if (!this._language) {
          this._language = new Language();
        }
        return this._language;
      },
      /**
       * A [[Language]] instance to be used for translations.
       *
       * @param value An instance of [[Language]]
       */
      set: function(value) {
        this._language = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "modal", {
      /**
       * Returns (and creates) [[Modal]].
       *
       * @ignore Exclude from docs
       * @return Modal instance
       */
      get: function() {
        if (!this._modal) {
          this._modal = new Modal();
          this._modal.adapter.add("classPrefix", function(value) {
            value = options.classNamePrefix + value;
            return value;
          });
        }
        return this._modal;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.showModal = function(text, title) {
      this.hideModal();
      this.hidePreloader();
      var modal = this.modal;
      modal.container = this.sprite.svgContainer.SVGContainer;
      modal.content = text;
      modal.readerTitle = title;
      modal.open();
    };
    Export2.prototype.hideModal = function() {
      if (this._modal) {
        this.modal.close();
      }
    };
    Export2.prototype._canvg = function() {
      return __awaiter(this, void 0, void 0, function() {
        var canvg;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, import(
                /* webpackChunkName: "canvg" */
                "./canvg-ZV7ZODTV.js"
              )];
            case 1:
              canvg = _a.sent();
              if (canvg.default != null) {
                return [2, canvg.default];
              } else {
                return [2, canvg];
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Object.defineProperty(Export2.prototype, "canvg", {
      /**
       * Returns canvg instance.
       *
       * @ignore Exclude from docs
       * @return Instance of canvg
       */
      get: function() {
        return this._canvg();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Export2.prototype, "pdfmake", {
      /**
       * Returns pdfmake instance.
       *
       * @ignore Exclude from docs
       * @return Instance of pdfmake
       */
      get: function() {
        if (pdfmakePromise == null) {
          pdfmakePromise = _pdfmake();
        }
        return pdfmakePromise;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype._xlsx = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, import(
                /* webpackChunkName: "xlsx" */
                "./xlsx-V5SSSIYP.js"
              )];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    Object.defineProperty(Export2.prototype, "xlsx", {
      /**
       * Returns xlsx instance.
       *
       * @ignore Exclude from docs
       * @return Instance of pdfmake
       */
      get: function() {
        return this._xlsx();
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype.setFormatOptions = function(type, options2) {
      this._formatOptions.setKey(type, options2);
    };
    Export2.prototype.getFormatOptions = function(type) {
      return this._formatOptions.getKey(type);
    };
    Object.defineProperty(Export2.prototype, "formatOptions", {
      /**
       * A [[Dictionary]] object containing format-specific options.
       *
       * May be used to change specific option for the format:
       *
       * ```TypeScript
       * chart.exporting.formatOptions.getKey("csv").disabled = true;
       * ```
       * ```JavaScript
       * chart.exporting.formatOptions.getKey("csv").disabled = true;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "exporting": {
       *     // ...
       *     "formatOptions": {
       *       "csv": {
       *         "disabled": true
       *       }
       *     }
       *   }
       * }
       * ```
       *
       * @since 4.9.12
       * @return  Options
       */
      get: function() {
        return this._formatOptions;
      },
      enumerable: true,
      configurable: true
    });
    Export2.prototype._disablePointers = function() {
      if (!hasValue(this._spriteInteractionsEnabled)) {
        this._spriteInteractionsEnabled = this.sprite.interactionsEnabled;
      }
      this.sprite.interactionsEnabled = false;
    };
    Export2.prototype._releasePointers = function() {
      if (hasValue(this._spriteInteractionsEnabled) && !this._exportRunning) {
        this.sprite.interactionsEnabled = this._spriteInteractionsEnabled;
      }
    };
    Export2.prototype.hideNonExportableSprites = function() {
      var _this = this;
      if (this._objectsAlreadyHidden) {
        return;
      }
      var svgContainer = this.sprite.svgContainer;
      if (svgContainer) {
        each(svgContainer.nonExportableSprites, function(item) {
          if (!item.isHidden && !item.isHiding && item.visible) {
            _this._hiddenObjects.push(item);
          }
          item.hide(0);
        });
      }
      this._objectsAlreadyHidden = true;
    };
    Export2.prototype.restoreNonExportableSprites = function() {
      if (!this._objectsAlreadyHidden) {
        return;
      }
      each(this._hiddenObjects, function(item) {
        item.show(0);
      });
      this._hiddenObjects = [];
      this._objectsAlreadyHidden = false;
    };
    Export2.prototype.awaitValidSprites = function() {
      return __awaiter(this, void 0, void 0, function() {
        var promises;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              promises = [];
              if (this.validateSprites.length) {
                each(this.validateSprites, function(sprite, index) {
                  if (sprite.invalid) {
                    promises.push(new Promise(function(resolve, reject) {
                      sprite.events.once("validated", function(ev) {
                        resolve();
                      });
                    }));
                  }
                });
              }
              if (!promises.length)
                return [3, 2];
              return [4, Promise.all(promises)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Export2.prototype.processConfig = function(config) {
      registry.registeredClasses["ExportMenu"] = ExportMenu;
      if (config) {
        if (hasValue(config.menu) && !hasValue(config.menu.type)) {
          config.menu.type = "ExportMenu";
        }
        if (hasValue(config.dataFields) && isObject(config.dataFields)) {
          this.dataFields = config.dataFields;
          delete config.dataFields;
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    Export2.XLINK = "http://www.w3.org/1999/xlink";
    return Export2;
  }(Validatable)
);

// node_modules/@amcharts/amcharts4/.internal/core/Sprite.js
var visualProperties = ["fill", "fillOpacity", "stroke", "strokeOpacity", "strokeWidth", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin"];
var Sprite = (
  /** @class */
  function(_super) {
    __extends(Sprite2, _super);
    function Sprite2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.properties = {};
      _this._eventDispatcher = new SpriteEventDispatcher(_this);
      _this._bindings = {};
      _this._isTemplate = false;
      _this._isPath = false;
      _this._inited = false;
      _this._ready = false;
      _this.isHiding = false;
      _this._isHidden = false;
      _this.isShowing = false;
      _this.isStandaloneInstance = false;
      _this._isActive = false;
      _this._mask = new MutableValueDisposer();
      _this._positionPrecision = 3;
      _this._language = new MutableValueDisposer();
      _this._exporting = new MutableValueDisposer();
      _this._exportable = true;
      _this._bbox = { x: 0, y: 0, width: 0, height: 0 };
      _this.invalid = false;
      _this.positionInvalid = false;
      _this.propertyFields = {};
      _this.applyOnClones = false;
      _this._measuredWidthSelf = 0;
      _this._measuredHeightSelf = 0;
      _this.maxLeft = 0;
      _this.maxRight = 0;
      _this.maxTop = 0;
      _this.maxBottom = 0;
      _this.maxLeftSelf = 0;
      _this.maxRightSelf = 0;
      _this.maxTopSelf = 0;
      _this.maxBottomSelf = 0;
      _this._isDragged = false;
      _this._isResized = false;
      _this._disabled = false;
      _this._internalDisabled = false;
      _this._updateDisabled = false;
      _this._internalDefaultsApplied = false;
      _this.rollOutDelay = 0;
      _this.isBaseSprite = false;
      _this.shouldClone = true;
      _this.appeared = false;
      _this.ex = 0;
      _this.ey = 0;
      _this.dragWhileResize = false;
      _this.measureFailed = false;
      _this.preventShow = false;
      _this.cloneTooltip = true;
      _this.className = "Sprite";
      _this._disposers.push(_this._eventDispatcher);
      used(_this.uid);
      _this.group = _this.paper.addGroup("g");
      _this.setPropertyValue("scale", 1);
      _this.setPropertyValue("rotation", 0);
      _this.setPropertyValue("align", "none");
      _this.setPropertyValue("valign", "none");
      _this.setPropertyValue("pixelPerfect", false);
      _this.setPropertyValue("visible", true);
      _this.setPropertyValue("tooltipPosition", "fixed");
      _this.setPropertyValue("verticalCenter", "none");
      _this.setPropertyValue("horizontalCenter", "none");
      _this.setPropertyValue("tooltipX", percent(50));
      _this.setPropertyValue("tooltipX", percent(50));
      _this.setPropertyValue("marginTop", 0);
      _this.setPropertyValue("marginBottom", 0);
      _this.setPropertyValue("marginLeft", 0);
      _this.setPropertyValue("marginRight", 0);
      _this.setPropertyValue("dx", 0);
      _this.setPropertyValue("dy", 0);
      _this.setPropertyValue("paddingTop", 0);
      _this.setPropertyValue("paddingBottom", 0);
      _this.setPropertyValue("paddingRight", 0);
      _this.setPropertyValue("paddingLeft", 0);
      _this.setPropertyValue("togglable", false);
      _this.setPropertyValue("hidden", false);
      _this.setPropertyValue("urlTarget", "_self");
      _this.setPropertyValue("alwaysShowTooltip", false);
      _this.setPropertyValue("showTooltipOn", "hover");
      _this._prevMeasuredWidth = 0;
      _this._prevMeasuredHeight = 0;
      _this._measuredWidth = 0;
      _this._measuredHeight = 0;
      _this._isMeasured = true;
      _this.invalidate();
      _this.applyTheme();
      _this._disposers.push(_this.events);
      _this._disposers.push(_this.group);
      _this._disposers.push(_this._mask);
      _this._disposers.push(_this._language);
      _this._disposers.push(_this._exporting);
      _this._disposers.push(new Disposer(function() {
        each2(_this._bindings, function(key, value) {
          value.dispose();
        });
      }));
      _this.setPropertyValue("interactionsEnabled", true);
      return _this;
    }
    Object.defineProperty(Sprite2.prototype, "events", {
      /**
       * Event dispatcher.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/event-listeners/} for more info about Events
       */
      get: function() {
        return this._eventDispatcher;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "adapter", {
      /**
       * Holds Adapter.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/adapters/} for more info about Adapters
       */
      get: function() {
        if (!this._adapterO) {
          this._adapterO = new Adapter(this);
        }
        return this._adapterO;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.applyTheme = function() {
      _super.prototype.applyTheme.call(this);
      if (options.autoSetClassName) {
        this.setClassName();
      }
    };
    Sprite2.prototype.getCurrentThemes = function() {
      var themes = this._themes;
      if (themes) {
        return themes;
      } else {
        var parent_1 = this._parent;
        if (parent_1) {
          return parent_1.getCurrentThemes();
        } else {
          return registry.themes;
        }
      }
    };
    Sprite2.prototype.applyInternalDefaults = function() {
      this._internalDefaultsApplied = true;
    };
    Sprite2.prototype.invalidate = function() {
      if (this.disabled || this._isTemplate || this.__disabled) {
        return;
      }
      if (!this.invalid) {
        this.invalid = true;
        registry.addToInvalidSprites(this);
        system.requestFrame();
      }
    };
    Sprite2.prototype.validate = function() {
      this.dispatchImmediately("beforevalidated");
      if (!this._internalDefaultsApplied) {
        this.applyInternalDefaults();
      }
      this.beforeDraw();
      this.draw();
      this.invalid = false;
      registry.removeFromInvalidSprites(this);
      this.afterDraw();
    };
    Sprite2.prototype.invalidatePosition = function() {
      if (this.disabled || this._isTemplate) {
        return;
      }
      if (!this.positionInvalid) {
        this.positionInvalid = true;
        registry.addToInvalidPositions(this);
        system.requestFrame();
      }
    };
    Sprite2.prototype.validatePosition = function() {
      var pixelX = this.pixelX;
      var pixelY = this.pixelY;
      var dx = this.dx;
      var dy = this.dy;
      var x = pixelX + dx;
      var y = pixelY + dy;
      if (this._updateDisabled) {
        if (this._internalDisabled) {
          this.group.attr({ "display": "none" });
        } else {
          if (!this.disabled) {
            this.removeSVGAttribute("display");
          }
        }
        this._updateDisabled = false;
      }
      var sizeChanged = this.measure();
      var prevGroupTransform = this.group.transformString;
      this.group.moveTo({ x, y });
      this.group.rotation = this.rotation;
      if (this.nonScaling) {
        this.group.scale = this.scale / this.globalScale;
      } else {
        this.group.scale = this.scale;
      }
      if (prevGroupTransform != this.group.transformString || sizeChanged) {
        if (prevGroupTransform == null) {
          this.dispatch("transformed");
        } else {
          this.dispatchImmediately("transformed");
        }
        this.dispatch("positionchanged");
        if (this.showTooltipOn == "hit" || this.showTooltipOn == "always") {
          this.updateTooltipPosition();
        }
      }
      if (pixelX + dx == x && pixelY + dy == y) {
        registry.removeFromInvalidPositions(this);
        this.positionInvalid = false;
      }
      var maskRectangle = this._maskRectangle;
      if (maskRectangle) {
        this._clipElement.moveTo({ x: maskRectangle.x - pixelX, y: maskRectangle.y - pixelY });
      }
    };
    Sprite2.prototype.beforeDraw = function() {
    };
    Sprite2.prototype.draw = function() {
    };
    Sprite2.prototype.afterDraw = function() {
      var e_1, _a;
      if (this.isMeasured || this.horizontalCenter !== "none" || this.verticalCenter !== "none") {
        this.measureElement();
      }
      if (!this._inited) {
        if (this._adapterO) {
          try {
            for (var _b = __values(this._adapterO.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var key = _c.value;
              switch (key) {
                case "mask":
                case "fill":
                case "opacity":
                case "fillOpacity":
                case "stroke":
                case "strokeOpacity":
                case "strokeWidth":
                case "shapeRendering":
                case "strokeDasharray":
                case "strokeDashoffset":
                case "strokeLinecap":
                case "strokeLinejoin":
                case "textDecoration":
                case "fontSize":
                case "fontFamily":
                case "fontWeight":
                  this[key] = this[key];
                  break;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        this.applyFilters();
        this.visible = this.visible;
        this.interactionsEnabled = this.getPropertyValue("interactionsEnabled");
        this._inited = true;
        if (!this.showOnInit) {
          this.appeared = true;
        }
        if (this.hidden) {
          this.hide(0);
        }
        this.applyMask();
        this.dispatch("validated");
        this.dispatch("inited");
        this.dispatchReady();
      } else {
        this.dispatch("validated");
      }
      if (this.showTooltipOn == "always") {
        if (this.visible && !this.disabled && !this.__disabled) {
          this.showTooltip();
        } else {
          this.hideTooltip(0);
        }
      }
    };
    Sprite2.prototype.dispatchReady = function() {
      if (!this.isReady()) {
        this._ready = true;
        this.dispatch("ready");
      }
    };
    Sprite2.prototype.reinit = function() {
      this._inited = false;
      this.setState(this.defaultState);
      this.invalidate();
    };
    Sprite2.prototype.handleGlobalScale = function() {
      this.dispatch("globalscalechanged");
      if (this.nonScalingStroke) {
        this.strokeWidth = this.strokeWidth;
      }
      if (this.nonScaling) {
        this.validatePosition();
      }
      this.updateFilterScale();
    };
    Sprite2.prototype.updateFilterScale = function() {
      var _this = this;
      each3(this.filters.iterator(), function(filter) {
        filter.scale = _this.globalScale;
      });
    };
    Sprite2.prototype.removeFromInvalids = function() {
      registry.removeFromInvalidSprites(this);
      registry.removeFromInvalidPositions(this);
    };
    Sprite2.prototype.copyFrom = function(source) {
      var _this = this;
      _super.prototype.copyFrom.call(this, source);
      this.isMeasured = source.isMeasured;
      this.states.copyFrom(source.states);
      if (source.filters.length > 0) {
        source.filters.each(function(filter) {
          _this.filters.push(filter.clone());
        });
      }
      if (source._adapterO) {
        this.adapter.copyFrom(source._adapterO);
      }
      if (source["_interaction"]) {
        this.interactions.copyFrom(source.interactions);
      }
      if (source["_plugins"]) {
        this.plugins.copyFrom(source.plugins);
      }
      this.configField = source.configField;
      this.applyOnClones = source.applyOnClones;
      this.disabled = source.disabled;
      this.virtualParent = source.virtualParent;
      this.exportable = source.exportable;
      if (source._tooltip) {
        if (this._tooltip) {
          this._tooltip.copyFrom(source.tooltip);
        } else {
          if (source.cloneTooltip) {
            this.tooltip = source.tooltip.clone();
          } else {
            this._tooltip = source.tooltip;
          }
        }
      }
      this._showSystemTooltip = source.showSystemTooltip;
      copyProperties(source.propertyFields, this.propertyFields);
      copyProperties(source.properties, this);
      if (source.fillModifier) {
        this.fillModifier = source.fillModifier.clone();
      }
      if (source.strokeModifier) {
        this.strokeModifier = source.strokeModifier.clone();
      }
      if (source.focusFilter) {
        this.focusFilter = source.focusFilter.clone();
      }
    };
    Sprite2.prototype.dispose = function() {
      if (!this.isDisposed()) {
        if (this.showTooltipOn == "always" && this.tooltip) {
          this.tooltip.hide();
        }
        this.dispatchImmediately("beforedisposed");
        if (this.isBaseSprite) {
          if (this.htmlContainer) {
            while (this.htmlContainer.childNodes.length > 0) {
              this.htmlContainer.removeChild(this.htmlContainer.firstChild);
            }
          }
          this.isBaseSprite = false;
        }
        _super.prototype.dispose.call(this);
        if (this._adapterO) {
          this._adapterO.clear();
        }
        if (this.applyOnClones) {
          if (this._clones) {
            for (var i = this._clones.length - 1; i >= 0; i--) {
              var clone2 = this._clones.getIndex(i);
              clone2.dispose();
            }
          }
        }
        if (this._svgContainer) {
          this._svgContainer.dispose();
        }
        if (this._interactionDisposer) {
          this._interactionDisposer.dispose();
          this._interactionDisposer = void 0;
        }
        if (this._urlDisposer) {
          this._urlDisposer.dispose();
        }
        this.removeFromInvalids();
        if (this.element) {
          this.element.dispose();
        }
        if (this.group) {
          this.group.dispose();
        }
        if (this._numberFormatter) {
          this._numberFormatter.dispose();
        }
        if (this._focusFilter) {
          this._focusFilter.dispose();
        }
        var stroke = this.stroke;
        if (stroke && !(stroke instanceof Color) && stroke.dispose) {
          if (this.clonedFrom && this.clonedFrom.stroke == stroke) {
          } else {
            stroke.dispose();
          }
        }
        var fill = this.fill;
        if (fill && !(fill instanceof Color) && fill.dispose) {
          if (this.clonedFrom && this.clonedFrom.fill == fill) {
          } else {
            fill.dispose();
          }
        }
        if (hasValue(this.id)) {
          this.map.removeKey(this.id);
        }
        this.parent = void 0;
        if (this._filters) {
          while (this._filters.length > 0) {
            var filter = this._filters.getIndex(0);
            filter.dispose();
            this._filters.removeValue(filter);
          }
        }
        this._alwaysShowDisposers = void 0;
      }
    };
    Object.defineProperty(Sprite2.prototype, "isTemplate", {
      /**
       * @ignore Exclude from docs
       * @return Is template?
       */
      get: function() {
        return this._isTemplate;
      },
      /**
       * Indicates if this element is a "template".
       *
       * Template Sprites act only as a holders for config for other "real"
       * elements to be cloned from.
       *
       * Templates are treated differently, as they are not validated, redrawn, or
       * otherwise are processed.
       *
       * @ignore Exclude from docs
       * @param value Is template?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this._isTemplate != value) {
          this._isTemplate = value;
          if (this instanceof Container) {
            each3(this.children.iterator(), function(child) {
              child.isTemplate = value;
            });
          }
          if (value) {
            this.parent = this._parent;
            this.removeFromInvalids();
          } else {
            this.invalidate();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "showSystemTooltip", {
      /**
       * @return Show system tooltip?
       */
      get: function() {
        if (!hasValue(this._showSystemTooltip)) {
          if (this.virtualParent) {
            return this.virtualParent.showSystemTooltip;
          } else if (this._parent) {
            return this._parent.showSystemTooltip;
          } else {
            return false;
          }
        }
        return this._showSystemTooltip;
      },
      /**
       * Indicates whether the element should attempt to construct itself in a way
       * so that system tooltip is shown if its `readerTitle` is set.
       *
       * @param value Show system tooltip?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this._showSystemTooltip != value) {
          this._showSystemTooltip = value;
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "topParent", {
      /**
       * ==========================================================================
       * HIERARCHY AND STRUCTURE RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Sprites's top-level [[Container]].
       *
       * Please note that in most cases it won't be the chart element.
       *
       * To access base chart element, use `baseSprite` instead.
       *
       * @return Top-level ascendant
       */
      get: function() {
        if (this._topParent) {
          return this._topParent;
        } else {
          if (this._parent) {
            return this._parent.topParent;
          }
        }
      },
      /**
       * @ignore
       * @param value {Container} top parent of a sprite
       */
      set: function(value) {
        this._topParent = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "parent", {
      /**
       * @return Parent container
       */
      get: function() {
        return this._parent;
      },
      /**
       * Elements' parent [[Container]].
       *
       * @param parent  Parent container
       */
      set: function(parent) {
        if (this._isTemplate) {
          return;
        }
        used(this.paper);
        var oldParent = this._parent;
        if (oldParent != parent) {
          if (oldParent) {
            oldParent.children.removeValue(this);
          }
          this._parent = parent;
          if (parent) {
            this.topParent = parent.topParent;
            if (parent.isTemplate) {
              this.isTemplate = true;
            }
            this.baseId = parent.baseId;
            parent.children.push(this);
            if (this._tooltip && !this._tooltipContainer) {
              this._tooltip.parent = parent.tooltipContainer;
            }
            if (!this._dataItem) {
              this.dataItem = parent.dataItem;
            }
            this.handleAlwaysShowTooltip();
            if (this.dataItem) {
              this.applyAccessibility();
            }
            this.dispatchImmediately("parentset");
          } else {
            this.topParent = void 0;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleAlwaysShow = function() {
      this.showTooltip();
    };
    Sprite2.prototype.handleAlwaysShowTooltip = function() {
      var sprite = this;
      var oldDisposers = this._alwaysShowDisposers;
      if (oldDisposers) {
        each(oldDisposers, function(oldDisposer) {
          oldDisposer.dispose();
        });
      }
      this._alwaysShowDisposers = [];
      if (this.showTooltipOn == "always") {
        while (sprite != void 0) {
          var disposer = sprite.events.on("visibilitychanged", this.handleAlwaysShow, this, false);
          this.addDisposer(disposer);
          this._alwaysShowDisposers.push(disposer);
          sprite = sprite.parent;
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "virtualParent", {
      /**
       * @return Virtual parent
       */
      get: function() {
        return this._virtualParent;
      },
      /**
       * Element's "virtual" parent.
       *
       * This is required in ordere to maintain proper inheritance (like
       * formatters).
       *
       * Sometimes an element is a "logical" parent, even though it's not a direct
       * ascendant.
       *
       * Example: a bullet is not a child of the axis, but it would make sense
       * for it to inherit series' formatters.
       *
       * @ignore Exclude from docs
       * @param value  Virtual parent
       */
      set: function(value) {
        this._virtualParent = value;
        if (this.dataItem) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.appendDefs = function() {
      if (this.filterElement) {
        this.paper.appendDef(this.filterElement);
      }
      var fill = this.fill;
      if (fill && fill.element) {
        this.paper.appendDef(fill.element);
      }
      var stroke = this.stroke;
      if (stroke && stroke.element) {
        this.paper.appendDef(stroke.element);
      }
      if (this.fillModifier && this.fill instanceof Color) {
        var fill_1 = this.fillModifier.modify(this.fill);
        if (fill_1 && fill_1.element) {
          this.paper.appendDef(fill_1.element);
        }
      }
      if (this.strokeModifier && this.stroke instanceof Color) {
        var stroke_1 = this.strokeModifier.modify(this.stroke);
        if (stroke_1 && stroke_1.element) {
          this.paper.appendDef(stroke_1.element);
        }
      }
      if (this._clipPath) {
        this.paper.appendDef(this._clipPath);
      }
      if (this._exportable === false) {
        this.exportable = false;
      }
    };
    Object.defineProperty(Sprite2.prototype, "map", {
      /**
       * Returns a [[Dictionary]] which maps object ids with their respective
       * objects.
       *
       * Can be used to retrieve any object by id, e.g.:
       *
       * ```TypeScript
       * console.log(mySprite.map.getKey("myid"));
       * ```
       * ```JavaScript
       * console.log(mySprite.map.getKey("myid"));
       * ```
       *
       * @return Map collection
       */
      get: function() {
        var top = this.topParent;
        if (top) {
          return top.map;
        } else if (!this._map) {
          this._map = new Dictionary();
        }
        return this._map;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "delayedMap", {
      /**
       * @ignore
       * @return Map collection
       */
      get: function() {
        var top = this.topParent;
        if (top) {
          return top.delayedMap;
        } else if (!this._delayedMap) {
          this._delayedMap = new Dictionary();
        }
        return this._delayedMap;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "id", {
      /**
       * @return ID
       */
      get: function() {
        return this._id;
      },
      /**
       * Element's user-defined ID.
       *
       * Will throw an Error if there already is an object with the same ID.
       *
       * Please note that above check will be performed withing the scope of the
       * current chart instance. It will not do checks across other chart instances
       * or in globally in DOM.
       *
       * Make sure the IDs are unique.
       *
       * @param value ID
       */
      set: function(value) {
        if (this._id != value) {
          this._id = value;
          if (this.map.hasKey(value)) {
            throw Error("Duplicate id (" + value + ") used on multiple objects.");
          } else {
            this.map.setKey(value, this);
          }
          if (options.autoSetClassName) {
            this.setClassName();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "dom", {
      /**
       * ==========================================================================
       * ELEMENT AND DOM TREE MANIPULATION AND MEASURING
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns DOM element reference associated with this element.
       *
       * @readonly
       * @return DOM element
       */
      get: function() {
        return this.group.node;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "paper", {
      /**
       * @ignore Exclude from docs
       * @return Paper
       */
      get: function() {
        if (this._paper) {
          return this._paper;
        } else {
          var parent_2 = this._parent;
          if (parent_2) {
            return parent_2.paper;
          }
        }
        return getGhostPaper();
      },
      /**
       * A [[Paper]] instance to place elements on.
       *
       * If there's no Paper set for this element, it goes up the ascendant tree
       * until it finds one.
       *
       * This method is used by important `addChild()` method, so it's essential
       * to have a [[Paper]] instance.
       *
       * If this element has a separate `htmlContainer` set, it will have a
       * [[Paper]] instance itself.
       *
       * @ignore Exclude from docs
       * @param paper  Paper
       */
      set: function(paper) {
        this.setPaper(paper);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setPaper = function(paper) {
      var oldPaper = this._paper;
      if (oldPaper != paper) {
        this._paper = paper;
        this.appendDefs();
        return true;
      }
      return false;
    };
    Object.defineProperty(Sprite2.prototype, "htmlContainer", {
      /**
       * @return HTML element
       */
      get: function() {
        if (this._htmlContainer) {
          return this._htmlContainer;
        } else {
          var parent_3 = this._parent;
          if (parent_3) {
            return parent_3.htmlContainer;
          }
        }
      },
      /**
       * An HTML element to be used when placing wrapper element (`<div>`)
       * for the whole chart.
       *
       * This is the same for **all** elements within the same chart.
       *
       * @param htmlContainer HTML element
       */
      set: function(htmlContainer) {
        this._htmlContainer = htmlContainer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "titleElement", {
      /**
       * Creates (if not yet created) and returns element's `<title>` element.
       *
       * @ignore Exclude from docs
       * @return Title element
       */
      get: function() {
        if (!this._titleElement) {
          this._titleElement = this.paper.add("title");
          this.group.add(this._titleElement);
        }
        return this._titleElement;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "descriptionElement", {
      /**
       * Creates (if not yet created) and returns element's `<desc>` element.
       *
       * @ignore Exclude from docs
       * @return Desc element
       */
      get: function() {
        if (!this._descriptionElement) {
          this._descriptionElement = this.paper.add("desc");
          this.group.add(this._descriptionElement);
        }
        return this._descriptionElement;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "filters", {
      /**
       * Returns list of SVG filters (effects) applied to element. If the filter
       * list is not yet initilized, creates and returns an empty one.
       * Note, not all filters combine well with one another. We recommend using one filter per sprite.
       *
       * @return List of filters
       */
      get: function() {
        if (!this._filters) {
          this._filters = new List();
          this._disposers.push(this._filters.events.onAll(this.applyFilters, this));
          this._disposers.push(new ListDisposer(this._filters));
        }
        return this._filters;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setSVGAttributes = function() {
      this.fill = this.fill;
      this.opacity = this.opacity;
      this.fillOpacity = this.fillOpacity;
      this.stroke = this.stroke;
      this.strokeOpacity = this.strokeOpacity;
      this.shapeRendering = this.shapeRendering;
      this.strokeDasharray = this.strokeDasharray;
      this.strokeDashoffset = this.strokeDashoffset;
      this.strokeLinecap = this.strokeLinecap;
      this.strokeLinejoin = this.strokeLinejoin;
      this.focusable = this.focusable;
      this.tabindex = this.tabindex;
      this.role = this.role;
    };
    Sprite2.prototype.setSVGAttribute = function(attribute) {
      this.group.attr(attribute);
    };
    Sprite2.prototype.removeSVGAttribute = function(attribute) {
      this.group.removeAttr(attribute);
    };
    Sprite2.prototype.setClassName = function() {
      var className = this.className;
      var classNamePrefix = options.classNamePrefix;
      if (this.element) {
        this.element.addClass(classNamePrefix + className);
      }
      this.group.addClass(classNamePrefix + className + "-group");
      if (hasValue(this.id)) {
        this.group.addClass(classNamePrefix + this.id);
      }
      if (this.userClassName) {
        this.group.addClass(this.userClassName);
      }
    };
    Sprite2.prototype.uidAttr = function() {
      this.setSVGAttribute({ "id": this.uid });
      return this.uid;
    };
    Sprite2.prototype.updateClipPath = function() {
      var element = this._clipElement;
      if (element) {
        element.moveTo({ x: this.mask.pixelX, y: this.mask.pixelY });
      }
    };
    Sprite2.prototype.createClipPath = function() {
      if (!this._clipPath) {
        this._clipPath = this.paper.addGroup("clipPath");
        this.paper.appendDef(this._clipPath);
        this._disposers.push(this._clipPath);
        var id = registry.getUniqueId();
        this._clipPath.attr({ "id": id });
        this.group.attr({ "clip-path": 'url("' + getBaseURI() + id + '")' });
      }
    };
    Sprite2.prototype.applyMask = function() {
      var mask = this.mask;
      if (this._clipPath && mask) {
        if (mask instanceof Container) {
          this._clipElement.attr({ "width": max(0, mask.pixelWidth), "height": max(0, mask.pixelHeight) });
          var point = spritePointToSprite({ x: mask.pixelX, y: mask.pixelY }, mask.parent, this);
          this._clipPath.x = point.x;
          this._clipPath.y = point.y;
        } else {
          if (mask.element && mask.element != this._clipElement) {
            this._clipElement = mask.element;
            this._clipPath.add(this._clipElement);
          }
          this._clipPath.scale = mask.scale;
          this._clipPath.x = mask.pixelX;
          this._clipPath.y = mask.pixelY;
          this._clipPath.rotation = mask.rotation;
        }
      }
    };
    Sprite2.prototype.applyFilters = function() {
      var _this = this;
      if (this._filters && this._filters.length > 0) {
        var width_1 = 100;
        var height_1 = 100;
        if (!this.filterElement) {
          this.filterElement = this.paper.addGroup("filter");
          this._disposers.push(this.filterElement);
        } else {
          this.filterElement.removeChildNodes();
        }
        this.paper.appendDef(this.filterElement);
        var id = "filter-" + this.uid;
        this.filterElement.attr({ "id": id });
        each3(this.filters.iterator(), function(filter) {
          filter.sprite = _this;
          filter.paper = _this.paper;
          _this.filterElement.attr({ filterUnits: filter.filterUnits });
          filter.appendPrimitives(_this.filterElement);
          if (filter.width > width_1) {
            width_1 = filter.width;
          }
          if (filter.height > height_1) {
            height_1 = filter.height;
          }
          filter.scale = _this.globalScale;
        });
        var w = width_1 + "%";
        var h = height_1 + "%";
        this.filterElement.attr({ "width": w, "height": h, "x": -(width_1 - 100) / 2 + "%", "y": -(height_1 - 100) / 2 + "%" });
        this.group.attr({ "filter": 'url("' + getBaseURI() + id + '")' });
      } else if (this.filterElement) {
        this.group.removeAttr("filter");
        this.filterElement.removeChildNodes();
      }
    };
    Sprite2.prototype.removeClipPath = function() {
      if (this._clipPath) {
        this.removeDispose(this._clipPath);
        this._clipPath = void 0;
      }
    };
    Sprite2.prototype.setElement = function(element) {
      this.element = element;
      this.setSVGAttributes();
      this.applyAccessibility();
    };
    Object.defineProperty(Sprite2.prototype, "element", {
      /**
       * @return Element
       */
      get: function() {
        return this._element;
      },
      /**
       * The main element for this Sprite, usually an SVG `<g>`.
       *
       * All other sub-elements are created in it.
       *
       * @param element  Element
       */
      set: function(element) {
        this.removeElement();
        this._element = element;
        this.group.add(element);
        if (element.node instanceof SVGPathElement) {
          this._isPath = true;
        }
        if (!this.invalid) {
          this.validate();
        }
        if (options.autoSetClassName) {
          this.setClassName();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "svgContainer", {
      /**
       * HTML container (`<div>`) which is used to place chart's `<svg>` element
       * in.
       *
       * @return Container for chart elements
       */
      get: function() {
        if (this._svgContainer) {
          return this._svgContainer;
        } else if (this._parent) {
          return this._parent.svgContainer;
        }
      },
      /**
       * Sets HTML container to add SVG and other chart elements to.
       *
       * @param svgContainer Container for chart elements
       */
      set: function(svgContainer) {
        this._svgContainer = svgContainer;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.measureElement = function() {
      if (this.element) {
        if (this.definedBBox) {
          this._bbox = this.definedBBox;
        } else {
          var svgBBox = this.element.getBBox();
          this._bbox = { x: svgBBox.x, y: svgBBox.y, width: svgBBox.width, height: svgBBox.height };
        }
      }
    };
    Sprite2.prototype.updateCenter = function() {
      if (this.element) {
        var prevElementTransform = this.element.transformString;
        var bbox = this.bbox;
        var ex = 0;
        var ey = 0;
        var elementX = bbox.x;
        var elementY = bbox.y;
        var elementWidth = bbox.width;
        var elementHeigth = bbox.height;
        var pixelPaddingLeft = this.pixelPaddingLeft;
        var pixelPaddingRight = this.pixelPaddingRight;
        var pixelPaddingTop = this.pixelPaddingTop;
        var pixelPaddingBottom = this.pixelPaddingBottom;
        var measuredWidth = max(elementWidth + pixelPaddingLeft + pixelPaddingRight, this.pixelWidth);
        var measuredHeight = max(elementHeigth + pixelPaddingTop + pixelPaddingBottom, this.pixelHeight);
        var left = bbox.x;
        var right = bbox.x + measuredWidth;
        var top_1 = bbox.y;
        var bottom = bbox.y + measuredHeight;
        var horizontalCenter = this.horizontalCenter;
        var verticalCenter = this.verticalCenter;
        switch (horizontalCenter) {
          case "none":
            ex = elementX + pixelPaddingLeft;
            break;
          case "left":
            ex = pixelPaddingLeft;
            break;
          case "middle":
            ex = pixelPaddingLeft - (elementWidth + pixelPaddingRight + pixelPaddingLeft) / 2;
            break;
          case "right":
            ex = -pixelPaddingRight - elementWidth;
            break;
        }
        switch (verticalCenter) {
          case "none":
            ey = elementY + pixelPaddingTop;
            break;
          case "top":
            ey = pixelPaddingTop;
            break;
          case "middle":
            ey = pixelPaddingTop - (elementHeigth + pixelPaddingBottom + pixelPaddingTop) / 2;
            break;
          case "bottom":
            ey = -pixelPaddingBottom - elementHeigth;
            break;
        }
        this._measuredHeight = measuredHeight;
        this._measuredWidth = measuredWidth;
        var x = round(ex - elementX, this._positionPrecision, true);
        var y = round(ey - elementY, this._positionPrecision, true);
        this.ex = x - pixelPaddingLeft;
        this.ey = y - pixelPaddingTop;
        this.maxLeft = left + x - pixelPaddingLeft;
        this.maxRight = right + x - pixelPaddingLeft;
        this.maxTop = top_1 + y - pixelPaddingTop;
        this.maxBottom = bottom + y - pixelPaddingTop;
        if (this.pixelPerfect && options.pixelPerfectPrecision == 0) {
          x -= 0.5;
          y -= 0.5;
        }
        this.element.moveTo({ x, y });
        if (prevElementTransform != this.element.transformString) {
          this.dispatchImmediately("transformed");
        }
      }
    };
    Sprite2.prototype.measure = function() {
      this.updateCenter();
      var measuredWidth = this._measuredWidth;
      var measuredHeight = this._measuredHeight;
      var left = this.maxLeft;
      var right = this.maxRight;
      var top = this.maxTop;
      var bottom = this.maxBottom;
      this._measuredWidthSelf = measuredWidth;
      this._measuredHeightSelf = measuredHeight;
      var positionPrecision = this._positionPrecision;
      this.maxLeftSelf = this.maxLeft;
      this.maxRightSelf = this.maxRight;
      this.maxTopSelf = this.maxTop;
      this.maxBottomSelf = this.maxBottom;
      if (this.rotation !== 0 || this.scale !== 1 || this.nonScaling) {
        if (this.nonScalingStroke) {
          this.strokeWidth = this.strokeWidth;
        }
        var svg = this.paper.svg;
        var matrix = svg.createSVGMatrix();
        var rotation = this.rotation;
        var scale = this.scale;
        if (this.nonScaling) {
          scale = this.scale / this.globalScale;
        }
        matrix.a = cos(rotation) * scale;
        matrix.c = -sin(rotation) * scale;
        matrix.e = 0;
        matrix.b = sin(rotation) * scale;
        matrix.d = cos(rotation) * scale;
        matrix.f = 0;
        var p1 = svg.createSVGPoint();
        p1.x = left;
        p1.y = top;
        var p2 = svg.createSVGPoint();
        p2.x = right;
        p2.y = top;
        var p3 = svg.createSVGPoint();
        p3.x = right;
        p3.y = bottom;
        var p4 = svg.createSVGPoint();
        p4.x = left;
        p4.y = bottom;
        var pt1 = p1.matrixTransform(matrix);
        var pt2 = p2.matrixTransform(matrix);
        var pt3 = p3.matrixTransform(matrix);
        var pt4 = p4.matrixTransform(matrix);
        left = Math.min(pt1.x, pt2.x, pt3.x, pt4.x);
        right = Math.max(pt1.x, pt2.x, pt3.x, pt4.x);
        top = Math.min(pt1.y, pt2.y, pt3.y, pt4.y);
        bottom = Math.max(pt1.y, pt2.y, pt3.y, pt4.y);
        measuredWidth = right - left;
        measuredHeight = bottom - top;
        this.maxLeft = round(left, positionPrecision, true);
        this.maxRight = round(right, positionPrecision, true);
        this.maxTop = round(top, positionPrecision, true);
        this.maxBottom = round(bottom, positionPrecision, true);
      }
      this._measuredWidth = round(measuredWidth, positionPrecision, true);
      this._measuredHeight = round(measuredHeight, positionPrecision, true);
      if (this._measuredWidth != this._prevMeasuredWidth || this._measuredHeight != this._prevMeasuredHeight) {
        this._prevMeasuredHeight = this._measuredHeight;
        this._prevMeasuredWidth = this._measuredWidth;
        this.dispatch("sizechanged");
        if ((this.isHover || this.showTooltipOn == "hit" || this.showTooltipOn == "always") && this.tooltip && this.tooltip.visible && (hasValue(this.tooltipText) || hasValue(this.tooltipHTML))) {
          this.updateTooltipPosition();
        }
        return true;
      }
      return false;
    };
    Sprite2.prototype.insertBefore = function(sprite) {
      var parent = this._parent;
      if (parent) {
        var index = parent.children.indexOf(sprite);
        if (index !== -1) {
          parent.children.moveValue(this, index);
          parent.sortChildren();
        }
      }
      return this;
    };
    Sprite2.prototype.insertAfter = function(sprite) {
      var parent = this._parent;
      if (parent) {
        var index = parent.children.indexOf(sprite);
        if (index !== -1) {
          parent.children.moveValue(this, index + 1);
          parent.sortChildren();
        }
      }
      return this;
    };
    Sprite2.prototype.removeElement = function() {
      if (this._element) {
        this.removeDispose(this._element);
        this._element = void 0;
      }
    };
    Sprite2.prototype.getRelativeX = function(value) {
      if (value instanceof Percent) {
        return value.value;
      } else if (this._parent) {
        return value / this._parent.innerWidth;
      }
      return 0;
    };
    Sprite2.prototype.getRelativeY = function(value) {
      if (value instanceof Percent) {
        return value.value;
      } else if (this._parent) {
        return value / this._parent.innerHeight;
      }
      return 0;
    };
    Sprite2.prototype.getPixelX = function(value) {
      var pixel = 0;
      if (isNumber(value)) {
        pixel = value;
      } else if (value instanceof Percent) {
        var relative = value.value;
        if (this._parent) {
          pixel = round(this._parent.innerWidth * relative, this._positionPrecision, true);
        }
      }
      return pixel;
    };
    Sprite2.prototype.getPixelY = function(value) {
      var pixel = 0;
      if (isNumber(value)) {
        pixel = value;
      } else if (value instanceof Percent) {
        var relative = value.value;
        if (this._parent) {
          pixel = round(this._parent.innerHeight * relative, this._positionPrecision, true);
        }
      }
      return pixel;
    };
    Sprite2.prototype.moveTo = function(point, rotation, scale, isDragged) {
      if (this.isDragged && !isDragged) {
        return;
      }
      if (point) {
        if (isNumber(point.x)) {
          this.setPropertyValue("x", round(point.x, this._positionPrecision, true));
        }
        if (isNumber(point.y)) {
          this.setPropertyValue("y", round(point.y, this._positionPrecision, true));
        }
      }
      if (isNumber(rotation)) {
        this.rotation = rotation;
      }
      if (isNumber(scale)) {
        this.scale = scale;
      }
      this.invalidatePosition();
    };
    Object.defineProperty(Sprite2.prototype, "mask", {
      /**
       * Returns [[Sprite]] element currently used as mask for this element.
       *
       * @ignore Exclude from docs
       * @return A [[Sprite]] to use as mask
       */
      get: function() {
        if (!this._adapterO) {
          return this._mask.get();
        } else {
          return this._adapterO.apply("mask", this._mask.get());
        }
      },
      /**
       * Sets another [[Sprite]] element as this elements mask.
       *
       * @ignore Exclude from docs
       * @param mask A [[Sprite]] to use as mask
       */
      set: function(mask) {
        var _this = this;
        if (this._mask.get() !== mask) {
          if (mask) {
            this.createClipPath();
            if (!(mask instanceof Container)) {
              mask.isMeasured = false;
              if (mask.element) {
                this._clipElement = mask.element;
              }
            } else {
              this._clipElement = this.paper.add("rect");
            }
            if (this._clipElement) {
              this._clipPath.add(this._clipElement);
            }
            this._mask.set(mask, new MultiDisposer([
              //mask.addEventListener(SpriteEvent.TRANSFORMED, this.applyMask, false, this);
              mask.events.on("maxsizechanged", function() {
                if (_this.inited) {
                  _this.applyMask();
                }
              }, void 0, false),
              mask.events.on("validated", this.applyMask, this, false),
              mask.events.on("positionchanged", this.applyMask, this, false)
            ]));
            this.applyMask();
          } else {
            this._mask.reset();
            this.group.removeAttr("clip-path");
            this.removeClipPath();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "maskRectangle", {
      /**
       * @ignore Exclude from docs
       * @return Mask Rectangle
       */
      get: function() {
        return this._maskRectangle;
      },
      // you can set IRectangle as a mask instead o a sprite. Note, the changes of the object won't be monitored
      /**
       * Instead of creating a [[Sprite]] for mask, you can just use a
       * [[Rectangle]] by setting this accessor.
       *
       * Please note that the element will not monitor any changes to the mask
       * rectangle.
       *
       * @ignore Exclude from docs
       * @param rect Mask Rectangle
       */
      set: function(rect) {
        if (rect) {
          this.createClipPath();
          if (!this._clipElement) {
            this._clipElement = this.paper.add("rect");
            this._clipPath.add(this._clipElement);
          }
          this._clipElement.attr({ "width": rect.width, "height": rect.height });
        } else {
          this.removeClipPath();
          this._clipElement = void 0;
        }
        this._maskRectangle = rect;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "isMeasured", {
      /**
       * @ignore Exclude from docs
       * @return Was element already measured?
       */
      get: function() {
        return this._isMeasured;
      },
      /**
       * Indicates if this element was already measured.
       *
       * @ignore Exclude from docs
       * @param value Was element already measured?
       */
      set: function(value) {
        value = toBoolean(value);
        if (!value) {
          this._measuredWidth = 0;
          this._measuredHeight = 0;
        }
        if (this._isMeasured != value) {
          this._isMeasured = value;
          this.invalidatePosition();
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.hitTest = function(sprite) {
      if (this.invalid) {
        this.validate();
      }
      if (sprite.invalid) {
        sprite.validate();
      }
      var ax1 = this.pixelX + this.maxLeft;
      var ay1 = this.pixelY + this.maxTop;
      var ax2 = ax1 + this.maxRight;
      var ay2 = ay1 + this.maxBottom;
      var bx1 = sprite.pixelX + sprite.maxLeft;
      var by1 = sprite.pixelY + sprite.maxTop;
      var bx2 = bx1 + sprite.maxRight;
      var by2 = by1 + sprite.maxBottom;
      return !(bx1 > ax2 || bx2 < ax1 || by1 > ay2 || by2 < ay1);
    };
    Object.defineProperty(Sprite2.prototype, "inited", {
      /**
       * ==========================================================================
       * STATE-RELATED
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns `true` if Sprite has already finished initializing.
       *
       * @return Initialized?
       */
      get: function() {
        return this._inited;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.isReady = function() {
      return this._ready;
    };
    Object.defineProperty(Sprite2.prototype, "states", {
      /**
       * Returns a collection of element's available [[SpriteState]] entries.
       *
       * @see {@link SpriteState}
       * @return States
       */
      get: function() {
        if (!this._states) {
          var state = new SpriteState();
          this._states = new DictionaryTemplate(state);
          this._disposers.push(this._states.events.on("insertKey", this.processState, this, false));
          this._disposers.push(this._states.events.on("setKey", this.processState, this, false));
          this._disposers.push(new DictionaryDisposer(this._states));
          this._disposers.push(state);
        }
        return this._states;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "hiddenState", {
      /**
       * Returns a [[SpriteState]] object for "hidden" state.
       *
       * This is a shortcut to `this.states.getKey("hidden")`.
       *
       * @return Hidden state
       */
      get: function() {
        if (!this.states.getKey("hidden")) {
          var hiddenState = this.states.create("hidden");
          hiddenState.properties.opacity = 0;
          hiddenState.properties.visible = false;
        }
        return this.states.getKey("hidden");
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "defaultState", {
      /**
       * Returns a [[SpriteState]] object for "default" state.
       *
       * This is a shortcut to `this.states.getKey("default")`.
       *
       * @return Hidden state
       */
      get: function() {
        if (!this.states.getKey("default")) {
          var defaultState = this.states.create("default");
          defaultState.properties.opacity = 1;
        }
        return this.states.getKey("default");
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.processState = function(event) {
      var state = event.newValue;
      state.sprite = this;
      state.name = event.key;
      if (this.states.hasKey("hover") || this.showTooltipOn == "hover" && (hasValue(this.tooltipHTML) || hasValue(this.tooltipText))) {
        this.hoverable = true;
      }
      if (this.states.hasKey("down") || this.showTooltipOn == "hover" && (hasValue(this.tooltipHTML) || hasValue(this.tooltipText))) {
        this.clickable = true;
      }
      if (this.states.hasKey("focus")) {
        this.focusable = true;
      }
      if (this.applyOnClones) {
        var clones = this.clones.values;
        var length_1 = clones.length;
        for (var i = 0; i < length_1; ++i) {
          var clone2 = clones[i];
          if (!clone2.isDisposed()) {
            clone2.states.setKey(state.name, state);
          }
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "animations", {
      /**
       * Returns a list elements's animations currently being played.
       *
       * If the list has not been initialized it is created.
       *
       * @return List of animations
       */
      get: function() {
        if (!this._animations) {
          this._animations = [];
          this._disposers.push(new AnimationDisposer(this._animations));
        }
        return this._animations;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.getSvgPoint = function(point) {
      try {
        var bbox = this.htmlContainer.getBoundingClientRect();
        return {
          "x": point.x - bbox.left,
          "y": point.y - bbox.top
        };
      } catch (e) {
        return point;
      }
    };
    Sprite2.prototype.animate = function(animationOptions, duration, easing) {
      return new Animation(this, animationOptions, duration, easing).start();
    };
    Sprite2.prototype.setState = function(value, transitionDuration, easing) {
      var state;
      if (value instanceof SpriteState) {
        this.states.setKey(value.name, value);
        state = value;
      } else {
        state = this.states.getKey(value);
        if (!state) {
          return;
        }
      }
      if (state.name == "hover") {
        if (this.isHidden) {
          return;
        }
        this.isHover = true;
      }
      if (state.name == "hidden") {
        this.isHiding = true;
      } else {
        if (!this.visible) {
          this.setVisibility(state.properties.visible || this.defaultState.properties.visible);
        }
      }
      if (state.name == "active") {
        this.isActive = true;
      }
      if (!isNumber(transitionDuration)) {
        transitionDuration = state.transitionDuration;
      }
      if (!hasValue(easing)) {
        easing = state.transitionEasing;
      }
      return this.transitTo(state, transitionDuration, easing);
    };
    Sprite2.prototype.applyCurrentState = function(duration) {
      var animation = this.setState(this.defaultState, duration);
      if (this.isHover) {
        animation = this.setState("hover", duration);
      }
      if (this.isDown && this.interactions.downPointers.length) {
        animation = this.setState("down", duration);
      }
      this.isFocused = this.isFocused;
      if (this.isActive) {
        animation = this.setState("active", duration);
        if (this.isHover && this.states.hasKey("hoverActive")) {
          animation = this.setState("hoverActive", duration);
        }
      }
      return animation;
    };
    Sprite2.prototype.transitTo = function(state, duration, easing) {
      var _this = this;
      var options2 = [], propValues = state.allValues, transition;
      each2(propValues, function(propertyName, finalValue) {
        var currentValue = _this[propertyName];
        if (finalValue != currentValue && _this.defaultState.properties[propertyName] == void 0) {
          _this.defaultState.properties[propertyName] = currentValue;
        }
        if (finalValue != "__unset") {
          var option = { from: currentValue, to: finalValue, property: propertyName };
          options2.push(option);
        }
      });
      if (options2.length > 0) {
        transition = this.animate(options2, duration, easing);
        if (transition && !transition.isFinished()) {
          this._disposers.push(transition.events.on("animationended", function() {
            _this.dispatchImmediately("transitionended");
          }));
        } else {
          this.dispatchImmediately("transitionended");
        }
      }
      if (state.filters.length > 0) {
        var newFilters_1 = [];
        each3(state.filters.iterator(), function(stateFilter) {
          var newFilter = stateFilter.clone();
          newFilters_1.push(newFilter);
          var animationOptions = [];
          each3(_this.filters.iterator(), function(currentFilter) {
            if (currentFilter.className == newFilter.className) {
              if (!contains(_this.defaultState.filters.iterator(), function(x) {
                return x.className === newFilter.className;
              })) {
                _this.defaultState.filters.push(currentFilter);
              }
              each2(newFilter.properties, function(propertyName, newValue) {
                var currentValue = currentFilter.properties[propertyName];
                if (currentValue != newValue) {
                  animationOptions.push({ property: propertyName, from: currentValue, to: newValue });
                }
              });
            }
          });
          newFilter.animate(animationOptions, duration, easing);
        });
        this.filters.clear();
        this.filters.pushAll(newFilters_1);
      }
      return transition;
    };
    Sprite2.prototype.isInTransition = function() {
      return this.animations.length > 0;
    };
    Object.defineProperty(Sprite2.prototype, "isHover", {
      /**
       * @return Is hovered?
       */
      get: function() {
        if (this.isInteractive()) {
          return this.interactions.isHover;
        }
        return false;
      },
      /**
       * Indicates if this element has a mouse pointer currently hovering
       * over it, or if it has any touch pointers pressed on it.
       *
       * You can force element to be "hovered" manually, by setting this property
       * to `true`.
       *
       * @param value Is hovered?
       */
      set: function(value) {
        value = toBoolean(value);
        if (value !== this.isHover) {
          if (this.isInteractive()) {
            this.interactions.isHover = value;
            if (value) {
              this.handleOver();
            } else {
              this.interactions.isRealHover = false;
              this.handleOut();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "isDragged", {
      /**
       * Returns indicator if this element is being dragged at the moment.
       *
       * @return Is dragged?
       */
      get: function() {
        return this._isDragged;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "isResized", {
      /**
       * Returns indicator if this element is being resized at the moment.
       *
       * @return Is resized?
       */
      get: function() {
        return this._isResized;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "isDown", {
      /**
       * @return Is down?
       */
      get: function() {
        if (this.isInteractive()) {
          return this.interactions.isDown;
        }
        return false;
      },
      /**
       * Indicates if this element has any pointers (mouse or touch) pressing down
       * on it.
       *
       * @param value Is down?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.isInteractive() && this.isDown != value) {
          this.interactions.isDown = value;
          if (value) {
            this.handleDown();
          } else {
            this.handleUp();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "isFocused", {
      /**
       * @return Is focused?
       */
      get: function() {
        if (this.isInteractive()) {
          return this.interactions.isFocused;
        }
        return false;
      },
      /**
       * Indicates if this element is focused (possibly by tab navigation).
       *
       * @param value Is focused?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.focusable && this.isFocused != value) {
          if (this.isInteractive()) {
            this.interactions.isFocused = value;
            if (value === true) {
              this.handleFocus();
            } else {
              this.handleBlur();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "isActive", {
      /**
       * @return Is active?
       */
      get: function() {
        return this._isActive;
      },
      /**
       * Indicates if this element is currently active (toggled on) or not
       * (toggled off).
       *
       * @param value Is active?
       */
      set: function(value) {
        this.setActive(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setActive = function(value) {
      value = toBoolean(value);
      if (this._isActive !== value) {
        this._isActive = value;
        if (value && this.states.hasKey("active")) {
          this.setState("active");
          if (this.isHover && this.states.hasKey("hoverActive")) {
            this.setState("hoverActive");
          }
        } else {
          this.applyCurrentState();
        }
        this.dispatchImmediately("toggled");
      }
    };
    Object.defineProperty(Sprite2.prototype, "disabled", {
      /**
       * @return Disabled?
       */
      get: function() {
        var current = this.getPropertyValue("disabled");
        if (hasValue(current)) {
          return current;
        } else {
          if (this.virtualParent) {
            return this.virtualParent.disabled;
          }
          if (this._parent) {
            return this._parent.disabled;
          }
        }
        return false;
      },
      /**
       * Controls if element is disabled.
       *
       * A disabled element is hidden, and is removed from any processing, layout
       * calculations, and generally treated as if it does not exist.
       *
       * The element itself is not destroyed, though. Setting this back to `false`,
       * will "resurrect" the element.
       *
       * @param value  Disabled?
       */
      set: function(value) {
        this.setDisabled(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setDisabled = function(value) {
      value = toBoolean(value);
      var current = this.getPropertyValue("disabled");
      if (current != value) {
        this.setPropertyValue("disabled", value, true);
        if (value) {
          this.parent = this._parent;
          this.removeFromInvalids();
          this.group.attr({ "display": "none" });
          this.dispatch("disabled");
        } else {
          if (this._parent) {
            var group = this._parent.element;
            if (!group.hasChild(this.group)) {
              group.add(this.group);
            }
          }
          if (this instanceof Container) {
            this.deepInvalidate();
            if (this._background) {
              this._background.invalidate();
            }
          } else {
            this.invalidate();
          }
          if (!this.__disabled) {
            this.removeSVGAttribute("display");
          }
          this.dispatch("enabled");
        }
        this.dispatch("transformed");
        system.requestFrame();
        return true;
      }
      return false;
    };
    Object.defineProperty(Sprite2.prototype, "__disabled", {
      /**
       * @ignore
       * @return Disabled?
       */
      get: function() {
        return this._internalDisabled;
      },
      /**
       * Internal disable method.
       *
       * Do not use it for disabling elements. Use `disabled` accessor instead.
       *
       * @ignore Exclude from docs
       * @param value Disabled?
       */
      set: function(value) {
        if (this._internalDisabled != value) {
          this._internalDisabled = value;
          this._updateDisabled = true;
          this.invalidatePosition();
          if (!value) {
            this.invalidate();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "numberFormatter", {
      /**
       * @return A [[NumberFormatter]] instance to be used
       */
      get: function() {
        if (this._numberFormatter) {
          return this._numberFormatter;
        } else if (this.virtualParent) {
          return this.virtualParent.numberFormatter;
        } else if (this._parent) {
          return this._parent.numberFormatter;
        }
        this._numberFormatter = new NumberFormatter();
        this._numberFormatter.language = this.language;
        return this.numberFormatter;
      },
      /**
       * ==========================================================================
       * FORMATTERS AND OTHER EXTERNAL HELPERS
       * ==========================================================================
       * @hidden
       */
      /**
       * A [[NumberFormatter]] instance.
       *
       * This is used to format numbers.
       *
       * ```TypeScript
       * chart.numberFormatter.numberFormat = "#,###.#####";
       * ```
       * ```JavaScript
       * chart.numberFormatter.numberFormat = "#,###.#####";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "numberFormatter": {
       *     "numberFormat": "#,###.#####"
       *   }
       * }
       * ```
       *
       * You can set a separate instance of formatter for each
       * individual element. However that would be unnecessary overhead as
       * all elements would automatically inherit formatter from their parents,
       * all the way up to the chart itself.
       *
       *
       * @see {@link NumberFormatter} for more info on formatting numbers
       * @param value  An instance of NumberFormatter
       */
      set: function(value) {
        this._numberFormatter = value;
        this._numberFormatter.language = this.language;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "dateFormatter", {
      /**
       * @return An instance of DateFormatter
       */
      get: function() {
        if (this._dateFormatter) {
          return this._dateFormatter;
        } else if (this.virtualParent) {
          return this.virtualParent.dateFormatter;
        } else if (this._parent) {
          return this._parent.dateFormatter;
        }
        this._dateFormatter = new DateFormatter();
        this._dateFormatter.language = this.language;
        return this.dateFormatter;
      },
      /**
       * A [[DateFormatter]] instance.
       *
       * This is used to format dates, e.g. on a date axes, balloons, etc.
       *
       * ```TypeScript
       * chart.dateFormatter.dateFormat = "yyyy-MM-dd";
       * ```
       * ```JavaScript
       * chart.dateFormatter.dateFormat = "yyyy-MM-dd";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "dateFormatter": {
       *     "dateFormat": "yyyy-MM-dd"
       *   }
       * }
       * ```
       *
       * You can set a separate instance of formatter for each
       * individual element. However that would be unnecessary overhead as
       * all elements would automatically inherit formatter from their parents,
       * all the way up to the chart itself.
       *
       * @see {@link DateFormatter} for more info on dates formatting
       * @param value  An instance of DateFormatter
       */
      set: function(value) {
        this._dateFormatter = value;
        this._dateFormatter.language = this.language;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "durationFormatter", {
      /**
       * @return An instance of DurationFormatter
       */
      get: function() {
        if (this._durationFormatter) {
          return this._durationFormatter;
        } else if (this.virtualParent) {
          return this.virtualParent.durationFormatter;
        } else if (this._parent) {
          return this._parent.durationFormatter;
        }
        this._durationFormatter = new DurationFormatter();
        this._durationFormatter.language = this.language;
        return this.durationFormatter;
      },
      /**
       * A [[DurationFormatter]] instance.
       *
       * This is used to format numbers as durations, e.g. on a value axes.
       *
       * You can set a separate instance of formatter for each
       * individual element. However that would be unnecessary overhead as
       * all elements would automatically inherit formatter from their parents,
       * all the way up to the chart itself.
       *
       * @see {@link DurationFormatter} for more info on durations
       * @param value  An instance of DurationFormatter
       */
      set: function(value) {
        this._durationFormatter = value;
        this._durationFormatter.language = this.language;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "language", {
      /**
       * @return An instance of Language
       */
      get: function() {
        var language = this._language.get();
        if (language) {
          return language;
        } else if (this.virtualParent) {
          return this.virtualParent.language;
        } else if (this._parent) {
          return this._parent.language;
        }
        language = new Language();
        this.language = language;
        return language;
      },
      /**
       * A [[Language]] instance to use for translations.
       *
       * Normally it is enough to set language for the top-most element - chart.
       *
       * All other element child elements will automatically re-use that language
       * object.
       *
       * @param value  An instance of Language
       */
      set: function(value) {
        var _this = this;
        if (this._language.get() !== value) {
          this._language.set(value, value.events.on("localechanged", function(ev) {
            if (_this._numberFormatter) {
              _this._numberFormatter.language = _this.language;
            }
            if (_this._dateFormatter) {
              _this._dateFormatter.language = _this.language;
            }
            if (_this._durationFormatter) {
              _this._durationFormatter.language = _this.language;
            }
            if (_this._exporting.get()) {
              var exporting = _this._exporting.get();
              exporting.numberFormatter.language = _this.language;
              exporting.dateFormatter.language = _this.language;
              exporting.durationFormatter.language = _this.language;
              exporting.language = _this.language;
            }
            if (_this instanceof Container) {
              _this.deepInvalidate();
            }
          }));
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.populateString = function(string, dataItem) {
      if (hasValue(string)) {
        string = castString(string);
        string = getTextFormatter().escape(string);
        var tags = string.match(/\{([^}]+)\}/g);
        var i = void 0;
        if (tags) {
          for (i = 0; i < tags.length; i++) {
            var tag = tags[i].replace(/\{([^}]+)\}/, "$1");
            var value = this.getTagValue(tag, "", dataItem);
            if (!hasValue(value)) {
              value = "";
            }
            string = string.split(tags[i]).join(value);
          }
        }
        string = getTextFormatter().unescape(string);
      } else {
        string = "";
      }
      if (!this._adapterO) {
        return string;
      } else {
        return this._adapterO.apply("populateString", string);
      }
    };
    Sprite2.prototype.getTagValue = function(tagName, format, dataItem) {
      var value;
      if (!hasValue(dataItem)) {
        dataItem = this.dataItem;
      }
      var parts = [];
      var reg = /([^.]+)\(([^)]*)\)|([^.]+)/g;
      ;
      var matches;
      while (true) {
        matches = reg.exec(tagName);
        if (matches === null) {
          break;
        }
        if (matches[3]) {
          parts.push({
            prop: matches[3]
          });
        } else {
          var params = [];
          if (trim(matches[2]) != "") {
            var reg2 = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g;
            var matches2 = void 0;
            while (true) {
              matches2 = reg2.exec(matches[2]);
              if (matches2 === null) {
                break;
              }
              params.push(matches2[1] || matches2[2] || matches2[3]);
            }
          }
          parts.push({
            method: matches[1],
            params
          });
        }
      }
      if (dataItem) {
        value = this.getTagValueFromObject(parts, dataItem.values);
        if (!hasValue(value) || isObject(value)) {
          value = this.getTagValueFromObject(parts, dataItem);
        }
        var dataContext = dataItem.dataContext;
        if (!hasValue(value) && dataContext) {
          value = this.getTagValueFromObject(parts, dataItem.dataContext);
          if (!hasValue(value)) {
            value = this.getTagValueFromObject([{
              prop: tagName
            }], dataContext);
          }
          if (!hasValue(value) && dataContext.dataContext) {
            value = this.getTagValueFromObject(parts, dataContext.dataContext);
          }
        }
        if (!hasValue(value) && dataItem.component && dataItem.component.dataItem !== dataItem) {
          value = dataItem.component.getTagValue(tagName, format);
        }
      }
      if (!hasValue(value)) {
        value = this.getTagValueFromObject(parts, this.populateStringFrom || this);
      }
      if (!hasValue(value) && this._parent) {
        value = this._parent.getTagValue(tagName, format);
      }
      return value;
    };
    Sprite2.prototype.getTagValueFromObject = function(parts, object, format) {
      var current = object;
      var formatApplied = false;
      for (var i = 0, len = parts.length; i < len; i++) {
        var part = parts[i];
        if (part.prop) {
          current = current[part.prop];
          if (!hasValue(current)) {
            return;
          }
        } else {
          switch (part.method) {
            case "formatNumber":
              var numberValue = anyToNumber(current);
              if (hasValue(numberValue)) {
                current = this.numberFormatter.format(numberValue, format || part.params[0] || void 0);
                formatApplied = true;
              }
              break;
            case "formatDate":
              var dateValue = void 0;
              if (isString(current)) {
                dateValue = this.dateFormatter.parse(current);
              } else {
                dateValue = anyToDate(current);
              }
              if (!isDate(dateValue) || isNaN2(dateValue.getTime())) {
                return;
              }
              if (hasValue(dateValue)) {
                current = this.dateFormatter.format(dateValue, format || part.params[0] || void 0);
                formatApplied = true;
              }
              break;
            case "formatDuration":
              var durationValue = anyToNumber(current);
              if (hasValue(durationValue)) {
                current = this.durationFormatter.format(durationValue, format || part.params[0] || void 0, part.params[1] || void 0);
                formatApplied = true;
              }
              break;
            case "urlEncode":
            case "encodeURIComponent":
              current = encodeURIComponent(current);
              break;
            default:
              if (current[part.method]) {
                current[part.method].apply(this, part.params);
              }
              break;
          }
        }
      }
      if (!formatApplied) {
        var formatParts = [{
          method: "",
          params: format
        }];
        if (!hasValue(format)) {
          if (isNumber(current)) {
            formatParts[0].method = "formatNumber";
            formatParts[0].params = "";
          } else if (isDate(current)) {
            formatParts[0].method = "formatDate";
            formatParts[0].params = "";
          }
        } else {
          var formatterType = getFormat(format);
          if (formatterType === NUMBER) {
            formatParts[0].method = "formatNumber";
          } else if (formatterType === DATE) {
            formatParts[0].method = "formatDate";
          } else if (formatterType === DURATION) {
            formatParts[0].method = "formatDuration";
          }
        }
        if (formatParts[0].method) {
          current = this.getTagValueFromObject(formatParts, current);
        }
      }
      return current;
    };
    Object.defineProperty(Sprite2.prototype, "dataItem", {
      /**
       * @return [[DataItem]]
       */
      get: function() {
        if (!this._dataItem) {
          if (this.virtualParent) {
            return this.virtualParent.dataItem;
          }
          if (this._parent) {
            return this._parent.dataItem;
          }
        }
        return this._dataItem;
      },
      /**
       * A [[DataItem]] to use as element's data source.
       *
       * @todo Review type
       * @param dataItem  DataItem
       */
      set: function(dataItem) {
        this.setDataItem(dataItem);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setDataItem = function(dataItem) {
      var _this = this;
      if (this._dataItem != dataItem) {
        this._dataItem = dataItem;
        if (dataItem) {
          if (this.configField) {
            var dataContext_1 = dataItem.dataContext;
            if (dataContext_1) {
              this.config = dataContext_1[this.configField];
              if (!this.config && dataContext_1.dataContext) {
                this.config = dataContext_1.dataContext[this.configField];
              }
            }
          }
          var dataContext_2 = dataItem.dataContext;
          if (dataContext_2) {
            var dataContext2_1 = dataContext_2.dataContext;
            each2(this.propertyFields, function(propertyName, fieldValue) {
              if (hasValue(dataContext_2[fieldValue])) {
                var anyThis = _this;
                anyThis[propertyName] = dataContext_2[fieldValue];
              } else {
                if (dataContext2_1) {
                  var value = dataContext2_1[fieldValue];
                  if (hasValue(value)) {
                    var anyThis = _this;
                    anyThis[propertyName] = value;
                  }
                }
              }
            });
          }
        }
        this.invalidate();
      }
    };
    Sprite2.prototype.getPropertyValue = function(propertyName) {
      var propValue = this.properties[propertyName];
      if (!this._isTemplate) {
        if (this._adapterO) {
          propValue = this._adapterO.apply(propertyName, propValue);
        }
        propValue = globalAdapter.applyAll(this, propertyName, propValue);
      }
      return propValue;
    };
    Sprite2.prototype.setColorProperty = function(property, value, invalidate) {
      var currentValue = this.properties[property];
      if (value instanceof Color && currentValue instanceof Color && value.toString() == currentValue.toString()) {
        return false;
      } else {
        return this.setPropertyValue(property, value, invalidate);
      }
    };
    Sprite2.prototype.setPercentProperty = function(property, value, invalidate, transform, precision, floor) {
      value = toNumberOrPercent(value);
      if (isNumber(value)) {
        if (isNumber(precision)) {
          value = round(value, precision, floor);
        }
        return this.setPropertyValue(property, value, invalidate, transform);
      } else {
        var currentValue = this.properties[property];
        if (value instanceof Percent && currentValue instanceof Percent && value.value == currentValue.value) {
          return false;
        } else {
          return this.setPropertyValue(property, value, invalidate, transform);
        }
      }
    };
    Sprite2.prototype.setPropertyValue = function(property, value, invalidate, transform) {
      if (this.properties[property] !== value && !this.isDisposed()) {
        this.properties[property] = value;
        if (this.events.isEnabled("propertychanged")) {
          var event_1 = {
            type: "propertychanged",
            target: this,
            property
          };
          this.events.dispatchImmediately("propertychanged", event_1);
        }
        if (invalidate) {
          this.invalidate();
        }
        if (transform) {
          this.invalidatePosition();
        }
        if (this.applyOnClones) {
          var clones = this.clones.values;
          var length_2 = clones.length;
          for (var i = 0; i < length_2; ++i) {
            var clone2 = clones[i];
            if (!clone2.isDisposed()) {
              clone2[property] = value;
            }
          }
        }
        return true;
      }
      return false;
    };
    Sprite2.prototype.bind = function(property, source, bindToProperty, modifier) {
      var _this = this;
      if (bindToProperty === void 0) {
        bindToProperty = property;
      }
      if (hasValue(this._bindings[property])) {
        this._bindings[property].dispose();
      }
      this[property] = source[bindToProperty];
      this._bindings[property] = source.events.on("propertychanged", function(event) {
        if (event.property === bindToProperty) {
          var value = source[bindToProperty];
          if (modifier) {
            value = modifier(value);
          }
          _this[property] = value;
        }
      });
    };
    Sprite2.prototype.observe = function(property, listener, context, shouldClone) {
      var _this = this;
      return new MultiDisposer(map(toArray(property), function(prop) {
        return _this.events.on("propertychanged", function(e) {
          if (e.property === prop) {
            listener.call(context, e);
          }
        }, context, shouldClone);
      }));
    };
    Sprite2.prototype.applyAccessibility = function() {
      var title = this.readerTitle, description = this.readerDescription, role = this.role, hidden = this.readerHidden, checked = this.readerChecked, controls = this.readerControls, live = this.readerLive, orientation = this.readerOrientation, valueNow = this.readerValueNow, valueText = this.readerValueText;
      var labelledByIds = [];
      var describedByIds = [];
      var labelledBy = this.readerLabelledBy;
      if (labelledBy) {
        labelledByIds.push(labelledBy);
      }
      var describedBy = this.readerDescribedBy;
      if (describedBy) {
        describedByIds.push(describedBy);
      }
      if (title) {
        if (labelledByIds.length || this.showSystemTooltip) {
          var titleElement = this.titleElement;
          var titleId = this.uid + "-title";
          if (titleElement.node.textContent != title) {
            titleElement.node.textContent = title;
            titleElement.attr({ id: titleId });
          }
          labelledByIds.push(titleId);
        } else {
          if (this._titleElement) {
            this.group.removeElement(this._titleElement);
            this._titleElement = void 0;
          }
          this.setSVGAttribute({
            "aria-label": title
          });
        }
      } else {
        this.removeSVGAttribute("aria-label");
        if (this._titleElement) {
          this.group.removeElement(this._titleElement);
          this._titleElement = void 0;
        }
      }
      if (description) {
        var descriptionElement = this.descriptionElement;
        var descriptionId = this.uid + "-description";
        if (descriptionElement.node.textContent != description) {
          descriptionElement.node.textContent = description;
          descriptionElement.attr({ id: descriptionId });
        }
        describedByIds.push(descriptionId);
      } else if (this._descriptionElement) {
        this.group.removeElement(this._descriptionElement);
        this._descriptionElement = void 0;
      }
      if (labelledByIds.length) {
        this.setSVGAttribute({ "aria-labelledby": labelledByIds.join(" ") });
      } else {
        this.removeSVGAttribute("aria-labelledby");
      }
      if (describedByIds.length) {
        this.setSVGAttribute({ "aria-describedby": describedByIds.join(" ") });
      } else {
        this.removeSVGAttribute("aria-describedby");
      }
      if (role) {
        this.setSVGAttribute({ "role": role });
      } else {
        this.removeSVGAttribute("role");
      }
      if (hidden) {
        this.setSVGAttribute({ "aria-hidden": "true" });
      } else {
        this.removeSVGAttribute("aria-hidden");
      }
      if (checked) {
        this.setSVGAttribute({ "aria-checked": "true" });
      } else if (checked === false) {
        this.setSVGAttribute({ "aria-checked": "false" });
      } else {
        this.removeSVGAttribute("aria-checked");
      }
      if (controls) {
        this.setSVGAttribute({ "aria-controls": controls });
      } else {
        this.removeSVGAttribute("aria-controls");
      }
      if (live) {
        this.setSVGAttribute({ "aria-live": live });
      } else {
        this.removeSVGAttribute("aria-live");
      }
      if (orientation) {
        this.setSVGAttribute({ "aria-orientation": orientation });
      } else {
        this.removeSVGAttribute("aria-orientation");
      }
      if (valueNow) {
        this.setSVGAttribute({ "aria-valuenow": valueNow });
      } else {
        this.removeSVGAttribute("aria-valuenow");
      }
      if (valueText) {
        this.setSVGAttribute({ "aria-valuetext": valueText });
      } else {
        this.removeSVGAttribute("aria-valuetext");
      }
    };
    Object.defineProperty(Sprite2.prototype, "readerTitle", {
      /**
       * @return Title
       */
      get: function() {
        var title = this.getPropertyValue("readerTitle");
        if (hasValue(title) && this.dataItem) {
          return this.populateString(title);
        }
        return title;
      },
      /**
       * Screen reader title of the element.
       *
       * @param value Title
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerTitle", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerDescription", {
      /**
       * @return Description
       */
      get: function() {
        var description = this.getPropertyValue("readerDescription");
        if (hasValue(description) && this.dataItem) {
          return this.populateString(description);
        }
        return this.getPropertyValue("readerDescription");
      },
      /**
       * Screen reader description of the element.
       *
       * @param value Description
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerDescription", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "role", {
      /**
       * @return Role
       */
      get: function() {
        return this.getPropertyValue("role");
      },
      /**
       * A WAI-ARIA role for the element.
       *
       * @see {@link https://www.w3.org/TR/wai-aria-1.1/#role_definitions} for more information on WAI-ARIA roles
       * @param value  Role
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("role", value)) {
          this.applyAccessibility();
          if (value == "slider") {
            this.setSVGAttribute({ "aria-valuemin": "0" });
            this.setSVGAttribute({ "aria-valuemax": "100" });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerHidden", {
      /**
       * @return Hidden?
       */
      get: function() {
        return this.getPropertyValue("readerHidden");
      },
      /**
       * Controls if element should be hidden from screen readers.
       *
       * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-hidden} for more information
       * @param value  Hidden?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("readerHidden", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerChecked", {
      /**
       * @ignore Exclude from docs
       * @return Checked?
       */
      get: function() {
        return this.getPropertyValue("readerChecked");
      },
      /**
       * Controls if element is currently marked as "checked".
       *
       * @ignore Exclude from docs
       * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-checked} for more information
       * @param value Checked?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("readerChecked", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerControls", {
      /**
       * @ignore Exclude from docs
       * @return Setting value
       */
      get: function() {
        return this.getPropertyValue("readerControls");
      },
      /**
       * A `uid` of an element this element controls.
       *
       * @ignore Exclude from docs
       * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-controls} for more information
       * @param value Setting value
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerControls", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerLive", {
      /**
       * @ignore Exclude from docs
       * @return Setting value
       */
      get: function() {
        return this.getPropertyValue("readerLive");
      },
      /**
       * Controls accessibility setting "aria-live" for the element.
       *
       * @ignore Exclude from docs
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions} for more information
       * @param value Setting value
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerLive", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerLabelledBy", {
      /**
       * @ignore Exclude from docs
       * @return Target element
       */
      get: function() {
        return this.getPropertyValue("readerLabelledBy");
      },
      /**
       * A `uid` of an element that describes this element.
       *
       * @ignore Exclude from docs
       * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-labelledby} for more information
       * @param value Target element
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerLabelledBy", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerDescribedBy", {
      /**
       * @ignore Exclude from docs
       * @return Target element
       */
      get: function() {
        return this.getPropertyValue("readerDescribedBy");
      },
      /**
       * A `uid` of an element that describes this element.
       *
       * @ignore Exclude from docs
       * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-describedby} for more information
       * @param value Target element
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerDescribedBy", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerOrientation", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("readerOrientation");
      },
      /**
       * Orientation of the element.
       *
       * @since 4.7.16
       * @param value Orientation
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerOrientation", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerValueNow", {
      /**
       * @return Current value
       */
      get: function() {
        return this.getPropertyValue("readerValueNow");
      },
      /**
       * Current value of the element.
       *
       * @since 4.7.16
       * @param value Current value
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerValueNow", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "readerValueText", {
      /**
       * @return Current value (text)
       */
      get: function() {
        return this.getPropertyValue("readerValueText");
      },
      /**
       * Text representation of the current value of the element.
       *
       * @since 4.7.16
       * @param value Current value (text)
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerValueText", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "keyboardOptions", {
      /**
       * ==========================================================================
       * USER INTERACTIONS
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns elements keyboard options.
       *
       * @return Keyboard options
       */
      get: function() {
        if (!this.interactions.keyboardOptions) {
          if (this.virtualParent) {
            return this.virtualParent.keyboardOptions;
          }
          if (this._parent) {
            return this._parent.keyboardOptions;
          }
        }
        return this.interactions.keyboardOptions;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "mouseOptions", {
      /**
       * Mouse options.
       *
       * Enables controlling options related to the mouse, for example sensitivity
       * of its mouse wheel.
       *
       * E.g. the below will reduce chart's wheel-zoom speed to half its default
       * speed:
       *
       * ```TypeScript
       * chart.plotContainer.mouseOptions.sensitivity = 0.5;
       * ```
       * ```JavaScript
       * chart.plotContainer.mouseOptions.sensitivity = 0.5;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "plotContainer": {
       *     "mouseOptions": {
       *       "sensitivity": 0.5
       *     }
       *   }
       * }
       * ```
       *
       * @return Mouse options
       */
      get: function() {
        if (!this.interactions.mouseOptions) {
          if (this.virtualParent) {
            return this.virtualParent.mouseOptions;
          }
          if (this._parent) {
            return this._parent.mouseOptions;
          }
        }
        return this.interactions.mouseOptions;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "interactions", {
      /**
       * Returns (creates if necessary) an [[InteractionObject]] associated with
       * this element.
       *
       * [[InteractionObject]] is used to attach all kinds of user-interactions to
       * the element, e.g. click/touch, dragging, hovering, and similar events.
       *
       * @return Interaction object
       */
      get: function() {
        if (!this._interaction) {
          var interaction2 = getInteraction().getInteraction(this.dom);
          this._interaction = interaction2;
          interaction2.clickable = this.clickable;
          interaction2.hoverable = this.hoverable;
          interaction2.trackable = this.trackable;
          interaction2.draggable = this.draggable;
          interaction2.swipeable = this.swipeable;
          interaction2.resizable = this.resizable;
          interaction2.wheelable = this.wheelable;
          interaction2.contextMenuDisabled = this.contextMenuDisabled;
          interaction2.inert = this.inert;
          interaction2.sprite = this;
          this._disposers.push(interaction2);
        }
        return this._interaction;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.isInteractive = function() {
      if (this._interaction) {
        return true;
      } else {
        return false;
      }
    };
    Object.defineProperty(Sprite2.prototype, "focusable", {
      /**
       * @return Can element be focused?
       */
      get: function() {
        return this.getPropertyValue("focusable");
      },
      /**
       * ==========================================================================
       * ELEMENT FOCUS-RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Controls if the element can gain focus.
       *
       * Focusable element will be selectable via TAB key.
       *
       * Please note, clicking it with a mouse or touching will not add focus to
       * it.
       *
       * Focused element will show a system-specific highlight, which might ruin
       * the overal look. This is why we don't focus element on click/touch.
       *
       * A default setting varies for different elements. By default all elements
       * are not focusable, except certain items like buttons, legend items, etc.
       *
       * @default undefined (auto)
       * @param value  Can element be focused?
       */
      set: function(value) {
        var _this = this;
        value = toBoolean(value);
        if (this.setPropertyValue("focusable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.interactions.focusable = value;
            if (value) {
              this.setSVGAttribute({ "focusable": value });
              if (!hasValue(this._tabindex)) {
                this.tabindex = 0;
              }
            } else {
              this.removeSVGAttribute("focusable");
              this.tabindex = void 0;
            }
            this.interactions.setEventDisposer("sprite-focusable", value, function() {
              return new MultiDisposer([
                _this.events.on("blur", _this.handleBlur, _this, false),
                _this.events.on("focus", _this.handleFocus, _this, false)
              ]);
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleFocus = function(ev) {
      if (this.focusable) {
        if (this.topParent) {
          this.topParent.hasFocused = true;
          this.topParent.focusedElement = this;
        }
        if (this.focusFilter) {
          this.filters.push(this.focusFilter);
        }
        if (this.hoverOnFocus) {
          this.isHover = true;
          this.handleOver();
        }
      }
    };
    Sprite2.prototype.handleBlur = function(ev) {
      if (this.focusable) {
        if (this.topParent) {
          this.topParent.hasFocused = false;
          this.topParent.focusedElement = void 0;
        }
        if (this.focusFilter) {
          this.filters.removeValue(this.focusFilter);
        }
        if (this.hoverOnFocus) {
          this.isHover = false;
          this.handleOut();
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "focusFilter", {
      /**
       * A reference to a [[Filter]] to apply to element when it gains focus.
       *
       * Normally, browsers will draw a default ugly square around focused element,
       * which totally makes sense because its purpose is to help identify active
       * element for visually impaired people.
       *
       * However, if you would rather apply a filter, so you can modify how focused
       * element looks like, use `focusFilter`.
       *
       * Simply set it to an anstance of [[FocusFilter]], or any other filter
       * object.
       *
       * ```TypeScript
       * chart.focusFilter = new am4core.FocusFilter();
       * ```
       * ```JavaScript
       * chart.focusFilter = new am4core.FocusFilter();
       * ```
       * ```JSON
       * {
       *   // ...
       *   "focusFilter": {
       *     "type": "FocusFilter"
       *   },
       *   // ...
       * }
       * ```
       *
       * @see {@link Filter}
       * @see {@link https://www.amcharts.com/docs/v4/concepts/accessibility/} more about accessibility
       * @see {@link https://www.amcharts.com/docs/v4/tutorials/changing-appearance-of-focused-items/} cusomizing focus appearance
       * @ignore Exclude from docs
       * @return Focused element filter
       */
      get: function() {
        var focusFilter = this._focusFilter;
        if (focusFilter) {
          return focusFilter;
        }
        if (this.virtualParent) {
          return this.virtualParent.focusFilter;
        } else if (this._parent) {
          return this._parent.focusFilter;
        }
      },
      /**
       * @see {@link Filter}
       * @ignore Exclude from docs
       * @todo This is still experimental, don't use it
       */
      set: function(value) {
        this._focusFilter = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "hoverOnFocus", {
      /**
       * @return Trigger hover on focus?
       */
      get: function() {
        return this.getPropertyValue("hoverOnFocus");
      },
      /**
       * If set to `true`, this element will also trigger `"over"` event with all
       * the related consequences, like "hover" state being applied and tooltip
       * being shown.
       *
       * Useful as an accessibility feature to display rollover tooltips on items
       * selected via keyboard.
       *
       * @param value  Trigger hover on focus?
       * @default false
       */
      set: function(value) {
        if (value !== this.hoverOnFocus) {
          this.setPropertyValue("hoverOnFocus", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tabindex", {
      /**
       * @return TAB index
       */
      get: function() {
        var index = this._tabindex;
        if (index != null) {
          return index;
        } else if (this.virtualParent) {
          return this.virtualParent.tabindex;
        } else if (this._parent) {
          return this._parent.tabindex;
        }
      },
      /**
       * Sets or returns TAB index.
       *
       * Tab index maintains the order in which focusable elements gain focus when
       * TAB key is pressed.
       *
       * Please note, tab index is not local to the chart. It affects the whole
       * of the page, including non-SVG elements. Maintain extreme causion when
       * setting tab indexes, as it affects the user experience for the whole
       * web page.
       *
       * @param value TAB index
       */
      set: function(value) {
        value = toNumber(value);
        if (this.setPropertyValue("tabindex", value) && isNumber(value)) {
          this.interactions.tabindex = value;
          this.setSVGAttribute({ "tabindex": value });
          this._tabindex = value;
          this.focusable = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "inertiaOptions", {
      /**
       * ==========================================================================
       * DRAGGING AND RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns element's options to be used for inertia. This setting is
       * inheritable, meaning that if not set directly, it will search in all its
       * ascendants until very top.
       *
       * Inertia is used only if element's `inert` is set to `true`.
       *
       * "Inert" element, when dragged and released, will carry the momentum of the
       * movement, and will continue moving in the same drag direction, gradually
       * reducing in speed until finally stops.
       *
       * Check [[IInertiaOptions]] for how you tweak inertia animations.
       *
       * @return Inertia options
       */
      get: function() {
        if (!this.interactions.inertiaOptions) {
          if (this._parent) {
            return this._parent.inertiaOptions;
          }
        }
        return this.interactions.inertiaOptions;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "draggable", {
      /**
       * @return `true` if element can be dragged
       */
      get: function() {
        return this.getPropertyValue("draggable");
      },
      /**
       * Controls if the element is draggable.
       *
       * @param value  `true` if element can be dragged
       */
      set: function(value) {
        var _this = this;
        value = toBoolean(value);
        if (this.setPropertyValue("draggable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.applyCursorStyle();
            this.interactions.draggable = value;
            this.interactions.setEventDisposer("sprite-draggable", value, function() {
              return new MultiDisposer([
                _this.events.on("down", _this.handleDown, _this, false),
                _this.events.on("dragstart", _this.handleDragStart, _this, false),
                _this.events.on("drag", _this.handleDragMove, _this, false),
                _this.events.on("dragstop", _this.handleDragStop, _this, false)
              ]);
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleDragStart = function(ev) {
      if (!this.interactions.isTouchProtected || !ev.touch) {
        this.interactions.originalPosition = {
          x: this.pixelX,
          y: this.pixelY
        };
        this._isDragged = true;
        this.hideTooltip(0);
      }
    };
    Sprite2.prototype.dragStart = function(pointer) {
      this._isDragged = true;
      getInteraction().dragStart(this.interactions, pointer);
    };
    Sprite2.prototype.handleDragStop = function(ev) {
      if (!this.interactions.isTouchProtected || !ev.touch) {
        this._isDragged = false;
        this.showTooltip();
        this.interactions.originalPosition = void 0;
      }
    };
    Sprite2.prototype.dragStop = function(pointer, cancelled) {
      this._isDragged = false;
      getInteraction().dragStop(this.interactions, pointer, cancelled);
    };
    Sprite2.prototype.handleDragMove = function(ev) {
      if (!this.interactions.isTouchProtected || !ev.touch) {
        var point = this.interactions.originalPosition;
        if (point && this._isDragged) {
          var globalScale = this._parent.globalScale * this.svgContainer.cssScale;
          this.moveTo({ x: point.x + ev.shift.x / globalScale, y: point.y + ev.shift.y / globalScale }, void 0, void 0, true);
        }
        this.dispatchImmediately("dragged", ev);
      }
    };
    Object.defineProperty(Sprite2.prototype, "inert", {
      /**
       * @return `true` if element should use inertia when animated
       */
      get: function() {
        return this.getPropertyValue("inert");
      },
      /**
       * Controls if the element should use inertia when interacted with.
       *
       * "Inert" element, when dragged and released, will carry the momentum of the
       * movement, and will continue moving in the same drag direction, gradually
       * reducing in speed until finally stops.
       *
       * @default false
       * @param value `true` if element should use inertia when animated
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("inert", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.interactions.inert = value;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "hoverOptions", {
      /**
       * ==========================================================================
       * HOVERING
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns Sprite's hover options.
       *
       * @see {@link IHoverOptions} for available options.
       * @return Options
       */
      get: function() {
        if (!this.interactions.hoverOptions) {
          if (this.virtualParent) {
            return this.virtualParent.hoverOptions;
          }
          if (this._parent) {
            return this._parent.hoverOptions;
          }
        }
        return this.interactions.hoverOptions;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "hoverable", {
      /**
       * @return `true` if element is hoverable
       */
      get: function() {
        return this.getPropertyValue("hoverable");
      },
      /**
       * Controls if the element is hoverable (hover events are registered).
       *
       * Use `over` and `out` events, to watch for those respective actions.
       *
       * @default false
       * @param value `true` if element can be hovered
       */
      set: function(value) {
        var _this = this;
        value = toBoolean(value);
        if (this.setPropertyValue("hoverable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.applyCursorStyle();
            this.interactions.hoverable = value;
            this.interactions.setEventDisposer("sprite-hoverable", value, function() {
              return new MultiDisposer([
                _this.events.on("over", _this.handleOver, _this, false),
                _this.events.on("out", _this.handleOut, _this, false)
              ]);
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleOver = function(ev) {
      if (this._outTimeout) {
        this._outTimeout.dispose();
      }
      if (this.isHover) {
        if (this.states.hasKey("hover")) {
          if (!this.isHidden) {
            this.applyCurrentState();
          }
        }
        var point = void 0;
        if (ev && ev.pointer) {
          point = documentPointToSvg(ev.pointer.point, this.svgContainer.SVGContainer, this.svgContainer.cssScale);
        }
        if (this.showTooltipOn == "hover") {
          this.showTooltip(point);
        }
      } else {
        if (this.showTooltipOn == "hover") {
          this.hideTooltip();
        }
        if (!this.isHidden && this.states.hasKey("hover")) {
          this.applyCurrentState();
        }
      }
    };
    Sprite2.prototype.handleOut = function(ev) {
      var _this = this;
      if (this.tooltip && this.tooltip.targetSprite == this && this.tooltip.keepTargetHover) {
        this._outTimeout = this.setTimeout(function() {
          if (!_this.tooltip.isHover) {
            if (_this.tooltip.targetSprite == _this) {
              _this.hideTooltip();
            }
            _this._outTimeout = _this.setTimeout(_this.handleOutReal.bind(_this), _this.rollOutDelay);
          }
        }, 10);
        return;
      }
      if (this.showTooltipOn == "hover") {
        this.hideTooltip();
      }
      this._outTimeout = this.setTimeout(this.handleOutReal.bind(this), this.rollOutDelay);
    };
    Sprite2.prototype.handleOutReal = function() {
      if (!this.isHidden && !this.isHiding && this.states.hasKey("hover")) {
        this.applyCurrentState();
      }
    };
    Object.defineProperty(Sprite2.prototype, "hitOptions", {
      /**
       * ==========================================================================
       * CLICKING/TAPPING AND TOGGLING STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns Sprite's click (hit) options.
       *
       * Click (hit) options control things like double-click, timeouts, etc.
       *
       * @see {@link IHitOptions} for available options.
       * @return Options
       */
      get: function() {
        if (!this.interactions.hitOptions) {
          if (this.virtualParent) {
            return this.virtualParent.hitOptions;
          }
          if (this._parent) {
            return this._parent.hitOptions;
          }
        }
        return this.interactions.hitOptions;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleDown = function(ev) {
      if (this.interactions.downPointers.length === 1) {
        this.interactions.originalPosition = {
          x: this.pixelX,
          y: this.pixelY
        };
        this.interactions.originalAngle = this.rotation;
        this.interactions.originalScale = this.scale;
        if (this.states.hasKey("down")) {
          this.setState("down");
        }
      }
    };
    Sprite2.prototype.handleUp = function(ev) {
      var _this = this;
      this._isResized = false;
      if (this.states.hasKey("down")) {
        this.applyCurrentState();
      }
      if (this.showTooltipOn == "hit") {
        this.updateTooltipPosition(ev.pointer ? ev.pointer.point : void 0);
        this._disposers.push(registry.events.once("exitframe", function() {
          _this.showTooltip();
        }));
        this._disposers.push(getInteraction().body.events.once("down", function(ev2) {
          _this.hideTooltip();
        }));
      }
    };
    Object.defineProperty(Sprite2.prototype, "clickable", {
      /**
       * @return {boolean}
       */
      get: function() {
        return this.getPropertyValue("clickable");
      },
      /**
       * Indicates if the element is clickable.
       *
       * Some type of the elements, like buttons are clickable by default.
       *
       * Most of the elements are not clickable by default.
       *
       * Use `hit`, `doublehit`, `up`, `down`, `toggled` events to watch for
       * respective click/touch actions.
       *
       * @param value `true` if element can be clicked
       */
      set: function(value) {
        var _this = this;
        value = toBoolean(value);
        if (this.setPropertyValue("clickable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.applyCursorStyle();
            this.interactions.clickable = value;
            this.interactions.setEventDisposer("sprite-clickable", value, function() {
              return new MultiDisposer([
                _this.events.on("down", _this.handleDown, _this, false),
                _this.events.on("up", _this.handleUp, _this, false)
              ]);
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "togglable", {
      /**
       * @return Is togglable?
       */
      get: function() {
        return this.getPropertyValue("togglable");
      },
      /**
       * Indicates if element can be toggled on and off by subsequent clicks/taps.
       *
       * Togglable element will alternate its `isActive` property between `true`
       * and `false` with each click.
       *
       * @param value Is togglable?
       */
      set: function(value) {
        var _this = this;
        value = toBoolean(value);
        if (this.setPropertyValue("togglable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.interactions.setEventDisposer("sprite-togglable", value, function() {
              return _this.events.on("hit", _this.handleToggle, _this, false);
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleToggle = function(ev) {
      this.isActive = !this.isActive;
    };
    Object.defineProperty(Sprite2.prototype, "contextMenuDisabled", {
      /**
       * @return Context menu disabled?
       */
      get: function() {
        return this.getPropertyValue("contextMenuDisabled");
      },
      /**
       * Should element prevent context menu to be displayed, e.g. when
       * right-clicked?
       *
       * @default false
       * @param value Context menu disabled?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("contextMenuDisabled", value)) {
          this.interactions.contextMenuDisabled = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "url", {
      /**
       * @return URL
       */
      get: function() {
        return this.getPropertyValue("url");
      },
      /**
       * Click-through URL for this element.
       *
       * If set, clicking/tapping this element will open the new URL in a target
       * window/tab as set by `urlTarget`.
       *
       * Please note that URL will be parsed by data placeholders in curly
       * brackets, to be populated from data. E.g.:
       *
       * ```TypeScript
       * series.columns.template.url = "https://www.google.com/search?q={category.urlEncode()}";
       * ```
       * ```JavaScript
       * series.columns.template.url = "https://www.google.com/search?q={category.urlEncode()}";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "columns": {
       *       "url": "https://www.google.com/search?q={category.urlEncode()}"
       *     }
       *   }]
       * }
       * ```
       *
       * @param value URL
       */
      set: function(value) {
        if (this.setPropertyValue("url", value)) {
          if (this._urlDisposer) {
            this._urlDisposer.dispose();
          }
          if (isNotEmpty(value)) {
            this._urlDisposer = this.events.on("hit", this.urlHandler, this, false);
            this.clickable = true;
            this.cursorOverStyle = MouseCursorStyle.pointer;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "baseId", {
      /**
       * [baseId description]
       *
       * @ignore
       * @return [description]
       */
      get: function() {
        if (!this._baseId && this._parent) {
          this.baseId = this._parent.baseId;
        }
        return this._baseId;
      },
      /**
       * [baseId description]
       *
       * @ignore
       * @param  value  [description]
       */
      set: function(value) {
        this.setBaseId(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setBaseId = function(value) {
      if (value != this._baseId) {
        if (this.invalid) {
          this.invalid = false;
          registry.removeFromInvalidSprites(this);
          this.invalidate();
        }
        this._baseId = value;
      }
    };
    Object.defineProperty(Sprite2.prototype, "baseSprite", {
      /**
       * Returns the mail chart object that this element belongs to.
       *
       * In most cases it will mean the chart object.
       *
       * Can be used to retrieve chart object in various events and adapters.
       *
       * ```TypeScript
       * chart.seriesContainer.events.on("hit", function(ev) {
       *   console.log(ev.target.baseSprite);
       * });
       * ```
       * ```JavaScript
       * chart.seriesContainer.events.on("hit", function(ev) {
       *   console.log(ev.target.baseSprite);
       * });
       * ```
       * ```JSON
       * {
       *   // ...
       *   "seriesContainer": {
       *     "events": {
       *       "hit": function(ev) {
       *         console.log(ev.target.baseSprite);
       *       }
       *     }
       *   }
       * }
       * ```
       *
       * @readonly
       * @return  Base chart object
       */
      get: function() {
        if (this.isBaseSprite) {
          return this;
        } else if (this._parent) {
          return this._parent.baseSprite;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "urlTarget", {
      /**
       * @return URL target
       */
      get: function() {
        return this.getPropertyValue("urlTarget");
      },
      /**
       * Target to use for URL clicks:
       *
       * * _blank
       * * _self (default)
       * * _parent
       * * _top
       * * Name of the window/frame
       *
       * Ignored if `url` is not set.
       *
       * @param value URL target
       */
      set: function(value) {
        this.setPropertyValue("urlTarget", value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.urlHandler = function(ev) {
      if (isNotEmpty(this.url)) {
        var url = this.populateString(this.url);
        if (this.urlTarget === "_self") {
          window.location.href = url;
        } else {
          window.open(url, this.urlTarget);
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "swipeOptions", {
      /**
       * ==========================================================================
       * SWIPING GESTURE TRACKING
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns element's swipe gesture options.
       *
       * @return Swipe gesture options
       */
      get: function() {
        if (!this.interactions.swipeOptions) {
          if (this.virtualParent) {
            return this.virtualParent.swipeOptions;
          }
          if (this._parent) {
            return this._parent.swipeOptions;
          }
        }
        return this.interactions.swipeOptions;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "swipeable", {
      /**
       * @return Element swipable?
       */
      get: function() {
        return this.getPropertyValue("swipeable");
      },
      /**
       * Controls if element is swipeable.
       *
       * Swipable element will invoke `swipe`, `swipeleft` and `swiperight` events,
       * when quick horizontal drag action is performed with either mouse or touch.
       *
       * Please note that combining swipe and drag is possible, however will incur
       * a slight but noticeable delay in drag start.
       *
       * @param value  Element swipable?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("swipeable", value)) {
          this.applyCursorStyle();
          if (!value && !this.isInteractive()) {
          } else {
            this.interactions.swipeable = value;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "trackable", {
      /**
       * @return Track cursor movement over element?
       */
      get: function() {
        return this.getPropertyValue("trackable");
      },
      /**
       * ==========================================================================
       * POINTER TRACKING
       * ==========================================================================
       * @hidden
       */
      /**
       * Indicates if the element is trackable (mouse position over it is reported to
       * event listeners).
       *
       * Will invoke `track` events whenever pointer (cursor) changes position
       * while over element.
       *
       * Please note, touch devices will also invoke `track` events when touch
       * point is moved while holding down on a trackable element.
       *
       * @param value Track cursor movement over element?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("trackable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.applyCursorStyle();
            this.interactions.trackable = value;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "wheelable", {
      /**
       * @return Mouse wheel events enabled?
       */
      get: function() {
        return this.getPropertyValue("wheelable");
      },
      /**
       * ==========================================================================
       * MOUSE-WHEEL RELATED
       * ==========================================================================
       * @hidden
       */
      /**
       * Indicates if the element can be interacted with mouse wheel.
       *
       * Will invoke `wheel`, `wheelup`, `wheeldown`, `wheelleft`, and `wheelright`
       * events when using mouse wheel over the element.
       *
       * @param value Mouse wheel events enabled?
       */
      set: function(value) {
        if (this.setPropertyValue("wheelable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.applyCursorStyle();
            this.interactions.wheelable = value;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "resizable", {
      /**
       * @return Element resizable?
       */
      get: function() {
        return this.getPropertyValue("resizable");
      },
      /**
       * ==========================================================================
       * RESIZE
       * ==========================================================================
       * @hidden
       */
      /**
       * Indicates if this element is resizable.
       *
       * Enabling resize will turn on various interactions on the element. Their
       * actual functionality will depend on other properties.
       *
       * If the element also `draggable`, resize will only happen with two points
       * of contact on a touch device.
       *
       * If the element is not draggable, resize can be performed with just one
       * point of contact, touch or mouse.
       *
       * Will invoke `resize` event every time the size of the element changes.
       *
       * @param value  Element resizable?
       */
      set: function(value) {
        var _this = this;
        value = toBoolean(value);
        if (this.setPropertyValue("resizable", value)) {
          if (!value && !this.isInteractive()) {
          } else {
            this.applyCursorStyle();
            this.interactions.resizable = value;
            this.interactions.setEventDisposer("sprite-resizable", value, function() {
              return new MultiDisposer([
                _this.events.on("down", _this.handleDown, _this, false),
                _this.events.on("resize", _this.handleResize, _this, false)
              ]);
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.handleResize = function(ev) {
      if (!this.interactions.isTouchProtected || !ev.touch) {
        this._isResized = true;
        this.scale = this.interactions.originalScale * ev.scale;
        this.validatePosition();
        if (this.draggable || this.dragWhileResize) {
          this._isDragged = false;
          var svgPoint1 = documentPointToSvg(ev.point1, this.htmlContainer, this.svgContainer.cssScale);
          var svgPoint2 = documentPointToSvg(ev.point2, this.htmlContainer, this.svgContainer.cssScale);
          var svgMidPoint = getMidPoint(svgPoint1, svgPoint2);
          var parentPoint1 = documentPointToSprite(ev.startPoint1, this._parent);
          var parentPoint2 = documentPointToSprite(ev.startPoint2, this._parent);
          var originalPosition = this.interactions.originalPosition;
          var originalScale = this.interactions.originalScale;
          if (originalPosition) {
            var spritePoint1 = { x: (parentPoint1.x - originalPosition.x) / originalScale, y: (parentPoint1.y - originalPosition.y) / originalScale };
            var spritePoint2 = { x: (parentPoint2.x - originalPosition.x) / originalScale, y: (parentPoint2.y - originalPosition.y) / originalScale };
            var spriteMidPoint = getMidPoint(spritePoint1, spritePoint2);
            var parentPoint = svgPointToSprite(svgMidPoint, this._parent);
            this.moveTo({ x: parentPoint.x - spriteMidPoint.x * this.scale, y: parentPoint.y - spriteMidPoint.y * this.scale }, void 0, void 0, true);
          }
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "cursorOptions", {
      /**
       * ==========================================================================
       * MOUSE-RELATED
       * ==========================================================================
       * @hidden
       */
      /**
       * Returns element's cursor options.
       *
       * Cursor options usually define cursor style for various states of the
       * hovered element.
       *
       * Elements inherit `cursorOptions` from their parents if they don't have
       * them set explicitly.
       *
       * @see {@link ICursorOptions} for a list of available options
       * @return Cursor options
       */
      get: function() {
        if (!this.interactions.cursorOptions) {
          if (this.virtualParent) {
            return this.virtualParent.cursorOptions;
          }
          if (this._parent) {
            return this._parent.cursorOptions;
          }
        }
        return this.interactions.cursorOptions;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "cursorOverStyle", {
      /**
       * A shortcut to setting mouse cursor on hover.
       *
       * Example:
       *
       * ```TypeScript
       * series.slices.template.cursorOverStyle = am4core.MouseCursorStyle.pointer;
       * ```
       * ```JavaScript
       * series.slices.template.cursorOverStyle = am4core.MouseCursorStyle.pointer;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": {
       *     // ...
       *     "slices": {
       *       "cursorOverStyle": "pointer"
       *     }
       *   }
       * }
       * ```
       *
       * @param style An array of styles to apply onhover
       */
      set: function(style) {
        if (!this.cursorOptions.overStyle) {
          this.interactions.cursorOptions = {
            defaultStyle: this.cursorOptions.defaultStyle
          };
        }
        this.cursorOptions.overStyle = style;
        getInteraction().applyCursorOverStyle(this.interactions);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "cursorDownStyle", {
      /**
       * A shortcut to setting mouse cursor when button is pressed down.
       *
       * Example:
       *
       * ```TypeScript
       * series.slices.template.cursorDownStyle = am4core.MouseCursorStyle.grabbing;
       * ```
       * ```JavaScript
       * series.slices.template.cursorDownStyle = am4core.MouseCursorStyle.grabbing;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": {
       *     // ...
       *     "slices": {
       *       "cursorDownStyle": "grabbing"
       *     }
       *   }
       * }
       * ```
       *
       * @param style An array of styles to apply onhover
       */
      set: function(style) {
        this.cursorOptions.downStyle = style;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.applyCursorStyle = function() {
    };
    Object.defineProperty(Sprite2.prototype, "interactionsEnabled", {
      /**
       * @return Is interaction enabled for this element?
       */
      get: function() {
        var value = this.getPropertyValue("interactionsEnabled");
        if (value === false) {
          return false;
        }
        if (this.virtualParent) {
          return this.virtualParent.interactionsEnabled;
        }
        if (this._parent) {
          return this._parent.interactionsEnabled;
        }
        return true;
      },
      /**
       * Setting this to `false` will effectively disable all interactivity on the
       * element.
       *
       * @param value  Is interaction enabled for this element?
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("interactionsEnabled", value)) {
          var pointerEvents = null;
          if (!value) {
            pointerEvents = "none";
          } else {
            this.group.node.style.pointerEvents = "";
          }
          this.group.node.style.pointerEvents = pointerEvents;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "exporting", {
      /**
       * @return Export instance
       */
      get: function() {
        return this.getExporting();
      },
      /**
       * ==========================================================================
       * EXPORT-RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * An [[Export]] instance.
       *
       * Used to access API of the chart export functionality.
       *
       * If `exporting` is not set, the element inherits [[Export]] instance from
       * its parents.
       *
       * Upon request, if no parent has such instance, a new one is created, using
       * default settings, what in most cases is just enough.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/exporting/} for more info about exporting
       * @param exp  Export
       */
      set: function(exp) {
        this._exporting.set(exp, exp);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.getExporting = function() {
      var _export = this._exporting.get();
      if (_export) {
        return _export;
      } else {
        if (this.isStandaloneInstance || !this._parent) {
          _export = new Export(this.svgContainer.SVGContainer);
          _export.sprite = this;
          _export.language = this.language;
          _export.numberFormatter = this.numberFormatter;
          _export.dateFormatter = this.dateFormatter;
          _export.durationFormatter = this.durationFormatter;
          this._exporting.set(_export, _export);
        } else {
          return this._parent.exporting;
        }
      }
      return _export;
    };
    Object.defineProperty(Sprite2.prototype, "exportable", {
      /**
       * @return Export?
       */
      get: function() {
        return this._exportable;
      },
      /**
       * If set to `false` this element will be omitted when exporting the chart
       * to an image.
       *
       * @default true
       * @param value  Export?
       */
      set: function(value) {
        var svgContainer = this.svgContainer;
        this._exportable = value;
        if (svgContainer) {
          if (value) {
            remove(svgContainer.nonExportableSprites, this);
          } else if (indexOf(svgContainer.nonExportableSprites, this) == -1) {
            svgContainer.nonExportableSprites.push(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.modalPrefix = function(value) {
      value = options.classNamePrefix + value;
      return value;
    };
    Object.defineProperty(Sprite2.prototype, "modal", {
      /**
       * Returns a [[Modal]] instance, associated with this chart.
       * (elements top parent)
       *
       * Accessing modal does not make it appear. To make a modal appear, use
       * `showModal()` method.
       *
       * @see {@link Modal} for more information about using Modal windows
       * @return Modal instance
       */
      get: function() {
        var svgContainer = this.svgContainer;
        if (svgContainer) {
          var modal = svgContainer.modal;
          if (!modal.adapter.has("classPrefix", this.modalPrefix)) {
            modal.adapter.add("classPrefix", this.modalPrefix);
          }
          return modal;
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.openModal = function(text, title) {
      var svgContainer = this.svgContainer;
      if (svgContainer) {
        return svgContainer.openModal(text, title);
      }
    };
    Sprite2.prototype.closeModal = function() {
      var svgContainer = this.svgContainer;
      if (svgContainer) {
        svgContainer.closeModal();
      }
    };
    Object.defineProperty(Sprite2.prototype, "popups", {
      /**
       * A list of popups for this chart.
       *
       * @return Popups
       */
      get: function() {
        var svgContainer = this.svgContainer;
        if (svgContainer) {
          var popups = svgContainer.popups;
          popups.template.sprite = this;
          if (!popups.template.adapter.has("classPrefix", this.modalPrefix)) {
            popups.template.adapter.add("classPrefix", this.modalPrefix);
          }
          return popups;
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.openPopup = function(text, title) {
      var svgContainer = this.svgContainer;
      if (svgContainer) {
        return svgContainer.openPopup(text, title);
      }
    };
    Sprite2.prototype.closeAllPopups = function() {
      var svgContainer = this.svgContainer;
      if (svgContainer) {
        svgContainer.closeAllPopups();
      }
    };
    Object.defineProperty(Sprite2.prototype, "x", {
      /**
       * @return X coordinate
       */
      get: function() {
        return this.getPropertyValue("x");
      },
      /**
       * ==========================================================================
       * POSITIONAL PROPERTIES AND RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Element's absolute or relative X coordinate.
       *
       * If setting both X and Y, please consider using `moveTo()` method instead,
       * as it will be faster to set both coordinates at once.
       *
       * @param value X coordinate
       */
      set: function(value) {
        if (!this.isDragged) {
          this.setPercentProperty("x", value, false, true, this._positionPrecision, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelX", {
      /**
       * Returns element's current absolute X coordinate in pixels.
       *
       * @readonly
       * @return X coordinate (px)
       */
      get: function() {
        var value = fitToRange(this.getPixelX(this.x), this.minX, this.maxX);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelX", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeX", {
      /**
       * Returns element's current relative X coordinate in [[Percent]].
       *
       * @return X coordinate ([[Percent]])
       */
      get: function() {
        if (!this._adapterO) {
          return this.getRelativeX(this.x);
        } else {
          return this._adapterO.apply("relativeX", this.getRelativeX(this.x));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "minX", {
      /**
       * @ignore Exclude from docs
       * @return Min X (px)
       */
      get: function() {
        return this.getPropertyValue("minX");
      },
      /**
       * The smallest allowable absolute X coordinate for this element.
       *
       * This is used to contain element movement within certain boundaries.
       *
       * @ignore Exclude from docs
       * @param value Min X (px)
       */
      set: function(value) {
        if (isNumber(value)) {
          value = round(value, this._positionPrecision, true);
          this.setPropertyValue("minX", value, false, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "maxX", {
      /**
       * @ignore Exclude from docs
       * @return Max X (px)
       */
      get: function() {
        return this.getPropertyValue("maxX");
      },
      /**
       * The biggest allowable absolute X coordinate for this element.
       *
       * This is used to contain element movement within certain boundaries.
       *
       * @ignore Exclude from docs
       * @param value Max X (px)
       */
      set: function(value) {
        if (isNumber(value)) {
          value = round(value, this._positionPrecision, true);
          this.setPropertyValue("maxX", value, false, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "y", {
      /**
       * @return Y coordinate
       */
      get: function() {
        return this.getPropertyValue("y");
      },
      /**
       * Element's absolute or relative Y coordinate.
       *
       * If setting both X and Y, please consider using `moveTo()` method instead,
       * as it will be faster to set both coordinates at once.
       *
       * @param value  Y coordinate
       */
      set: function(value) {
        if (!this.isDragged) {
          this.setPercentProperty("y", value, false, true, this._positionPrecision, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelY", {
      /**
       * Returns element's current absolute Y coordinate in pixels.
       *
       * @readonly
       * @return Y coordinate (px)
       */
      get: function() {
        var value = fitToRange(this.getPixelY(this.y), this.minY, this.maxY);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelY", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeY", {
      /**
       * Returns element's current relative Y coordinate in [[Percent]].
       *
       * @readonly
       * @return Y coordinate ([[Percent]])
       */
      get: function() {
        if (!this._adapterO) {
          return this.getRelativeX(this.y);
        } else {
          return this._adapterO.apply("relativeY", this.getRelativeX(this.y));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "minY", {
      /**
       * @ignore Exclude from docs
       * @return Min Y (px)
       */
      get: function() {
        return this.getPropertyValue("minY");
      },
      /**
       * The smallest allowable absolute Y coordinate for this element.
       *
       * This is used to contain element movement within certain boundaries.
       *
       * @ignore Exclude from docs
       * @param value Min Y (px)
       */
      set: function(value) {
        if (isNumber(value)) {
          value = round(value, this._positionPrecision, true);
          this.setPropertyValue("minY", value, false, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "maxY", {
      /**
       * @ignore Exclude from docs
       * @return Max Y (px)
       */
      get: function() {
        return this.getPropertyValue("maxY");
      },
      /**
       * The biggest allowable absolute Y coordinate for this element.
       *
       * This is used to contain element movement within certain boundaries.
       *
       * @ignore Exclude from docs
       * @param value  Max Y (px)
       */
      set: function(value) {
        if (isNumber(value)) {
          value = round(value, this._positionPrecision, true);
          this.setPropertyValue("maxY", value, false, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "dx", {
      /**
       * @return Horizontal offset (px)
       */
      get: function() {
        return this.getPropertyValue("dx");
      },
      /**
       * A horizontal offset for the element in pixels.
       *
       * Can be negative value for offset to the left.
       *
       * @param value  Horizontal offset (px)
       */
      set: function(value) {
        if (isNumber(value)) {
          value = round(value, this._positionPrecision, true);
          this.setPropertyValue("dx", value, false, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "dy", {
      /**
       * @return Vertical offset (px)
       */
      get: function() {
        return this.getPropertyValue("dy");
      },
      /**
       * A vertical offset for the element in pixels.
       *
       * Can be negative value for offset upwards.
       *
       * @param value  Vertical offset (px)
       */
      set: function(value) {
        if (isNumber(value)) {
          value = round(value, this._positionPrecision, true);
          this.setPropertyValue("dy", value, false, true);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "rotation", {
      /**
       * @return Rotation (0-360)
       */
      get: function() {
        return this.getPropertyValue("rotation");
      },
      /**
       * Rotation of the element in degrees. (0-360)
       *
       * Note: For convenience purposes, negative values (for counter-clockwise
       * rotation) and values exceeding 360 can also be used.
       *
       * @param value  Rotation (0-360)
       */
      set: function(value) {
        value = toNumber(value);
        if (!isNumber(value)) {
          value = 0;
        }
        this.setPropertyValue("rotation", value, false, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "align", {
      /**
       * @return Horizontal align
       */
      get: function() {
        return this.getPropertyValue("align");
      },
      /**
       * Controls horizontal alignment of the element.
       *
       * This is used by parent [[Container]] when layouting its children.
       *
       * @param value  Horizontal align
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("align", value)) {
          if (this._parent) {
            this._parent.invalidateLayout();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "valign", {
      /**
       * @return Vertical align
       */
      get: function() {
        return this.getPropertyValue("valign");
      },
      /**
       * Controls vertical alignment of the element.
       *
       * This is used by parent [[Container]] when layouting its children.
       *
       * @param value  Vertical align
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("valign", value)) {
          if (this._parent) {
            this._parent.invalidateLayout();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "horizontalCenter", {
      /**
       * @return Horizontal center
       */
      get: function() {
        return this.getPropertyValue("horizontalCenter");
      },
      /**
       * Controls which part of the element to treat as a horizontal center.
       *
       * The setting will be used when positioning, resizing and rotating the
       * element.
       *
       * @param value  Horizontal center
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("horizontalCenter", value)) {
          this.updateCenter();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "verticalCenter", {
      /**
       * @return Vertical center
       */
      get: function() {
        return this.getPropertyValue("verticalCenter");
      },
      /**
       * Controls which part of the element to treat as a vertical center.
       *
       * The setting will be used when positioning, resizing and rotating the
       * element.
       *
       * @param value  Vertical center
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("verticalCenter", value)) {
          this.updateCenter();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "maxWidth", {
      /**
       * @return Maximum width (px)
       */
      get: function() {
        var maxWidth = this.getPropertyValue("maxWidth");
        if (!isNumber(maxWidth)) {
          if (this._parent) {
            var parentWidth = this._parent.maxWidth;
            if (this._parent.layout != "absolute" && this.align != "none" && this.align != void 0) {
              parentWidth = parentWidth - this.pixelMarginLeft - this.pixelMarginRight;
            }
            return parentWidth;
          }
        }
        return maxWidth;
      },
      /**
       * ==========================================================================
       * DIMENSIONAL PROPERTIES AND RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Maximum allowed width for the element in pixels.
       *
       * @param value  Maximum width (px)
       */
      set: function(value) {
        this.setMaxWidth(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setMaxWidth = function(value) {
      var prevWidth = this.maxWidth;
      var prevHeight = this.maxHeight;
      if (this.setPropertyValue("maxWidth", value)) {
        if (isNumber(this.relativeWidth)) {
          this.invalidate();
        }
        var event_2 = {
          type: "maxsizechanged",
          target: this,
          previousWidth: prevWidth,
          previousHeight: prevHeight
        };
        this.dispatchImmediately("maxsizechanged", event_2);
      }
    };
    Object.defineProperty(Sprite2.prototype, "maxHeight", {
      /**
       * @return Maximum height (px)
       */
      get: function() {
        var maxHeight = this.getPropertyValue("maxHeight");
        if (!isNumber(maxHeight)) {
          if (this._parent) {
            var parentHeight = this._parent.maxHeight;
            if (this._parent.layout != "absolute" && this.valign != "none" && this.valign != void 0) {
              parentHeight = parentHeight - this.pixelMarginTop - this.pixelMarginBottom;
            }
            return parentHeight;
          }
        }
        return maxHeight;
      },
      /**
       * Maximum allowed height for the element in pixels.
       *
       * @param value  Maximum height (px)
       */
      set: function(value) {
        this.setMaxHeight(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setMaxHeight = function(value) {
      var prevWidth = this.maxWidth;
      var prevHeight = this.maxHeight;
      if (this.setPropertyValue("maxHeight", value)) {
        if (isNumber(this.relativeHeight)) {
          this.invalidate();
        }
        var event_3 = {
          type: "maxsizechanged",
          target: this,
          previousWidth: prevWidth,
          previousHeight: prevHeight
        };
        this.dispatchImmediately("maxsizechanged", event_3);
      }
    };
    Object.defineProperty(Sprite2.prototype, "minWidth", {
      /**
       * @return Minimum width (px)
       */
      get: function() {
        return this.getPropertyValue("minWidth");
      },
      /**
       * Minimum width of the element in pixels.
       *
       * Set to `undefined` to remove the limit.
       *
       * @param value  Minimum width (px)
       */
      set: function(value) {
        this.setPropertyValue("minWidth", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "minHeight", {
      /**
       * @return Minimum height (px)
       */
      get: function() {
        return this.getPropertyValue("minHeight");
      },
      /**
       * Minimum height for the element in pixels.
       *
       * Set to `undefined` to remove the limit.
       *
       * @param value  Minimum height (px)
       */
      set: function(value) {
        this.setPropertyValue("minHeight", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "width", {
      /**
       * @return Width (absolute or relative)
       */
      get: function() {
        return this.getPropertyValue("width");
      },
      /**
       * Element's absolute or relative width.
       *
       * The width can either be absolute, set in numeric pixels, or relative, set
       * in [[Percent]].
       *
       * Relative width will be calculated using closest measured ancestor
       * [[Container]].
       *
       * NOTE: `width` is an accessor, which allows setting width in pixels or
       * percent. It is a sort of a "shortcut" for the users. Actual renderer does
       * not ever use it. It uses either `pixelWidth` or `percentWidth`, so if
       * you need to add an adapter for width add it for either of the two
       * properties - whichever suits your requirements.
       *
       * @param value  Width (numeric in pixels or relative)
       */
      set: function(value) {
        var changed = this.setPercentProperty("width", value, true, false, this._positionPrecision, true);
        if (changed) {
          this.percentWidth = void 0;
          this.relativeWidth = void 0;
          if (value instanceof Percent) {
            this.percentWidth = value.percent;
            if (isNumber(this._pixelWidth)) {
              this.maxWidth = void 0;
            }
            this._pixelWidth = void 0;
          } else {
            this._pixelWidth = Number(value);
            this.maxWidth = this._pixelWidth;
          }
          this.invalidatePosition();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "height", {
      /**
       * @return height (absolute or relative)
       */
      get: function() {
        return this.getPropertyValue("height");
      },
      /**
       * Element's absolute or relative height.
       *
       * The height can either be absolute, set in numeric pixels, or relative, set
       * in [[Percent]].
       *
       * Relative height will be calculated using closest measured ancestor
       * [[Container]].
       *
       * NOTE: `height` is an accessor, which allows setting height in pixels or
       * percent. It is a sort of a "shortcut" for the users. Actual renderer does
       * not ever use it. It uses either `pixelHeight` or `percentHeight`, so if
       * you need to add an adapter for height add it for either of the two
       * properties - whichever suits your requirements.
       *
       * @param value  Height (numeric in pixels or relative)
       */
      set: function(value) {
        var changed = this.setPercentProperty("height", value, true, false, this._positionPrecision, true);
        if (changed) {
          this.percentHeight = void 0;
          this._relativeHeight = void 0;
          if (value instanceof Percent) {
            this.percentHeight = value.percent;
            if (isNumber(this._pixelHeight)) {
              this.maxHeight = void 0;
            }
            this._pixelHeight = void 0;
          } else {
            this._pixelHeight = Number(value);
            this.maxHeight = this._pixelHeight;
          }
          this.invalidatePosition();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelWidth", {
      /**
       * Returns element's width in pixels, if width was set. For actual width use measuredWidth property.
       *
       * @readonly
       * @return Width (px)
       */
      get: function() {
        var width2;
        if (isNumber(this.percentWidth)) {
          width2 = this.maxWidth;
        } else if (isNumber(this._pixelWidth)) {
          width2 = this._pixelWidth;
        } else {
          width2 = 0;
        }
        var minWidth = this.minWidth;
        if (minWidth != null && width2 < minWidth) {
          width2 = minWidth;
        }
        var value = round(width2, this._positionPrecision, true);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelWidth", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelHeight", {
      /**
       * Returns element's height in pixels. For actual height use measuredHeight property.
       *
       * @readonly
       * @return Height (px)
       */
      get: function() {
        var height2;
        if (isNumber(this.percentHeight)) {
          height2 = this.maxHeight;
        } else if (isNumber(this._pixelHeight)) {
          height2 = this._pixelHeight;
        } else {
          height2 = 0;
        }
        var minHeight = this.minHeight;
        if (minHeight != null && height2 < minHeight) {
          height2 = minHeight;
        }
        var value = round(height2, this._positionPrecision, true);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelHeight", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeWidth", {
      /**
       * @return Relative width
       * @ignore
       */
      get: function() {
        var relativeWidth = this._relativeWidth;
        if (isNumber(relativeWidth)) {
          if (!this._adapterO) {
            return relativeWidth;
          } else {
            return this._adapterO.apply("relativeWidth", relativeWidth);
          }
        }
      },
      /**
       * Element's relative width in [[Percent]].
       * @ignore
       *
       * @param value  Relative width
       */
      set: function(value) {
        if (this._relativeWidth != value) {
          this._relativeWidth = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeHeight", {
      /**
       * @return Relative height
       * @ignore
       */
      get: function() {
        var relativeHeight = this._relativeHeight;
        if (isNumber(relativeHeight)) {
          if (!this._adapterO) {
            return relativeHeight;
          } else {
            return this._adapterO.apply("relativeHeight", relativeHeight);
          }
        }
      },
      /**
       * Element's relative height in [[Percent]].
       *
       * @param value  Relative height
       * @ignore
       */
      set: function(value) {
        if (this._relativeHeight != value) {
          this._relativeHeight = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "measuredWidth", {
      /**
       * Returns element's measured width in pixels.
       *
       * A measured width is actual width of contents plus `paddingRight` and* `paddingLeft`, relative to sprite parent, meaning that
       * rotation and scale is taken into account.
       *
       * @readonly
       * @return Width (px)
       */
      get: function() {
        if (this.disabled || this.__disabled) {
          return 0;
        }
        if (!this._adapterO) {
          return this._measuredWidth;
        } else {
          return this._adapterO.apply("measuredWidth", this._measuredWidth);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "measuredHeight", {
      /**
       * Returns elements's measured height in pixels.
       *
       * A measured height is actual height of contents plus `paddingTop` and `paddingBottom`, relative to sprite parent, meaning that
       * rotation and scale taken into account.
       *
       * @readonly
       * @return Height (px)
       */
      get: function() {
        if (this.disabled || this.__disabled) {
          return 0;
        }
        if (!this._adapterO) {
          return this._measuredHeight;
        } else {
          return this._adapterO.apply("measuredHeight", this._measuredHeight);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "outerWidth", {
      /**
       * Returns element's measured width plus its left and right margins in
       * pixels.
       *
       * @readonly
       * @return Outer width (px)
       */
      get: function() {
        var value = this.pixelWidth + this.pixelMarginRight + this.pixelMarginLeft;
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("outerWidth", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "outerHeight", {
      /**
       * Returns element's measured height plus its top and bottom margins in
       * pixels.
       *
       * @readonly
       * @return Outer height (px)
       */
      get: function() {
        var value = this.pixelHeight + this.pixelMarginTop + this.pixelMarginBottom;
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("outerHeight", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "innerWidth", {
      /**
       * Returns element's measured inner width in pixels.
       *
       * Inner width is actual available space for content, e.g. element's width
       * minus horizontal padding.
       *
       * @readonly
       * @return Inner width (px)
       */
      get: function() {
        var value = Math.max(0, this.pixelWidth - this.pixelPaddingRight - this.pixelPaddingLeft);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("innerWidth", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "innerHeight", {
      /**
       * Returns element's measured inner height in pixels.
       *
       * Inner height is actual available space for content, e.g. element's height
       * minus vertical padding.
       *
       * @readonly
       * @return Inner height (px)
       */
      get: function() {
        var value = Math.max(0, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("innerHeight", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "globalScale", {
      /**
       * Returns element's current "global" scale.
       *
       * Scale values accumulate over hierarchy of elements.
       *
       * E.g. if a [[Container]] has `scale = 2` and it's child has a `scale = 2`,
       * the child's `globalScale` will be 4. (a multitude of `2 x 2`)
       *
       * @readonly
       * @return Global scale
       */
      get: function() {
        var scale = this.scale;
        if (this._parent) {
          scale = scale * this._parent.globalScale;
        }
        if (!this._adapterO) {
          return scale;
        } else {
          return this._adapterO.apply("globalScale", scale);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "scale", {
      /**
       * @return Scale (0-1)
       */
      get: function() {
        return this.getPropertyValue("scale");
      },
      /**
       * Scale of the element.
       *
       * The scale is set from 0 (element reduced to nothing) to 1 (default size).
       * * 2 will mean element is increased twice.
       * * 0.5 - reduced by 50%.
       *
       * Etc.
       *
       * @param value  Scale (0-1)
       */
      set: function(value) {
        value = toNumber(value);
        if (value < 0) {
          value = 0;
        }
        if (value != this.getPropertyValue("scale")) {
          this.setPropertyValue("scale", value, false, true);
          this.handleGlobalScale();
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.margin = function(top, right, bottom, left) {
      this.marginTop = top;
      this.marginRight = right;
      this.marginBottom = bottom;
      this.marginLeft = left;
      return this;
    };
    Object.defineProperty(Sprite2.prototype, "marginLeft", {
      /**
       * @return Margin value
       */
      get: function() {
        return this.getPropertyValue("marginLeft");
      },
      /**
       * Left margin - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Margin value
       */
      set: function(value) {
        this.setPercentProperty("marginLeft", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "marginRight", {
      /**
       * @return Margin value
       */
      get: function() {
        return this.getPropertyValue("marginRight");
      },
      /**
       * Right margin - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Margin value
       */
      set: function(value) {
        this.setPercentProperty("marginRight", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "marginTop", {
      /**
       * @return Margin value
       */
      get: function() {
        return this.getPropertyValue("marginTop");
      },
      /**
       * Top margin - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Margin value
       */
      set: function(value) {
        this.setPercentProperty("marginTop", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "marginBottom", {
      /**
       * @return Margin value
       */
      get: function() {
        return this.getPropertyValue("marginBottom");
      },
      /**
       * Bottom margin - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Margin value
       */
      set: function(value) {
        this.setPercentProperty("marginBottom", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelMarginRight", {
      /**
       * Returns current right margin in pixels.
       *
       * @readonly
       * @return Right margin (px)
       */
      get: function() {
        var value = this.getPixelX(this.marginRight);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelMarginRight", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeMarginRight", {
      /**
       * Returns current relative right margin.
       *
       * @readonly
       * @return Relative right margin
       */
      get: function() {
        var value = this.getRelativeX(this.marginRight);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("relativeMarginRight", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelMarginLeft", {
      /**
       * Returns current left margin in pixels.
       *
       * @readonly
       * @return Left margin (px)
       */
      get: function() {
        var value = this.getPixelX(this.marginLeft);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelMarginLeft", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeMarginLeft", {
      /**
       * Returns current relative left margin.
       *
       * @readonly
       * @return Relative left margin
       */
      get: function() {
        var value = this.getRelativeX(this.marginLeft);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("relativeMarginLeft", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelMarginTop", {
      /**
       * Returns current top margin in pixels.
       *
       * @readonly
       * @return Top margin (px)
       */
      get: function() {
        var value = this.getPixelY(this.marginTop);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelMarginTop", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeMarginTop", {
      /**
       * Returns current relative top margin.
       *
       * @readonly
       * @return Relative top margin
       */
      get: function() {
        var value = this.getRelativeY(this.marginTop);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("relativeMarginTop", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelMarginBottom", {
      /**
       * Returns current bottom margin in pixels.
       *
       * @readonly
       * @return Bottom margin (px)
       */
      get: function() {
        var value = this.getPixelY(this.marginBottom);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("pixelMarginBottom", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativeMarginBottom", {
      /**
       * Returns current relative bottom margin.
       *
       * @readonly
       * @return Relative bottom margin
       */
      get: function() {
        var value = this.getRelativeY(this.marginBottom);
        if (!this._adapterO) {
          return value;
        } else {
          return this._adapterO.apply("relativeMarginBottom", value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.padding = function(top, right, bottom, left) {
      this.paddingTop = top;
      this.paddingRight = right;
      this.paddingBottom = bottom;
      this.paddingLeft = left;
      return this;
    };
    Object.defineProperty(Sprite2.prototype, "paddingLeft", {
      /**
       * @return Padding value
       */
      get: function() {
        return this.getPropertyValue("paddingLeft");
      },
      /**
       * Left padding - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Padding value
       */
      set: function(value) {
        this.setPercentProperty("paddingLeft", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "paddingRight", {
      /**
       * @return Padding value
       */
      get: function() {
        return this.getPropertyValue("paddingRight");
      },
      /**
       * Right padding - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Padding value
       */
      set: function(value) {
        this.setPercentProperty("paddingRight", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "paddingTop", {
      /**
       * @return Padding value
       */
      get: function() {
        return this.getPropertyValue("paddingTop");
      },
      /**
       * Top padding - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Padding value
       */
      set: function(value) {
        this.setPercentProperty("paddingTop", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "paddingBottom", {
      /**
       * @return Padding value
       */
      get: function() {
        return this.getPropertyValue("paddingBottom");
      },
      /**
       * Bottom padding - absolute (px) or relative ([[Percent]]).
       *
       * @param value  Padding value
       */
      set: function(value) {
        this.setPercentProperty("paddingBottom", value, true, true, this._positionPrecision, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelPaddingRight", {
      /**
       * Returns current right padding in pixels.
       *
       * @readonly
       * @return Right padding (px)
       */
      get: function() {
        return this.getPixelX(this.paddingRight);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativePaddingRight", {
      /**
       * Returns current relative right padding.
       *
       * @readonly
       * @return Relative right padding
       */
      get: function() {
        return this.getRelativeX(this.paddingRight);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelPaddingLeft", {
      /**
       * Returns current left padding in pixels.
       *
       * @readonly
       * @return Left padding (px)
       */
      get: function() {
        return this.getPixelX(this.paddingLeft);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativePaddingLeft", {
      /**
       * Returns current relative left padding.
       *
       * @readonly
       * @return Relative left padding
       */
      get: function() {
        return this.getRelativeX(this.paddingLeft);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelPaddingTop", {
      /**
       * Returns current top padding in pixels.
       *
       * @readonly
       * @return Top padding (px)
       */
      get: function() {
        return this.getPixelY(this.paddingTop);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativePaddingTop", {
      /**
       * Returns current relative top padding.
       *
       * @readonly
       * @return Relative top padding
       */
      get: function() {
        return this.getRelativeY(this.paddingTop);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelPaddingBottom", {
      /**
       * Returns current bottom padding in pixels.
       *
       * @readonly
       * @return Bottom padding (px)
       */
      get: function() {
        return this.getPixelY(this.paddingBottom);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "relativePaddingBottom", {
      /**
       * Returns current relative bottom padding.
       *
       * @readonly
       * @return Relative bottom padding
       */
      get: function() {
        return this.getRelativeY(this.paddingBottom);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "path", {
      /**
       * @return Path of a Sprite element
       */
      get: function() {
        return this.getPropertyValue("path");
      },
      /**
       * ==========================================================================
       * APPEARANCE-RELATED PROPERTIES AND RELATED STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * Path of Sprite element
       */
      set: function(value) {
        this.setPath(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setPath = function(value) {
      if (this.setPropertyValue("path", value)) {
        if (this._adapterO) {
          value = this._adapterO.apply("path", value);
        }
        if (!this._isPath) {
          if (!this.element || this.element.node && !(this.element.node instanceof SVGPathElement)) {
            this.element = this.paper.add("path");
          }
          this._isPath = true;
        }
        if (hasValue(value)) {
          this.element.attr({ "d": value });
        } else {
          this.element.removeAttr("d");
        }
        this.invalidatePosition();
        if (!this.inited) {
          this.events.once("inited", this.validatePosition, this, false);
        }
        return true;
      }
      return false;
    };
    Object.defineProperty(Sprite2.prototype, "fillModifier", {
      /**
       * @return Fill color modifier
       */
      get: function() {
        return this.getPropertyValue("fillModifier");
      },
      /**
       * [[ColorModifier]] that can be used to modify color and pattern of the
       * element's fill, e.g. create gradients.
       *
       * @param value  Fill color modifiier
       */
      set: function(value) {
        if (this.setPropertyValue("fillModifier", value)) {
          this.setFill(this.fill);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "strokeModifier", {
      /**
       * @return Stroke color modifier
       */
      get: function() {
        return this.getPropertyValue("strokeModifier");
      },
      /**
       * [[ColorModifier]] that can be used to modify color and pattern of the
       * element's stroke (outline), e.g. create gradients.
       *
       * @param value  Stroke color modifier
       */
      set: function(value) {
        this.setPropertyValue("strokeModifier", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "fillOpacity", {
      /**
       * @return Opacity (0-9)
       */
      get: function() {
        return this.getPropertyValue("fillOpacity");
      },
      /**
       * Element's fill opacity.
       *
       * Opacity ranges from 0 (fully transparent) to 1 (fully opaque).
       *
       * @param value  Opacity (0-1)
       */
      set: function(value) {
        value = toNumberRange(value, 0, 1);
        if (this.setPropertyValue("fillOpacity", value)) {
          this.setSVGAttribute({ "fill-opacity": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "fill", {
      /**
       * @return Fill
       */
      get: function() {
        return this.getPropertyValue("fill");
      },
      /**
       * Element's fill color or pattern.
       *
       * @param value  Fill
       */
      set: function(value) {
        this.setFill(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setFill = function(value) {
      if (!isObject(value) || "r" in value) {
        value = toColor(value);
      }
      if (this.setColorProperty("fill", value) || this.fillModifier) {
        if (value instanceof Color) {
          if (this.fillModifier) {
            value = this.fillModifier.modify(value);
          }
        }
        this.realFill = value;
        if (value instanceof Color) {
          this.setSVGAttribute({ "fill": value.toString() });
        } else if (!hasValue(value)) {
          this.removeSVGAttribute("fill");
        } else if (value instanceof Pattern || value instanceof LinearGradient || value instanceof RadialGradient) {
          var fill = value;
          fill.paper = this.paper;
          this.setSVGAttribute({ "fill": 'url("' + getBaseURI() + fill.id + '")' });
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "opacity", {
      /**
       * @return Opacity (0-1)
       */
      get: function() {
        return this.getPropertyValue("opacity");
      },
      /**
       * Element's opacity.
       *
       * Opacity setting can range from 0 (fully transparent) to 1 (fully opaque).
       *
       * ATTENTION: It is highly not recommended to use `opacity` directly on the
       * element. The charts use `opacity` to hide/show elements, so your setting
       * might be lost if element is hidden and then later shown.
       *
       * Instead use methods `hide()` and `show()` to completely toggle off and on
       * the element.
       *
       * Or, use properties `fillOpacity` and `strokeOpacity`, if you need to make
       * the element semi-transparent.
       *
       * @param value Opacity (0-1)
       */
      set: function(value) {
        value = toNumberRange(value, 0, 1);
        if (this.setPropertyValue("opacity", value)) {
          this.setSVGAttribute({ "opacity": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "stroke", {
      /**
       * @return Stroke setting
       */
      get: function() {
        return this.getPropertyValue("stroke");
      },
      /**
       * Element's stroke (outline) color or pattern.
       *
       * @param value  Stroke setting
       */
      set: function(value) {
        this.setStroke(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setStroke = function(value) {
      if (!isObject(value) || "r" in value) {
        value = toColor(value);
      }
      if (this.setColorProperty("stroke", value) || this.strokeModifier) {
        if (value instanceof Color) {
          if (this.strokeModifier) {
            value = this.strokeModifier.modify(value);
          }
        }
        this.realStroke = value;
        if (value instanceof Color) {
          if (value.hex == "none") {
            this.removeSVGAttribute("stroke");
          } else {
            this.setSVGAttribute({ "stroke": value.toString() });
          }
        } else if (!hasValue(value)) {
          this.removeSVGAttribute("stroke");
        } else if (value instanceof Pattern || value instanceof LinearGradient || value instanceof RadialGradient) {
          var stroke = value;
          stroke.paper = this.paper;
          this.setSVGAttribute({ "stroke": 'url("' + getBaseURI() + stroke.id + '")' });
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "strokeOpacity", {
      /**
       * @return Opacity (0-1)
       */
      get: function() {
        return this.getPropertyValue("strokeOpacity");
      },
      /**
       * Stroke (outline) opacity.
       *
       * The values may range from 0 (fully transparent) to 1 (fully opaque).
       *
       * @param value  Opacity (0-1)
       */
      set: function(value) {
        value = toNumberRange(value, 0, 1);
        if (this.setPropertyValue("strokeOpacity", value)) {
          this.setSVGAttribute({ "stroke-opacity": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "nonScalingStroke", {
      /**
       * @return Do not scale stroke (outline)
       */
      get: function() {
        return this.getPropertyValue("nonScalingStroke");
      },
      /**
       * Controls if the element's stroke (outline) should remain keep constant
       * thicnkess and do not scale when the whole element is resized.
       *
       * @param value  Do not scale stroke (outline)
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.setPropertyValue("nonScalingStroke", value)) {
          this.strokeWidth = this.strokeWidth;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "nonScaling", {
      /**
       * @return Is element scaleable?
       */
      get: function() {
        return this.getPropertyValue("nonScaling");
      },
      /**
       * Controls if element should keep constant size and not scale even if there is
       * space available, or it does not fit.
       *
       * @param value  Is element scaleable?
       */
      set: function(value) {
        value = toBoolean(value);
        this.setPropertyValue("nonScaling", value, false, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "strokeWidth", {
      /**
       * @return Thickness (px)
       */
      get: function() {
        return this.getPropertyValue("strokeWidth");
      },
      /**
       * Stroke (outline) thickness in pixels.
       *
       * @param value  Thickness (px)
       */
      set: function(value) {
        value = toNumber(value);
        this.setPropertyValue("strokeWidth", value, true);
        if (this.nonScalingStroke) {
          if (!isNumber(value)) {
            value = 1;
          }
          value = value / this.globalScale;
        }
        this.setSVGAttribute({ "stroke-width": value });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "strokeDasharray", {
      /**
       * @return `stroke-dasharray`
       */
      get: function() {
        return this.getPropertyValue("strokeDasharray");
      },
      /**
       * A `stroke-dasharray` for the stroke (outline).
       *
       * "Dasharray" allows setting rules to make lines dashed, dotted, etc.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more info on `stroke-dasharray`
       * @param value  `stroke-dasharray`
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("strokeDasharray", value)) {
          this.setSVGAttribute({ "stroke-dasharray": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "strokeDashoffset", {
      /**
       * @return `stroke-dashoffset`
       */
      get: function() {
        return this.getPropertyValue("strokeDashoffset");
      },
      /**
       * A `stroke-dashoffset` for the stroke (outline).
       *
       * "Dashoffset" allows setting the start position of the dashes if
       * `strokeDasharray` is used.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dashoffset} for more info on `stroke-dashoffset`
       * @param value  `stroke-dashoffset`
       */
      set: function(value) {
        value = toNumber(value);
        if (this.setPropertyValue("strokeDashoffset", value)) {
          this.setSVGAttribute({ "stroke-dashoffset": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "strokeLinecap", {
      /**
       * @return `stroke-linecap`
       */
      get: function() {
        return this.getPropertyValue("strokeLinecap");
      },
      /**
       * A `stroke-linecap` to indicate how line ends are drawn.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes#Stroke} for more info on `stroke-linecap`
       * @param value  `stroke-linecap`
       */
      set: function(value) {
        if (this.setPropertyValue("strokeLinecap", value)) {
          this.setSVGAttribute({ "stroke-linecap": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "strokeLinejoin", {
      /**
       * @return `stroke-linejoin`
       */
      get: function() {
        return this.getPropertyValue("strokeLinejoin");
      },
      /**
       * A `stroke-linejoin` to indicate how line ends are drawn.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes#Stroke} for more info on `stroke-linejoin`
       * @param value  `stroke-linejoin`
       */
      set: function(value) {
        if (this.setPropertyValue("strokeLinejoin", value)) {
          this.setSVGAttribute({ "stroke-linejoin": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "shapeRendering", {
      /**
       * @return 'shape-rendering' value
       */
      get: function() {
        return this.getPropertyValue("shapeRendering");
      },
      /**
       * An SVG-specific `shape-rendering` value.
       *
       * `shape-rendering` controls how vector graphics are drawn and rendered.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering} for more information about `shape-rendering`
       * @default "auto"
       * @param value  'shape-rendering' value
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("shapeRendering", value)) {
          this.setSVGAttribute({ "shape-rendering": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "pixelPerfect", {
      /**
       * @return Use pixel perfect?
       */
      get: function() {
        return this.getPropertyValue("pixelPerfect");
      },
      /**
       * Controls if SVG vectors should be drawn with "pixel" precision, producing
       * perfectly crisp lines on retina displays.
       *
       * Setting this to `true` might improve visual quality, but may have a
       * negative effect on performance.
       *
       * Different elements use different default setting for `pixelPerfect`.
       *
       * We recommend leaving this at their default settings, unless there's a
       * specific need.
       *
       * @param value  Use pixel perfect?
       */
      set: function(value) {
        value = toBoolean(value);
        if (value) {
          this._positionPrecision = options.pixelPerfectPrecision;
        } else {
          this._positionPrecision = 3;
        }
        this.setPropertyValue("pixelPerfect", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "rtl", {
      /**
       * @return RTL?
       */
      get: function() {
        if (hasValue(this._rtl)) {
          return this._rtl;
        } else if (this._topParent) {
          return this._topParent.rtl;
        }
        return false;
      },
      /**
       * An RTL (right-to-left) setting.
       *
       * RTL may affect alignment, text, and other visual properties.
       *
       * If you set this on a top-level chart object, it will be used for all
       * child elements, e.g. labels, unless they have their own `rtl` setting
       * set directly on them.
       *
       * @param value  `true` for to use RTL
       */
      set: function(value) {
        value = toBoolean(value);
        if (this.isBaseSprite) {
          this.topParent.rtl = value;
        }
        this._rtl = value;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.show = function(duration) {
      return this.showReal(duration);
    };
    Sprite2.prototype.showReal = function(duration) {
      var _this = this;
      if (this.preventShow) {
        return;
      }
      var transition;
      var properties = this.defaultState.properties;
      if (!this.disabled && (this.isHidden || !this.visible || this.isHiding || properties.opacity != null && this.opacity < properties.opacity && !this.isShowing) && !this.isDisposed()) {
        if (this.invalid) {
          this.validate();
        }
        if (this.positionInvalid) {
          this.validatePosition();
        }
        if (!isNumber(duration)) {
          duration = this.defaultState.transitionDuration;
        }
        if (this._hideAnimation) {
          this._hideAnimation.kill();
          this._hideAnimation = void 0;
        }
        if (this._showHideDisposer) {
          this.removeDispose(this._showHideDisposer);
        }
        this._isHidden = false;
        this.isHiding = false;
        this.isShowing = true;
        transition = this.applyCurrentState(duration);
        if (transition && !transition.isFinished()) {
          this._showHideDisposer = transition.events.on("animationended", function() {
            _this.isShowing = false;
          });
          this._disposers.push(this._showHideDisposer);
        } else {
          this.isShowing = false;
        }
        var visible = this.defaultState.properties.visible;
        if (!hasValue(visible)) {
          visible = true;
        }
        this.visible = visible;
        this.readerHidden = false;
        this.dispatchImmediately("shown");
      }
      return transition;
    };
    Sprite2.prototype.hide = function(duration) {
      return this.hideReal(duration);
    };
    Sprite2.prototype.hideReal = function(duration) {
      var _this = this;
      var transition;
      if (!this.isHiding && this.visible && !this.isDisposed()) {
        if (this.tooltip && this.tooltip.currentSprite == this) {
          this.hideTooltip(0);
        }
        if (this._hideAnimation) {
          this._hideAnimation.kill();
          this._hideAnimation = void 0;
        }
        this.isShowing = false;
        if (this._showHideDisposer) {
          this.removeDispose(this._showHideDisposer);
        }
        var hiddenState_1 = this.hiddenState;
        if (hiddenState_1) {
          transition = this.setState(hiddenState_1, duration, void 0);
          if (transition && !transition.isFinished()) {
            this._hideAnimation = transition;
            this._showHideDisposer = transition.events.on("animationended", function() {
              _this.isHiding = false;
              _this._isHidden = true;
              if (hiddenState_1.properties.visible == false) {
                _this.visible = false;
              }
            }, this);
            this._disposers.push(this._showHideDisposer);
            this._disposers.push(transition);
          } else {
            this.isHiding = false;
            this._isHidden = true;
          }
        } else {
          this.visible = false;
          this.isHiding = false;
          this._isHidden = true;
        }
        this.readerHidden = true;
        this.dispatchImmediately("hidden");
        this.invalidate();
      }
      if (!isNumber(duration)) {
        duration = this.hiddenState.transitionDuration;
      }
      return transition;
    };
    Object.defineProperty(Sprite2.prototype, "visible", {
      /**
       * @return Visible?
       */
      get: function() {
        return this.getVisibility();
      },
      /**
       * Indicates if element is current visible (`true`) or hidden (`false`).
       *
       * @param value Visible?
       */
      set: function(value) {
        value = toBoolean(value);
        this.setVisibility(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.getVisibility = function() {
      var value = this.getPropertyValue("visible");
      if (!hasValue(value)) {
        value = true;
      }
      return value;
    };
    Sprite2.prototype.setVisibility = function(value) {
      if (this.setPropertyValue("visible", value)) {
        if (value) {
          this.group.removeAttr("visibility");
        } else {
          this.group.attr({ "visibility": "hidden" });
        }
        if (this.events.isEnabled("visibilitychanged")) {
          var event_4 = {
            type: "visibilitychanged",
            target: this,
            visible: value
          };
          this.events.dispatchImmediately("visibilitychanged", event_4);
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "zIndex", {
      /**
       * @return zIndex
       */
      get: function() {
        return this.getPropertyValue("zIndex");
      },
      /**
       * A "zIndex" of the element.
       *
       * "zIndex" determines the order of how elements are placed over each other.
       *
       * Higher "zIndex" will mean the element will be draw on top of elements
       * with lower "zIndexes".
       *
       * @param value  zIndex
       */
      set: function(value) {
        value = toNumber(value);
        if (this.setPropertyValue("zIndex", value)) {
          this.dispatch("zIndexChanged");
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.toFront = function() {
      var parent = this._parent;
      if (parent && parent.children.indexOf(this) != parent.children.length - 1) {
        parent.children.moveValue(this, parent.children.length - 1);
        this.dispatch("zIndexChanged");
      }
    };
    Sprite2.prototype.toBack = function() {
      var parent = this._parent;
      if (parent && parent.children.indexOf(this) != 0) {
        parent.children.moveValue(this, 0);
        this.dispatch("zIndexChanged");
      }
    };
    Object.defineProperty(Sprite2.prototype, "userClassName", {
      /**
       * @return Class name
       */
      get: function() {
        return this.getPropertyValue("userClassName");
      },
      /**
       * A custom class name to set on the element.
       *
       * If set, the value will be added to element's `class` attribute.
       *
       * @since 4.9.11
       * @param  value  Class name
       */
      set: function(value) {
        if (this.setPropertyValue("userClassName", value)) {
          if (!value && this.userClassName) {
            this.group.removeClass(this.userClassName);
          }
          this.setClassName();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltip", {
      /**
       * @return Tooltip
       */
      get: function() {
        if (this._tooltip) {
          return this._tooltip;
        } else if (this.virtualParent) {
          return this.virtualParent.tooltip;
        } else if (this._parent) {
          return this._parent.tooltip;
        }
      },
      /**
       * ==========================================================================
       * TOOLTIP-RELATED PROPERTIES STUFF
       * ==========================================================================
       * @hidden
       */
      /**
       * A [[Tooltip]] object to be used when displayed rollover information for
       * the element.
       *
       * @param tooltip  Tooltip
       */
      set: function(tooltip) {
        if (this._tooltip) {
          this.removeDispose(this._tooltip);
        }
        this._tooltip = tooltip;
        if (tooltip) {
          tooltip.parent = this.tooltipContainer;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipDataItem", {
      /**
       * @return Tooltip data item
       */
      get: function() {
        var tooltipDataItem = this._tooltipDataItem;
        if (tooltipDataItem) {
          return tooltipDataItem;
        } else {
          return this.dataItem;
        }
      },
      /**
       * A [[DataItem]] to use when populating content for the element's
       * [[Tooltip]].
       *
       * @see {@link Tooltip}
       * @see {@link DataItem}
       * @param value  Tooltip data item
       */
      set: function(value) {
        this._tooltipDataItem = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipColorSource", {
      /**
       * @return Tooltip color source
       */
      get: function() {
        return this._tooltipColorSource;
      },
      /**
       * A [[Sprite]] or sprite template to use when getting colors for tooltip. If a template is set,
       * tooltip will look for a clone in tooltipDataItem.sprites. If no clone is found, then template colors will be used.
       *
       * @see {@link Tooltip}
       * @see {@link Sprite}
       * @param sprite Sprite
       */
      set: function(sprite) {
        this._tooltipColorSource = sprite;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.showTooltip = function(point) {
      if (this.showTooltipOn == "always" && !this._tooltip && this.tooltip) {
        this._tooltip = this.tooltip.clone();
      }
      if (!point && this.tooltipPosition == "pointer" && this.isHover) {
        point = documentPointToSvg(getInteraction().lastPointer.point, this.svgContainer.SVGContainer, this.svgContainer.cssScale);
      }
      var sprite = this;
      while (sprite != void 0) {
        if (!sprite.visible || sprite.disabled || sprite.__disabled) {
          if (this._tooltip && this._tooltip.visible) {
            this._tooltip.hide(0);
          }
          return;
        }
        sprite = sprite.parent;
      }
      if (hasValue(this.tooltipText) || hasValue(this.tooltipHTML)) {
        var tooltip = this.tooltip;
        var tooltipDataItem = this.tooltipDataItem;
        if (tooltip) {
          tooltip.targetSprite = this;
          var colorSource_1 = this;
          var tooltipColorSource_1 = this.tooltipColorSource;
          if ((tooltip.getStrokeFromObject || tooltip.getFillFromObject) && tooltipColorSource_1) {
            if (tooltipColorSource_1.isTemplate) {
              if (tooltipDataItem) {
                eachContinue(tooltipDataItem.sprites, function(sprite2) {
                  if (sprite2.clonedFrom == tooltipColorSource_1) {
                    colorSource_1 = sprite2;
                    return false;
                  }
                  return true;
                });
              }
            } else {
              colorSource_1 = tooltipColorSource_1;
            }
          }
          if (tooltip.getStrokeFromObject) {
            var stroke = this.stroke;
            var source = colorSource_1;
            while (source.parent != void 0) {
              stroke = source.stroke;
              if (stroke == void 0) {
                source = source.parent;
              }
              if (stroke != void 0) {
                break;
              }
            }
            if (stroke instanceof Color) {
              tooltip.background.animate({ property: "stroke", to: stroke }, tooltip.animationDuration);
            } else {
              tooltip.background.stroke = stroke;
            }
          }
          tooltip.dataItem = tooltipDataItem;
          tooltip.label.populateStringFrom = this;
          if (tooltip.getFillFromObject) {
            var fill = this.fill;
            var source = colorSource_1;
            while (source.parent != void 0) {
              fill = source.fill;
              if (fill == void 0 || fill instanceof Color && fill.rgb == void 0) {
                source = source.parent;
              } else if (fill != void 0) {
                break;
              }
            }
            if (fill == void 0) {
              fill = color("#000000");
            }
            if (fill instanceof Color) {
              if (!tooltip.visible) {
                tooltip.background.fill = fill;
              } else {
                tooltip.background.animate({ property: "fill", to: fill }, tooltip.animationDuration);
              }
            } else {
              tooltip.background.fill = fill;
            }
            if (tooltip.autoTextColor && fill instanceof Color) {
              tooltip.label.fill = fill.alternative;
            }
          }
          var text = "";
          if (this.tooltipHTML) {
            tooltip.html = this.tooltipHTML;
            text = this.tooltipHTML;
          }
          if (this.tooltipText) {
            tooltip.text = this.tooltipText;
            text = this.tooltipText;
          }
          if (this.updateTooltipPosition(point)) {
            tooltip.readerDescribedBy = this.uidAttr();
            if (tooltip.label.invalid) {
              tooltip.label.validate();
            }
            if (text != void 0 && text != "" && tooltip.label.currentText != "") {
              if (tooltip && !tooltip.parent) {
                tooltip.parent = this.tooltipContainer;
              }
              var duration = tooltip.defaultState.transitionDuration;
              if (duration <= 0) {
                duration = 1;
              }
              tooltip.show(duration);
              tooltip.currentSprite = this;
              return true;
            } else {
              this.hideTooltip(0);
            }
          } else {
            this.hideTooltip(0);
          }
        }
      }
      return false;
    };
    Sprite2.prototype.updateTooltipPosition = function(point) {
      var _this = this;
      if (this.tooltipPosition == "pointer") {
        if (this._interactionDisposer) {
          this._interactionDisposer.dispose();
        }
        this._interactionDisposer = getInteraction().body.events.on("track", function(ev) {
          return _this.pointTooltipTo(documentPointToSvg(ev.point, _this.svgContainer.SVGContainer, _this.svgContainer.cssScale), true);
        });
        if (point) {
          return this.pointTooltipTo(point, true);
        }
      } else {
        var globalPoint = spritePointToSvg({
          "x": this.getTooltipX(),
          "y": this.getTooltipY()
        }, this);
        return this.pointTooltipTo(globalPoint);
      }
    };
    Sprite2.prototype.pointTooltipTo = function(point, instantly) {
      var tooltip = this.tooltip;
      if (tooltip && this.topParent) {
        if (tooltip.showInViewport) {
          tooltip.pointTo(point, instantly);
          return true;
        }
        if (isInRectangle(point, { x: 0, y: 0, width: this.topParent.maxWidth, height: this.topParent.maxHeight })) {
          tooltip.pointTo(point, instantly);
          return true;
        }
      }
      return false;
    };
    Sprite2.prototype.hideTooltip = function(duration) {
      if (this.showTooltipOn == "always") {
        return;
      }
      var tooltip = this.tooltip;
      if (tooltip) {
        if (tooltip.targetSprite == this) {
          tooltip.targetSprite = void 0;
        }
        tooltip.hide(duration);
        if (this._interactionDisposer) {
          this._interactionDisposer.dispose();
          this._interactionDisposer = void 0;
        }
      }
    };
    Object.defineProperty(Sprite2.prototype, "tooltipHTML", {
      /**
       * @return Tooltip HTML content template
       */
      get: function() {
        return this.getPropertyValue("tooltipHTML");
      },
      /**
       * An HTML template to be used to populate [[Tooltip]] contents.
       *
       * If element has `tooltipDataItem` or `dataItem` set, this will be parsed
       * for any data values to be replaced with the values from respective data
       * items.
       *
       * @param value Tooltip HTML content template
       */
      set: function(value) {
        value = toText(value);
        this.hoverable = true;
        if (this.setPropertyValue("tooltipHTML", value)) {
          if (this.tooltip) {
            if (this.tooltip.visible) {
              this.showTooltip();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipText", {
      /**
       * @return Tooltip content template
       */
      get: function() {
        return this.getPropertyValue("tooltipText");
      },
      /**
       * A text template to be used to populate Tooltip's contents.
       *
       * If element has `tooltipDataItem` or `dataItem` set, this will be parsed
       * for any data values to be replaced with the values from respective data
       * items.
       *
       * This template will also be parsed for any special formatting tags.
       *
       * @param value Tooltip content template
       * @see {@link TextFormatter}
       */
      set: function(value) {
        value = toText(value);
        if (value) {
          this.hoverable = true;
        }
        if (this.setPropertyValue("tooltipText", value)) {
          if (this.tooltip) {
            if (this.tooltip.visible) {
              this.showTooltip();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipContainer", {
      /**
       * @ignore Exclude from docs
       * @return Container
       */
      get: function() {
        if (this._tooltipContainer) {
          return this._tooltipContainer;
        } else if (this._parent) {
          return this._parent.tooltipContainer;
        }
      },
      /**
       * A container reference that should be used to place element's
       * [[Tooltip]] in.
       *
       * Will use parent's container if does not have one set.
       *
       * @ignore Exclude from docs
       * @param value Container
       * @todo Dispose of the old _tooltipContainer ?
       */
      set: function(value) {
        this._tooltipContainer = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipX", {
      /**
       * @return Tooltip X (px)
       */
      get: function() {
        return this.getTooltipX();
      },
      /**
       * X coordinate the [[Tooltip]] should be shown at.
       *
       * @param value  Tooltip X (px)
       */
      set: function(value) {
        if (this.setPercentProperty("tooltipX", value) && this.tooltip) {
          this.tooltip.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "alwaysShowTooltip", {
      /**
       * @return Always show tooltip?
       */
      get: function() {
        return this.getPropertyValue("showTooltipOn") == "always";
      },
      /**
       * DEPRECATION NOTICE: This setting is deprecated in favor of a more flexible
       * setting: `showTooltipOn`. Please use `showTooltipOn = "always"` instead.
       *
       * Indicates if this element should display a tooltip permanently.
       *
       * Useful, if you want to show permanent tooltips on some items.
       *
       * @default false
       * @since 4.5.4
       * @deprecated Use `showTooltipOn = "always"` instead
       * @param  value  Always show tooltip?
       */
      set: function(value) {
        value = toBoolean(value);
        if (value) {
          this.showTooltipOn = "always";
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "showTooltipOn", {
      /**
       * @return When to show tooltip
       */
      get: function() {
        return this.getPropertyValue("showTooltipOn");
      },
      /**
       * Indicates when tooltip needs to be shown on this element:
       *
       * * `"hover"` (default) - Tooltip will be shown when element is hovered on.
       * * `"hit"` - Tooltip will be shown when element is clicked/tapped. Tooltip will be hidden when clicked/tapped anywhere else.
       * * `"always"` - Tooltip will be shown on the element permanently.
       *
       * For example, if you would like to show tooltips on all of the columns of
       * a [[ColumnSeries]]:
       *
       * ```TypeScript
       * series.columns.template.showTooltipOn = "always";
       * ```
       * ```JavaScript
       * series.columns.template.showTooltipOn = "always";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "columns": {
       *       "showTooltipOn": "always"
       *     }
       *   }]
       * }
       * ```
       *
       * It can even be set to display on a selected columns via `propertyFields`:
       *
       * ```TypeScript
       * series.columns.template.propertyFields.showTooltipOn = "tooltip";
       * ```
       * ```JavaScript
       * series.columns.template.propertyFields.showTooltipOn = "tooltip";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "columns": {
       *       "propertyFields": {
       *         "showTooltipOn": "tooltip"
       *       }
       *     }
       *   }]
       * }
       * ```
       *
       * @default "hover"
       * @since 4.7.9
       * @param  value  When to show tooltip
       */
      set: function(value) {
        if (this.setPropertyValue("showTooltipOn", value)) {
          if (value == "hit") {
            this.clickable = true;
          }
          if (this.tooltip) {
            if (value == "always") {
              this.showTooltip();
            } else {
              this.handleAlwaysShowTooltip();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipPosition", {
      /**
       * Position
       */
      get: function() {
        return this.getPropertyValue("tooltipPosition");
      },
      /**
       * Specifies if [[Tooltip]] should follow the mouse or touch pointer or stay
       * at the fixed position.
       *
       * @param value  Position
       */
      set: function(value) {
        this.setPropertyValue("tooltipPosition", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tooltipY", {
      /**
       * @return Tooltip Y (px)
       */
      get: function() {
        return this.getTooltipY();
      },
      /**
       * Y coordinate the [[Tooltip]] should be shown at.
       *
       * @param value  Tooltip Y (px)
       */
      set: function(value) {
        if (this.setPercentProperty("tooltipY", value) && this.tooltip) {
          this.tooltip.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.getTooltipX = function() {
      var x = this.getPropertyValue("tooltipX");
      if (!hasValue(x)) {
        x = percent(50);
      }
      var value;
      if (isNumber(x)) {
        value = x;
      }
      if (x instanceof Percent) {
        value = this.maxLeftSelf + this._measuredWidthSelf * x.value - this.pixelPaddingLeft - this.ex;
      }
      if (!isNumber(value)) {
        value = 0;
      }
      return value;
    };
    Sprite2.prototype.getTooltipY = function() {
      var y = this.getPropertyValue("tooltipY");
      if (!hasValue(y)) {
        y = percent(50);
      }
      var value;
      if (isNumber(y)) {
        value = y;
      }
      if (y instanceof Percent) {
        value = this.maxTopSelf + this._measuredHeightSelf * y.value - this.pixelPaddingTop - this.ey;
      }
      if (!isNumber(value)) {
        value = 0;
      }
      return value;
    };
    Sprite2.prototype.raiseCriticalError = function(e, closable) {
      if (this.svgContainer) {
        if (!this._adapterO) {
          this.modal.content = e.message;
        } else {
          this.modal.content = this._adapterO.apply("criticalError", e).message;
        }
        if (!closable) {
          this.disabled = true;
        } else {
          this.modal.closable = true;
        }
        if (!options.suppressErrors) {
          this.modal.open();
        }
      }
      if (options.verbose) {
        console.log(e);
      }
    };
    Sprite2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.tooltipColorSource) && isString(config.tooltipColorSource) && this.map.hasKey(config.tooltipColorSource)) {
          config.tooltipColorSource = this.map.getKey(config.tooltipColorSource);
        }
        if (hasValue(config.cursorOverStyle) && isString(config.cursorOverStyle)) {
          config.cursorOverStyle = this.getCursorStyle(config.cursorOverStyle);
        }
        if (hasValue(config.cursorDowntyle) && isString(config.cursorDowntyle)) {
          config.cursorDowntyle = this.getCursorStyle(config.cursorDowntyle);
        }
        if (hasValue(config.cursorOptions)) {
          if (hasValue(config.cursorOptions.overStyle) && isString(config.cursorOptions.overStyle)) {
            config.cursorOptions.overStyle = this.getCursorStyle(config.cursorOptions.overStyle);
          }
          if (hasValue(config.cursorOptions.downStyle) && isString(config.cursorOptions.downStyle)) {
            config.cursorOptions.downStyle = this.getCursorStyle(config.cursorOptions.downStyle);
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
      this.processDelayedMap();
    };
    Sprite2.prototype.getCursorStyle = function(style) {
      switch (style) {
        case "grab":
          return MouseCursorStyle.grab;
        case "grabbing":
          return MouseCursorStyle.grabbing;
        case "pointer":
          return MouseCursorStyle.pointer;
        case "horizontalResize":
          return MouseCursorStyle.horizontalResize;
        case "verticalResize":
          return MouseCursorStyle.verticalResize;
        default:
          return MouseCursorStyle.default;
      }
    };
    Sprite2.prototype.configOrder = function(a, b) {
      if (a == b) {
        return 0;
      } else if (a == "tooltipColorSource") {
        return 1;
      } else if (b == "tooltipColorSource") {
        return -1;
      } else {
        return _super.prototype.configOrder.call(this, a, b);
      }
    };
    Object.defineProperty(Sprite2.prototype, "isHidden", {
      /**
       * If `sprite.hide()` is called, we set isHidden to true when sprite is hidden.
       * This was added becaus hidden state might have visibility set to true and so
       * there would not be possible to find out if a sprite is technically hidden or not.
       */
      get: function() {
        if (this._isHidden) {
          return this._isHidden;
        } else if (this._parent) {
          return this._parent.isHidden;
        }
        return false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "showOnInit", {
      /**
       * @return Show on init?
       */
      get: function() {
        return this.getPropertyValue("showOnInit");
      },
      /**
       * If this is set to `true`, Sprite, when inited will be instantly hidden
       * ("hidden" state applied) and then shown ("default" state applied).
       *
       * If your "default" state's `transitionDuration > 0` this will result in
       * initial animation from "hidden" state to "default" state.
       *
       * If you need a Sprite which has `showOnInit = true` not to be shown
       * initially, set `sprite.hidden = true`. Setting `sprite.visible = false`
       * will not prevent the animation and the sprite will be shown.
       *
       * @param value show on init?
       */
      set: function(value) {
        value = toBoolean(value);
        this.setShowOnInit(value);
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype.setShowOnInit = function(value) {
      if (this.setPropertyValue("showOnInit", value)) {
        if (!this.isTemplate) {
          if (value && !this.inited && !this.hidden) {
            this._showOnInitDisposer = new MultiDisposer([
              registry.events.once("enterframe", this.hideInitially, this),
              this.events.once("beforevalidated", this.hideInitially, this, false),
              this.events.on("inited", this.appear, this, false)
            ]);
            this._disposers.push(this._showOnInitDisposer);
          } else {
            if (this._showOnInitDisposer) {
              this._showOnInitDisposer.dispose();
            }
          }
        }
      }
    };
    Sprite2.prototype.hideInitially = function() {
      if (!this.isDisposed()) {
        this.appeared = false;
        if (!this.inited) {
          this.hide(0);
        }
      }
    };
    Sprite2.prototype.appear = function() {
      var _this = this;
      this.appeared = false;
      if (!this.hidden && !this.isHidden) {
        this.hide(0);
      }
      if (!this.hidden) {
        var animation = this.show();
        if (animation && !animation.isFinished()) {
          this.addDisposer(animation.events.on("animationended", function() {
            _this.appeared = true;
            _this.dispatch("appeared");
          }));
        } else {
          this.appeared = true;
          this.dispatch("appeared");
        }
      } else {
        this.appeared = true;
        this.dispatch("appeared");
      }
    };
    Object.defineProperty(Sprite2.prototype, "hidden", {
      /**
       * @return Is initially hidden?
       */
      get: function() {
        return this.getPropertyValue("hidden");
      },
      /**
       * If a sprite has `showOnInit = true`, it will animate from "hidden" to
       * "default" state when initialized. To prevent this but keep
       * `showOnInit = true`, you can set `sprite.hidden = true`.
       *
       * @param value initially hidden?
       */
      set: function(value) {
        value = toBoolean(value);
        this.setPropertyValue("hidden", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "bbox", {
      /**
       * Returns bounding box (square) for this element.
       *
       * @ignore Exclude from docs
       */
      get: function() {
        if (this.definedBBox) {
          return this.definedBBox;
        }
        return this._bbox;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "plugins", {
      /**
       * A list of plugins (objects that implement [[IPlugin]] interface) attached
       * to this object.
       *
       * @since 4.2.2
       * @return List of plugins
       */
      get: function() {
        var _this = this;
        if (!this._plugins) {
          this._plugins = new List();
          this._disposers.push(this._plugins.events.on("inserted", function(ev) {
            ev.newValue.target = _this;
            ev.newValue.init();
          }));
          this._disposers.push(new ListDisposer(this._plugins));
        }
        return this._plugins;
      },
      enumerable: true,
      configurable: true
    });
    Sprite2.prototype._systemUpdate = function(skippedSprites) {
      this.validate();
    };
    Sprite2.prototype._systemCheckIfValidate = function() {
      return true;
    };
    Sprite2.prototype._systemValidatePositions = function() {
      this.validatePosition();
    };
    Sprite2.prototype._systemValidateLayouts = function() {
    };
    return Sprite2;
  }(BaseObjectEvents)
);
registry.registeredClasses["Sprite"] = Sprite;

// node_modules/@amcharts/amcharts4/.internal/core/elements/Rectangle.js
var Rectangle = (
  /** @class */
  function(_super) {
    __extends(Rectangle2, _super);
    function Rectangle2() {
      var _this = _super.call(this) || this;
      _this.className = "Rectangle";
      _this.element = _this.paper.add("rect");
      _this.applyTheme();
      return _this;
    }
    Rectangle2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var precision = this._positionPrecision;
      if (this.pixelPerfect) {
        precision = 0;
      }
      var w = round(this.innerWidth, precision);
      var h = round(this.innerHeight, precision);
      this.element.attr({
        "width": w,
        "height": h
      });
    };
    Rectangle2.prototype.measureElement = function() {
    };
    Object.defineProperty(Rectangle2.prototype, "bbox", {
      /**
       * Returns bounding box (square) for this element.
       *
       * @ignore Exclude from docs
       */
      get: function() {
        if (this.definedBBox) {
          return this.definedBBox;
        }
        if (this.isMeasured) {
          return {
            x: 0,
            y: 0,
            width: this.innerWidth,
            height: this.innerHeight
          };
        } else {
          return { x: 0, y: 0, width: 0, height: 0 };
        }
      },
      enumerable: true,
      configurable: true
    });
    return Rectangle2;
  }(Sprite)
);
registry.registeredClasses["Rectangle"] = Rectangle;

// node_modules/@amcharts/amcharts4/.internal/core/Container.js
var Container = (
  /** @class */
  function(_super) {
    __extends(Container2, _super);
    function Container2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._childrenByLayout = [];
      _this._childrenDisposers = new Dictionary();
      _this.hasFocused = false;
      _this.setStateOnSprites = [];
      _this.layoutInvalid = false;
      _this._absoluteWidth = 0;
      _this._absoluteHeight = 0;
      _this._shouldBeReady = [];
      _this._tapToActivate = false;
      _this.tapTimeout = 3e3;
      _this.className = "Container";
      _this._element = _this.paper.addGroup("g");
      _this.group.add(_this.element);
      _this.setPropertyValue("pixelPerfect", false);
      _this.setPropertyValue("layout", "absolute");
      _this.setPropertyValue("fixedWidthGrid", false);
      _this.setPropertyValue("verticalCenter", "none");
      _this.setPropertyValue("horizontalCenter", "none");
      _this._positionPrecision = 4;
      _this._disposers.push(new DictionaryDisposer(_this._childrenDisposers));
      _this.children.events.on("inserted", _this.handleChildAdded, _this);
      _this.children.events.on("removed", _this.handleChildRemoved, _this);
      _this.applyTheme();
      return _this;
    }
    Container2.prototype.handleChildAdded = function(event) {
      this.processChild(event.newValue);
    };
    Container2.prototype.processChild = function(child) {
      try {
        this._childrenDisposers.insertKey(child.uid, new MultiDisposer([
          // it's not enough to listen to POSITION_CHANGED only, as some extra redrawals will happen.
          child.events.on("transformed", this.handleChildTransform, this),
          child.events.on("zIndexChanged", this.sortAndAdd, this)
        ]));
      } catch (err) {
      }
      if (this.element) {
        var group = this.element;
        group.add(child.group);
      }
      child.parent = this;
      child.paper = this.paper;
      this.dispatchImmediately("childadded", { type: "childadded", newValue: child });
      this.invalidate();
    };
    Container2.prototype.sortAndAdd = function() {
      this.sortChildren();
      this.addChildren();
    };
    Container2.prototype.handleChildRemoved = function(event) {
      var child = event.oldValue;
      this._childrenDisposers.removeKey(child.uid);
      if (this.element) {
        var group = this.element;
        group.removeElement(child.group);
      }
      if (child.isMeasured) {
        this.invalidateLayout();
      }
      this.dispatchImmediately("childremoved", { type: "childremoved", oldValue: child });
    };
    Container2.prototype.handleChildTransform = function(event) {
      var child = event.target;
      if (child.isMeasured) {
        this.invalidateLayout();
      }
    };
    Container2.prototype.invalidateLayout = function() {
      if (this.layoutInvalid || this.disabled || this.isTemplate || this.layout == "none" || this.__disabled) {
        return;
      }
      this.layoutInvalid = true;
      registry.addToInvalidLayouts(this);
      system.requestFrame();
    };
    Container2.prototype.invalidate = function() {
      _super.prototype.invalidate.call(this);
      this.invalidateLayout();
    };
    Container2.prototype.deepInvalidate = function() {
      _super.prototype.invalidate.call(this);
      each(this._childrenByLayout, function(child) {
        if (child instanceof Container2) {
          child.deepInvalidate();
        } else {
          child.invalidate();
        }
      });
      this.invalidateLayout();
    };
    Object.defineProperty(Container2.prototype, "children", {
      /**
       * Returns a list of the child [[Sprite]] elements contained in this
       * Container.
       *
       * @return List of child elements (Sprites)
       */
      get: function() {
        if (!this._children) {
          this._children = new List();
        }
        return this._children;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "minWidth", {
      /**
       * @return Width (px)
       */
      get: function() {
        return this.getPropertyValue("minWidth");
      },
      /**
       * Minimum width (px) for the Container. A container will not
       * auto-shrink beyond this value, even if child elements are smaller.
       *
       * @param value  Width (px)
       */
      set: function(value) {
        if (this.setPropertyValue("minWidth", value)) {
          this.invalidateLayout();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "minHeight", {
      /**
       * @return Height (px)
       */
      get: function() {
        return this.getPropertyValue("minHeight");
      },
      /**
       * Minimum height (px) for the Container. A container will not
       * auto-shrink beyond this value, even if child elements are smaller.
       *
       * @param value  Height (px)
       */
      set: function(value) {
        if (this.setPropertyValue("minHeight", value)) {
          this.invalidateLayout();
        }
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.removeElement = function() {
    };
    Container2.prototype.sortChildren = function() {
      var _this = this;
      this._childrenByLayout = [];
      if (this.layout == "none" || this.layout == "absolute" || !this.layout) {
        this._childrenByLayout = this.children.values;
      } else {
        var fixed_1 = [];
        var relative_1 = [];
        each3(this.children.iterator(), function(child) {
          if (_this.layout == "horizontal" || _this.layout == "grid") {
            if (!isNumber(child.percentWidth)) {
              fixed_1.push(child);
            } else {
              relative_1.push(child);
            }
          } else if (_this.layout == "vertical") {
            if (!isNumber(child.percentHeight)) {
              fixed_1.push(child);
            } else {
              relative_1.push(child);
            }
          } else {
            fixed_1.push(child);
          }
        });
        this._childrenByLayout = fixed_1.concat(relative_1);
      }
      this.calculateRelativeSize();
    };
    Container2.prototype.calculateRelativeSize = function() {
      var _this = this;
      var totalRelativeWidth = 0;
      var totalRelativeHeight = 0;
      each(this._childrenByLayout, function(child) {
        if (child.isMeasured) {
          if (isNumber(child.percentWidth)) {
            totalRelativeWidth += child.percentWidth;
          }
          if (isNumber(child.percentHeight)) {
            totalRelativeHeight += child.percentHeight;
          }
        }
      });
      each(this._childrenByLayout, function(child) {
        if (child.isMeasured) {
          if (_this.layout == "horizontal") {
            if (isNumber(child.percentWidth)) {
              child.relativeWidth = child.percentWidth / totalRelativeWidth;
            }
            if (isNumber(child.percentHeight)) {
              child.relativeHeight = child.percentHeight / 100;
            }
          }
          if (_this.layout == "vertical") {
            if (isNumber(child.percentHeight)) {
              child.relativeHeight = child.percentHeight / totalRelativeHeight;
            }
            if (isNumber(child.percentWidth)) {
              child.relativeWidth = child.percentWidth / 100;
            }
          }
          if (_this.layout == "grid") {
            if (isNumber(child.percentHeight)) {
              child.relativeHeight = child.percentHeight / 100;
            }
            if (isNumber(child.percentWidth)) {
              child.relativeWidth = child.percentWidth / 100;
            }
          }
        }
        if (_this.layout == "absolute" || !child.isMeasured) {
          if (isNumber(child.percentWidth)) {
            child.relativeWidth = child.percentWidth / 100;
          }
          if (isNumber(child.percentHeight)) {
            child.relativeHeight = child.percentHeight / 100;
          }
        }
      });
    };
    Container2.prototype.addChildren = function() {
      if (this.element) {
        var zindexed = copy(this.children.values);
        var sortArray = zindexed.map(function(data, idx) {
          return { idx, data };
        });
        sortArray.sort(function(a, b) {
          var ai = a.data.zIndex || 0;
          var bi = b.data.zIndex || 0;
          if (ai < bi) {
            return -1;
          }
          if (ai > bi) {
            return 1;
          }
          return a.idx - b.idx;
        });
        zindexed = sortArray.map(function(val) {
          return val.data;
        });
        var group_1 = this.element;
        var isCorrect = true;
        if (group_1.node && group_1.node.childNodes) {
          for (var i = 0, len = group_1.node.childNodes.length; i < len; i++) {
            if (group_1.node.childNodes[i] != zindexed[i].group.node) {
              isCorrect = false;
              break;
            }
          }
        }
        if (!isCorrect) {
          each(zindexed, function(child) {
            if (child.group) {
              group_1.add(child.group);
            }
          });
          if (this._background) {
            this.group.addToBack(this._background.group);
          }
          this.invalidateLayout();
        }
      }
    };
    Container2.prototype.createChild = function(classType) {
      var sprite = new classType();
      sprite.parent = this;
      return sprite;
    };
    Container2.prototype.removeChildren = function() {
      while (this.children.length > 0) {
        var child = this.children.getIndex(0);
        child.parent = void 0;
        this.children.removeValue(child);
      }
    };
    Container2.prototype.disposeChildren = function() {
      while (this.children.length > 0) {
        var child = this.children.getIndex(0);
        child.dispose();
        this.children.removeValue(child);
      }
    };
    Object.defineProperty(Container2.prototype, "background", {
      /**
       * @return Background element
       */
      get: function() {
        if (!this._background) {
          this._background = this.createBackground();
          this.processBackground();
        }
        return this._background;
      },
      /**
       * An element to use as container background.
       *
       * @param background  Background element
       */
      set: function(background) {
        if (this._background && this.background != background) {
          this.removeDispose(this._background);
        }
        if (background) {
          this._background = background;
          this._disposers.push(background);
          this.processBackground();
        }
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.handleGlobalScale = function() {
      _super.prototype.handleGlobalScale.call(this);
      this.children.each(function(child) {
        child.handleGlobalScale();
      });
    };
    Container2.prototype.createBackground = function() {
      return new Rectangle();
    };
    Container2.prototype.processBackground = function() {
      var background = this._background;
      if (background) {
        background.isMeasured = false;
        this._background.fill = new InterfaceColorSet().getFor("background");
        background.parent = this;
        background.isMeasured = false;
        this.children.removeValue(background);
        this._disposers.push(background);
        this.group.addToBack(this._background.group);
      }
    };
    Container2.prototype.validateLayout = function() {
      var _this = this;
      registry.removeFromInvalidLayouts(this);
      this.layoutInvalid = false;
      this._availableWidth = this.innerWidth;
      this._availableHeight = this.innerHeight;
      var measuredWidth = 0;
      var measuredHeight = 0;
      var allValid = true;
      if (this.children) {
        this.sortChildren();
        each(this._childrenByLayout, function(child) {
          var maxWidth;
          var maxHeight;
          if (isNumber(child.relativeWidth)) {
            maxWidth = round(_this._availableWidth * child.relativeWidth, 2);
            if (_this.layout == "horizontal") {
              maxWidth -= child.pixelMarginRight + child.pixelMarginLeft;
            }
          } else {
            if (_this.layout == "horizontal") {
              if (child.invalid) {
                child.validate();
              }
            }
          }
          if (isNumber(child.relativeHeight)) {
            maxHeight = round(_this._availableHeight * child.relativeHeight, 2);
            if (_this.layout == "vertical") {
              maxHeight -= child.pixelMarginTop + child.pixelMarginBottom;
            }
          } else {
            if (_this.layout == "vertical") {
              if (child.invalid) {
                child.validate();
              }
            }
          }
          if (child.invalid == false) {
            if (isNumber(child.relativeWidth)) {
              child.maxWidth = maxWidth;
            }
            if (isNumber(child.relativeHeight)) {
              child.maxHeight = maxHeight;
            }
            if (child.isMeasured) {
              if (_this.layout == "horizontal") {
                if (!isNumber(child.percentWidth)) {
                  if (child.measuredWidth > 0) {
                    _this._availableWidth -= child.measuredWidth + child.pixelMarginLeft + child.pixelMarginRight;
                  }
                }
              }
              if (_this.layout == "vertical") {
                if (!isNumber(child.percentHeight)) {
                  if (child.measuredHeight > 0) {
                    _this._availableHeight -= child.measuredHeight + child.pixelMarginTop + child.pixelMarginBottom;
                  }
                }
              }
              var childMeasuredWidth = child.measuredWidth;
              var childMeasuredHeight = child.measuredHeight;
              if (child.align != "none") {
                childMeasuredWidth += child.pixelMarginLeft + child.pixelMarginRight;
              }
              if (child.valign != "none") {
                childMeasuredHeight += child.pixelMarginTop + child.pixelMarginBottom;
              }
              measuredWidth = Math.max(measuredWidth, childMeasuredWidth);
              measuredHeight = Math.max(measuredHeight, childMeasuredHeight);
            }
          } else {
            if (child.isMeasured) {
              if (isNumber(child.relativeWidth)) {
                if (child.maxWidth != maxWidth) {
                  child.maxWidth = maxWidth;
                  allValid = false;
                }
              }
              if (isNumber(child.relativeHeight)) {
                if (child.maxHeight != maxHeight) {
                  child.maxHeight = maxHeight;
                  allValid = false;
                }
              }
            }
          }
        });
      }
      this._absoluteWidth = measuredWidth;
      this._absoluteHeight = measuredHeight;
      if (allValid) {
        this.arrange();
      }
    };
    Container2.prototype.arrange = function() {
      var _this = this;
      var children = this.children;
      var measuredWidth = 0;
      var measuredHeight = 0;
      var innerWidth = max(this.innerWidth, this._absoluteWidth);
      var innerHeight = max(this.innerHeight, this._absoluteHeight);
      var left;
      var right;
      var top;
      var bottom;
      var paddingLeft = this.pixelPaddingLeft;
      var paddingRight = this.pixelPaddingRight;
      var paddingTop = this.pixelPaddingTop;
      var paddingBottom = this.pixelPaddingBottom;
      var nextX = 0;
      var nextY = 0;
      var row = 0;
      var column = 0;
      var columnWidth = [];
      var rowHeight = [];
      var maxCellWidth;
      var minCellWidth;
      var columnCount;
      var maxWidth = this.maxWidth;
      var maxHeight = this.maxHeight;
      var minWidth = this.minWidth;
      var minHeight = this.minHeight;
      var childrenCopy = copy(children.values);
      if (this.reverseOrder) {
        childrenCopy.reverse();
      }
      if (this.layout == "grid") {
        minCellWidth = maxWidth;
        maxCellWidth = 1;
        for (var i = 0, len = childrenCopy.length; i < len; i++) {
          var child = childrenCopy[i];
          if (child.isMeasured && !child.disabled && !child.__disabled) {
            var childMeasuredWidth = child.measuredWidth;
            if (childMeasuredWidth < minCellWidth) {
              minCellWidth = childMeasuredWidth;
            }
            if (childMeasuredWidth > maxCellWidth) {
              maxCellWidth = childMeasuredWidth;
            }
          }
        }
        minCellWidth = fitToRange(minCellWidth, 1, maxWidth);
        maxCellWidth = fitToRange(maxCellWidth, 1, maxWidth);
        if (this.fixedWidthGrid) {
          columnCount = maxWidth / maxCellWidth;
        } else {
          columnCount = maxWidth / minCellWidth;
        }
        columnCount = max(1, Math.floor(columnCount));
        columnCount = min(this.maxColumns, columnCount);
        columnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);
      }
      var contentLeft;
      var contentRight;
      var contentTop;
      var contentBottom;
      for (var i = 0, len = childrenCopy.length; i < len; i++) {
        var child = childrenCopy[i];
        if (child.isMeasured && !child.disabled && !child.__disabled) {
          var x = void 0;
          var y = void 0;
          var childMarginLeft = child.pixelMarginLeft;
          var childMarginRight = child.pixelMarginRight;
          var childMarginTop = child.pixelMarginTop;
          var childMarginBottom = child.pixelMarginBottom;
          var childWidth = child.measuredWidth;
          var childHeight = child.measuredHeight;
          var childLeft = void 0;
          var childRight = void 0;
          var childTop = void 0;
          var childBottom = void 0;
          switch (this.layout) {
            case "none":
              break;
            case "absolute":
              switch (child.align) {
                case "left":
                  x = childMarginLeft - child.maxLeft;
                  break;
                case "center":
                  x = (innerWidth - childWidth) / 2 - child.maxLeft;
                  break;
                case "right":
                  x = innerWidth - childMarginRight - child.maxRight;
                  break;
                default:
                  if (!(child.x instanceof Percent)) {
                    x = child.pixelX;
                  }
                  break;
              }
              switch (child.valign) {
                case "top":
                  y = childMarginTop - child.maxTop;
                  break;
                case "middle":
                  y = (innerHeight - childHeight) / 2 - child.maxTop;
                  break;
                case "bottom":
                  y = innerHeight - childMarginBottom - child.maxBottom;
                  break;
                default:
                  if (!(child.y instanceof Percent)) {
                    y = child.pixelY;
                  }
                  break;
              }
              break;
            case "vertical":
              switch (child.align) {
                case "left":
                  x = childMarginLeft - child.maxLeft;
                  break;
                case "center":
                  x = (innerWidth - childWidth) / 2 - child.maxLeft;
                  break;
                case "right":
                  x = innerWidth - childMarginRight - child.maxRight;
                  break;
                default:
                  x = child.pixelX;
                  break;
              }
              y = nextY + childMarginTop - child.maxTop;
              nextY = y + child.maxBottom + childMarginBottom;
              break;
            case "horizontal":
              switch (child.valign) {
                case "top":
                  y = childMarginTop - child.maxTop;
                  break;
                case "middle":
                  y = (innerHeight - childHeight) / 2 - child.maxTop;
                  break;
                case "bottom":
                  y = innerHeight - childMarginBottom - child.maxBottom;
                  break;
                default:
                  y = child.pixelY;
                  break;
              }
              x = nextX + childMarginLeft - child.maxLeft;
              nextX = x + child.maxRight + childMarginRight;
              break;
            case "grid":
              x = nextX + childMarginLeft - child.maxLeft;
              switch (child.valign) {
                case "top":
                  y = nextY + childMarginTop - child.maxTop;
                  break;
                case "middle":
                  y = nextY + (innerHeight - childHeight) / 2 - child.maxTop;
                  break;
                case "bottom":
                  y = nextY + innerHeight - childMarginBottom - child.maxBottom;
                  break;
                default:
                  y = nextY - child.maxTop;
                  break;
              }
              nextX += columnWidth[column];
              rowHeight[row] = max(rowHeight[row], childHeight);
              column++;
              var nextColumnWidth = columnWidth[column];
              if (!isNumber(nextColumnWidth)) {
                nextColumnWidth = maxCellWidth;
              }
              if (nextX > min(this.innerWidth, maxWidth) - nextColumnWidth + 1 && column < columnCount) {
                columnCount = column;
                nextX = 0;
                nextY = 0;
                row = 0;
                column = 0;
                columnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);
                rowHeight = [];
                i = -1;
                continue;
              }
              if (column >= columnCount) {
                column = 0;
                nextY += rowHeight[row];
                row++;
                nextX = 0;
              }
              break;
          }
          if (this.layout !== "none") {
            child.moveTo({ x, y });
            childLeft = x + child.maxLeft - childMarginLeft;
            childRight = x + child.maxRight + childMarginRight;
            childTop = y + child.maxTop - childMarginTop;
            childBottom = y + child.maxBottom + childMarginBottom;
            if (childRight > right || !isNumber(right)) {
              right = childRight;
            }
            if (childLeft < left || !isNumber(left)) {
              left = childLeft;
            }
            if (childTop < top || !isNumber(top)) {
              top = childTop;
            }
            if (childBottom > bottom || !isNumber(bottom)) {
              bottom = childBottom;
            }
            if (childRight > contentRight || !isNumber(contentRight)) {
              contentRight = childRight;
            }
            if (childLeft < contentLeft || !isNumber(contentLeft)) {
              contentLeft = childLeft;
            }
            if (childTop < contentTop || !isNumber(contentTop)) {
              contentTop = childTop;
            }
            if (childBottom > contentBottom || !isNumber(contentBottom)) {
              contentBottom = contentBottom;
            }
          }
        } else {
          child.validatePosition();
        }
      }
      if (this.layout == "none") {
        var noneBBox = this.bbox;
        left = noneBBox.x;
        right = noneBBox.x + noneBBox.width;
        top = noneBBox.y;
        bottom = noneBBox.y + noneBBox.height;
      }
      if (!isNumber(left)) {
        left = 0;
        contentLeft = 0;
      }
      if (!isNumber(right)) {
        right = this._availableWidth;
        contentRight = right;
      }
      if (!isNumber(top)) {
        top = 0;
        contentTop = 0;
      }
      if (!isNumber(bottom)) {
        bottom = this._availableHeight;
        contentBottom = bottom;
      }
      if (!isNumber(contentTop)) {
        contentTop = 0;
      }
      if (!isNumber(contentBottom)) {
        contentBottom = contentTop;
      }
      if (!isNumber(contentLeft)) {
        contentLeft = 0;
      }
      if (!isNumber(contentRight)) {
        contentRight = contentLeft;
      }
      measuredWidth = right - left;
      measuredHeight = bottom - top;
      if (isNumber(this.relativeWidth)) {
        measuredWidth = maxWidth - paddingLeft - paddingRight;
        left = 0;
        right = measuredWidth;
      }
      if (isNumber(this.relativeHeight)) {
        measuredHeight = maxHeight - paddingTop - paddingBottom;
        top = 0;
        bottom = measuredHeight;
      }
      if (isNumber(this._pixelWidth)) {
        left = 0;
        measuredWidth = this._pixelWidth - paddingLeft - paddingRight;
      }
      if (isNumber(minWidth) && measuredWidth < minWidth) {
        left = 0;
        measuredWidth = this.minWidth - paddingLeft - paddingRight;
      }
      if (isNumber(this._pixelHeight)) {
        top = 0;
        measuredHeight = this._pixelHeight - paddingTop - paddingBottom;
      }
      if (isNumber(minHeight) && measuredHeight < minHeight) {
        top = 0;
        measuredHeight = minHeight - paddingTop - paddingBottom;
      }
      var measuredContentWidth = contentRight - contentLeft;
      var measuredContentHeight = contentBottom - contentTop;
      if (this.layout != "none" && (this.contentAlign || this.contentValign) && children.length > 0) {
        var dx_1;
        var dy_1;
        var mwa = measuredWidth;
        var mha = measuredHeight;
        if (mwa < measuredContentWidth) {
          mwa = measuredContentWidth;
        }
        if (mha < measuredContentHeight) {
          mha = measuredContentHeight;
        }
        if (this.contentAlign == "center") {
          dx_1 = (mwa - measuredContentWidth) / 2;
        }
        if (this.contentAlign == "right") {
          dx_1 = mwa - measuredContentWidth;
        }
        if (this.contentValign == "middle") {
          dy_1 = (mha - measuredContentHeight) / 2;
        }
        if (this.contentValign == "bottom") {
          dy_1 = mha - measuredContentHeight;
        }
        if (isNumber(dx_1)) {
          each3(children.iterator(), function(child2) {
            var childLeft2 = child2.maxLeft;
            var ddx = dx_1;
            if (_this.layout == "horizontal") {
              child2.x = child2.pixelX + ddx;
            }
            if (_this.layout == "grid") {
              child2.x = child2.pixelX + ddx;
            }
            if (_this.layout == "vertical") {
              ddx += child2.pixelMarginLeft;
              if (child2.align == "none") {
                child2.x = ddx - childLeft2;
              }
            }
            if (_this.layout == "absolute") {
              ddx += child2.pixelMarginLeft;
              if (child2.align == "none") {
                child2.x = ddx - childLeft2;
              }
            }
          });
        }
        if (isNumber(dy_1)) {
          each3(children.iterator(), function(child2) {
            var childTop2 = child2.maxTop;
            var ddy = dy_1;
            if (_this.layout == "horizontal") {
              ddy += child2.pixelMarginTop;
              if (child2.valign == "none") {
                child2.y = ddy - childTop2;
              }
            }
            if (_this.layout == "grid") {
              ddy += child2.pixelMarginTop;
              child2.y = ddy - childTop2;
            }
            if (_this.layout == "vertical") {
              child2.y = child2.pixelY + ddy;
            }
            if (_this.layout == "absolute") {
              ddy += child2.pixelMarginTop;
              if (child2.valign == "none") {
                child2.y = ddy - childTop2;
              }
            }
          });
        }
      }
      var oldBBox = this.bbox;
      measuredWidth = max(measuredWidth, minWidth);
      measuredHeight = max(measuredHeight, minHeight);
      this.contentWidth = measuredWidth;
      this.contentHeight = measuredHeight;
      measuredWidth = min(measuredWidth, maxWidth);
      measuredHeight = min(measuredHeight, maxHeight);
      this._bbox = { x: left, y: top, width: measuredWidth, height: measuredHeight };
      var prevLeft = this.maxLeft;
      var prevTop = this.maxTop;
      var prevBotttom = this.maxBottom;
      var prevRight = this.maxRight;
      this.measure();
      if (prevLeft != this.maxLeft || prevRight != this.maxRight || prevTop != this.maxTop || prevBotttom != this.maxBottom) {
        if (this.events.isEnabled("transformed")) {
          var event_1 = {
            type: "transformed",
            target: this
          };
          if (oldBBox) {
            event_1.dummyData = oldBBox.width + " " + measuredWidth + "  " + oldBBox.height + " " + measuredHeight;
          }
          this.events.dispatchImmediately("transformed", event_1);
        }
      }
      this.dispatchImmediately("layoutvalidated");
    };
    Container2.prototype.updateCenter = function() {
      _super.prototype.updateCenter.call(this);
      this.updateBackground();
    };
    Container2.prototype.updateBackground = function() {
      var background = this._background;
      if (background) {
        background.x = this.maxLeft;
        background.y = this.maxTop;
        background.width = this.maxRight - this.maxLeft;
        background.height = this.maxBottom - this.maxTop;
      }
    };
    Container2.prototype.getColumnWidth = function(children, columnCount, maxCellWidth) {
      var _this = this;
      var columnWidth = [];
      var column = 0;
      each(children, function(child) {
        if (child.isMeasured && !child.disabled && !child.__disabled) {
          if (_this.fixedWidthGrid) {
            columnWidth[column] = maxCellWidth;
          } else {
            columnWidth[column] = max(columnWidth[column], child.measuredWidth + child.pixelMarginRight + child.pixelMarginLeft);
          }
          column++;
          if (column == columnCount) {
            column = 0;
          }
        }
      });
      return columnWidth;
    };
    Object.defineProperty(Container2.prototype, "layout", {
      /**
       * @return Layout
       */
      get: function() {
        return this.getPropertyValue("layout");
      },
      /**
       * Container layout.
       *
       * Options: "absolute" (default), "vertical", "horizontal", "grid", "none". "none" is quite the same as "absolute" - the objects will
       * be positioned at their x, y coordinates, the difference is that with "absolute" you can still use align/valign for children and with "none" you can not.
       * Use "none" as much as you can as it's most cpu-saving layout.
       *
       * @default "absolute"
       * @param value Layout
       */
      set: function(value) {
        if (this.setPropertyValue("layout", value)) {
          this.invalidateLayout();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "contentValign", {
      /**
       * @return Vertical alignment
       */
      get: function() {
        return this.getPropertyValue("contentValign");
      },
      /**
       * Vertical alignment of the elements for the vertical Container.
       *
       * This is used when Container is larger than the height of all its children.
       *
       * @param value vertical alignment
       */
      set: function(value) {
        this.setPropertyValue("contentValign", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "contentAlign", {
      /**
       * @return Horizontal alignment
       */
      get: function() {
        return this.getPropertyValue("contentAlign");
      },
      /**
       * Horizontal alignment of the elements for the horizontal Container.
       *
       * This is used when Container is larger than the height of all its children.
       *
       * @param value  Horizontal alignment
       */
      set: function(value) {
        this.setPropertyValue("contentAlign", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "fixedWidthGrid", {
      /**
       * @return Should use fixed width grid?
       */
      get: function() {
        return this.getPropertyValue("fixedWidthGrid");
      },
      /**
       * Controls if the grid of the Container should use fixed width. Fixed width
       * grid will divide available space to all its columns/rows equally, without
       * adapting to actual child sizes or size requirements.
       *
       * @default false
       * @param value  Should use fixed width grid?
       */
      set: function(value) {
        this.setPropertyValue("fixedWidthGrid", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "maxColumns", {
      /**
       * @return Should use fixed width grid?
       */
      get: function() {
        return this.getPropertyValue("maxColumns");
      },
      /**
       * Maximum number of columns (when using `"grid"` layout).
       *
       * @param value  Should use fixed width grid?
       */
      set: function(value) {
        this.setPropertyValue("maxColumns", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "reverseOrder", {
      /**
       * @return Reverse children?
       */
      get: function() {
        return this.getPropertyValue("reverseOrder");
      },
      /**
       * If set to `true`, the children of the container will be drawn in reverse
       * order.
       *
       * @default false
       * @param value  Reverse children?
       */
      set: function(value) {
        this.setPropertyValue("reverseOrder", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "setStateOnChildren", {
      /**
       * @return Set state on children
       */
      get: function() {
        return this.getPropertyValue("setStateOnChildren");
      },
      /**
       * Specifies if, when state is applied on this container, the same state
       * should be applied to container's children as well as `background`.
       *
       * @default false
       * @param value  Set state on children
       */
      set: function(value) {
        this.setPropertyValue("setStateOnChildren", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.fitsToBounds = function(point) {
      var x = point.x;
      var y = point.y;
      var deviation = 0.5;
      if (x >= -deviation && x <= this.pixelWidth + deviation && y >= -deviation && y <= this.pixelHeight + deviation) {
        return true;
      } else {
        return false;
      }
    };
    Container2.prototype.copyFrom = function(source) {
      var _this = this;
      _super.prototype.copyFrom.call(this, source);
      this.layout = source.layout;
      this.setStateOnChildren = source.setStateOnChildren;
      if (source._background) {
        this.background = source._background.clone();
        this.background.copyFrom(source._background);
      }
      each3(source.children.iterator(), function(child) {
        if (child.shouldClone) {
          var clonedChild = child.clone();
          clonedChild.parent = _this;
        }
      });
    };
    Object.defineProperty(Container2.prototype, "preloader", {
      /**
       * @return Preloader instance
       */
      get: function() {
        var preloader = this._preloader;
        if (preloader) {
          return preloader;
        } else if (this.parent) {
          return this.parent.preloader;
        }
      },
      /**
       * A [[Preloader]] instance to be used when Container is busy.
       *
       * @param preloader  Preloader instance
       */
      set: function(preloader) {
        if (this._preloader) {
          this.removeDispose(this._preloader);
        }
        this._preloader = preloader;
        if (preloader) {
          preloader.parent = this.tooltipContainer;
          this._disposers.push(preloader);
        }
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.setPaper = function(paper) {
      var _this = this;
      var changed = _super.prototype.setPaper.call(this, paper);
      if (changed) {
        if (this._background) {
          this._background.paper = paper;
          this._background.topParent = this.topParent;
        }
        this.children.each(function(child) {
          child.setPaper(paper);
          child.topParent = _this.topParent;
        });
      }
      return changed;
    };
    Container2.prototype.removeFromInvalids = function() {
      _super.prototype.removeFromInvalids.call(this);
      registry.removeFromInvalidLayouts(this);
    };
    Container2.prototype.setDataItem = function(dataItem) {
      if (this._dataItem != dataItem) {
        each3(this.children.iterator(), function(child) {
          child.dataItem = dataItem;
        });
        if (this._background) {
          this._background.dataItem = dataItem;
        }
      }
      _super.prototype.setDataItem.call(this, dataItem);
    };
    Container2.prototype.measureElement = function() {
      if (this.disabled || this.isTemplate || this.layout == "none" || this.__disabled) {
      } else {
        this.validateLayout();
      }
    };
    Object.defineProperty(Container2.prototype, "fontFamily", {
      /**
       * @return Font family
       */
      get: function() {
        return this.getPropertyValue("fontFamily");
      },
      /**
       * Font family to be used for the text.
       *
       * Parts of the text may override this setting using in-line formatting.
       *
       * @param value Font family value
       */
      set: function(value) {
        if (this.setPropertyValue("fontFamily", value, true)) {
          this.setSVGAttribute({ "font-family": value });
          this.invalidateLabels();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "fontSize", {
      /**
       * @return Font size
       */
      get: function() {
        return this.getPropertyValue("fontSize");
      },
      /**
       * Font size to be used for the text. The size can either be numeric, in
       * pixels, or other measurements.
       *
       * Parts of the text may override this setting using in-line formatting.
       *
       * @param value Font size value
       */
      set: function(value) {
        if (this.setPropertyValue("fontSize", value, true)) {
          this.setSVGAttribute({ "font-size": value });
          this.invalidateLabels();
        }
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.invalidateLabels = function() {
      this.children.each(function(child) {
        if (child["hardInvalidate"]) {
          child["hardInvalidate"]();
          child.events.once("validated", child.handleValidate, child, false);
        } else if (child instanceof Container2) {
          child.invalidateLabels();
        }
      });
    };
    Object.defineProperty(Container2.prototype, "fontWeight", {
      /**
       * @return Font weight
       */
      get: function() {
        return this.getPropertyValue("fontWeight");
      },
      /**
       * Font weight to use for text.
       *
       * Parts of the text may override this setting using in-line formatting.
       *
       * @param value Font weight
       */
      set: function(value) {
        this.setPropertyValue("fontWeight", value);
        this.setSVGAttribute({ "font-weight": value });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "textDecoration", {
      /**
       * @return Decoration
       */
      get: function() {
        return this.getPropertyValue("textDecoration");
      },
      /**
       * A text decoration to use for text.
       *
       * Parts of the text may override this setting using in-line formatting.
       *
       * @param value  Decoration
       */
      set: function(value) {
        this.setPropertyValue("textDecoration", value);
        this.setSVGAttribute({ "text-decoration": value });
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.dispose = function() {
      if (this._background) {
        this._background.dispose();
      }
      this._shouldBeReady = [];
      this.disposeChildren();
      _super.prototype.dispose.call(this);
    };
    Container2.prototype.setState = function(value, transitionDuration, easing) {
      var stateName = value;
      if (value instanceof SpriteState) {
        stateName = value.name;
      }
      if (this.setStateOnChildren) {
        each3(this.children.iterator(), function(child) {
          child.setState(stateName, transitionDuration, easing);
          if (stateName != "active") {
            child.isActive = false;
          }
        });
      }
      if (this._background) {
        this._background.setState(stateName);
      }
      if (this.setStateOnSprites.length) {
        each(this.setStateOnSprites, function(item) {
          item.setState(stateName, transitionDuration, easing);
        });
      }
      return _super.prototype.setState.call(this, value, transitionDuration, easing);
    };
    Container2.prototype.setActive = function(value) {
      _super.prototype.setActive.call(this, value);
      if (this._background) {
        this._background.isActive = value;
      }
    };
    Container2.prototype.dispatchReady = function() {
      var _this = this;
      if (!this.isReady() && !this.isDisposed()) {
        var allReady_1 = true;
        eachContinue3(this.children.iterator(), function(sprite) {
          if (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {
            allReady_1 = false;
            return false;
          } else {
            return true;
          }
        });
        eachContinue(this._shouldBeReady, function(sprite) {
          if (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {
            allReady_1 = false;
            return false;
          } else {
            return true;
          }
        });
        if (allReady_1) {
          _super.prototype.dispatchReady.call(this);
        } else {
          registry.events.once("exitframe", function() {
            _this.dispatchReady();
            system.requestFrame();
          }, void 0, false);
        }
      }
    };
    Container2.prototype._systemUpdate = function(skippedSprites) {
      this.children.each(function(child) {
        if (child.invalid) {
          if (!child._systemCheckIfValidate()) {
            skippedSprites.push(child);
          } else if (child.dataItem && child.dataItem.component && child.dataItem.component.dataInvalid) {
            skippedSprites.push(child);
          } else {
            child.validate();
          }
        }
      });
      _super.prototype._systemUpdate.call(this, skippedSprites);
    };
    Container2.prototype._systemValidatePositions = function() {
      this.children.each(function(sprite) {
        if (sprite.positionInvalid) {
          sprite.validatePosition();
        }
      });
      _super.prototype._systemValidatePositions.call(this);
    };
    Container2.prototype._systemValidateLayouts = function() {
      if (this.layoutInvalid && !this.isDisposed()) {
        this.validateLayout();
      }
    };
    Object.defineProperty(Container2.prototype, "tapToActivate", {
      /**
       * @return Enable touch protection?
       */
      get: function() {
        return this._tapToActivate;
      },
      /**
       * If set to `true` the chart's regular touch functionality will be suspended
       * so that the whole page it is located in remains scrollable, even when
       * swiping over the chart's body.
       *
       * User will need to tap the chart in order to activate its regular touch
       * functionality.
       *
       * The chart will remain "active" as long as user keeps interacting with the
       * chart. After `tapTimeout` milliseconds the chart will return to its
       * "protected" mode.
       *
       * @default false
       * @since 4.4.0
       * @param  value  Enable touch protection?
       * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.
       */
      set: function(value) {
        if (this._tapToActivate != value) {
          this.setTapToActivate(value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Container2.prototype.setTapToActivate = function(value) {
      var _this = this;
      this._tapToActivate = value;
      this.interactions.isTouchProtected = value;
      if (value) {
        this.interactions.setEventDisposer("container-tapToActivate", value, function() {
          return new MultiDisposer([
            _this.events.on("hit", _this.handleTapToActivate, _this, false),
            _this.events.on("down", _this.initTapTimeout, _this, false),
            _this.events.on("track", _this.initTapTimeout, _this, false),
            //this.events.on("drag", this.initTapTimeout, this, false),
            getInteraction().body.events.on("down", function(ev) {
              if (!getInteraction().isLocalElement(ev.pointer, _this.paper.svg, _this.uid)) {
                _this.handleTapToActivateDeactivation();
              }
            }, _this, false)
          ]);
        });
      }
      getInteraction();
    };
    Container2.prototype.handleTapToActivate = function() {
      this.interactions.isTouchProtected = false;
      this.initTapTimeout();
    };
    Container2.prototype.handleTapToActivateDeactivation = function() {
      this.interactions.isTouchProtected = true;
    };
    Container2.prototype.initTapTimeout = function() {
      var _this = this;
      if (this._tapToActivateTimeout) {
        this._tapToActivateTimeout.dispose();
      }
      if (this.tapToActivate && !this.interactions.isTouchProtected && this.tapTimeout) {
        this._tapToActivateTimeout = this.setTimeout(function() {
          _this.handleTapToActivateDeactivation();
        }, this.tapTimeout);
      }
    };
    Container2.prototype.moveHtmlContainer = function(htmlElement) {
      var newContainer = getElement(htmlElement);
      if (newContainer) {
        this.htmlContainer = newContainer;
        var svgDiv = this.svgContainer;
        svgDiv.htmlElement = newContainer;
        svgDiv.htmlElement.appendChild(svgDiv.SVGContainer);
        svgDiv.initSensor();
        svgDiv.measure();
      } else if (isString(htmlElement) && htmlElement != "") {
        system.log("html container '" + htmlElement + "' not found");
      }
    };
    Container2.prototype.hasLicense = function() {
      if (options.commercialLicense) {
        return true;
      }
      for (var i = 0; i < options.licenses.length; i++) {
        if (options.licenses[i].match(/^CH.{5,}/i)) {
          return true;
        }
      }
      return false;
    };
    return Container2;
  }(Sprite)
);
registry.registeredClasses["Container"] = Container;

// node_modules/@amcharts/amcharts4/.internal/core/System.js
var System = (
  /** @class */
  function() {
    function System2() {
      this._isPaused = false;
      this.animations = [];
      this.uid = registry.getUniqueId();
      this.dummyCounter = 0;
      this._frameRequested = false;
      this.updateStepDuration = 45;
      this.time = Date.now();
    }
    System2.prototype.reportTime = function(msg, reset) {
      if (this.dummyCounter < 6) {
      }
      if (reset) {
        this.time = Date.now();
      }
    };
    System2.prototype.update = function() {
      var _this = this;
      if (this._isPaused) {
        return;
      }
      this._frameRequested = false;
      var time = Date.now();
      registry.dispatchImmediately("enterframe");
      var skippedComponents = [];
      for (var key in registry.invalidDatas) {
        if (hasKey(registry.invalidDatas, key)) {
          var invalidData = registry.invalidDatas[key];
          while (invalidData.length > 0) {
            var component = invalidData[0];
            var dataProvider = component.dataProvider;
            if (!component.isDisposed()) {
              if (dataProvider && dataProvider.dataInvalid) {
                try {
                  dataProvider.validateData();
                  if (dataProvider.dataValidationProgress < 1) {
                    break;
                  }
                } catch (e) {
                  remove(invalidData, dataProvider);
                  dataProvider.raiseCriticalError(e);
                }
              } else {
                try {
                  component.validateData();
                  if (component.dataValidationProgress < 1) {
                    break;
                  }
                } catch (e) {
                  remove(invalidData, component);
                  component.raiseCriticalError(e);
                }
              }
            } else {
              remove(invalidData, component);
            }
          }
          if (Date.now() - time > this.updateStepDuration) {
            break;
          }
        }
      }
      while (registry.invalidRawDatas.length > 0) {
        var component = registry.invalidRawDatas[0];
        if (!component.isDisposed()) {
          try {
            component.validateRawData();
          } catch (e) {
            remove(registry.invalidRawDatas, component);
            component.raiseCriticalError(e);
          }
        } else {
          remove(registry.invalidRawDatas, component);
        }
      }
      while (registry.invalidDataItems.length > 0) {
        var component = registry.invalidDataItems[0];
        var dataProvider = component.dataProvider;
        if (component.isDisposed() || component.dataInvalid || dataProvider && dataProvider.dataInvalid) {
        } else {
          try {
            component.validateDataItems();
          } catch (e) {
            remove(registry.invalidDataItems, component);
            component.raiseCriticalError(e);
          }
        }
        remove(registry.invalidDataItems, component);
      }
      while (registry.invalidDataRange.length > 0) {
        var component = registry.invalidDataRange[0];
        var dataProvider = component.dataProvider;
        if (component.isDisposed() || component.dataInvalid || dataProvider && dataProvider.dataInvalid) {
        } else {
          try {
            component.validateDataRange();
            if (!component.skipRangeEvent) {
              component.dispatchImmediately("datarangechanged");
            }
            component.skipRangeEvent = false;
          } catch (e) {
            remove(registry.invalidDataRange, component);
            component.raiseCriticalError(e);
          }
        }
        remove(registry.invalidDataRange, component);
      }
      var skippedSprites = [];
      each2(registry.invalidLayouts, function(key2) {
        _this.validateLayouts(key2);
      });
      each2(registry.invalidPositions, function(key2) {
        _this.validatePositions(key2);
      });
      var hasSkipped = false;
      time = Date.now();
      each2(registry.invalidSprites, function(key2, invalidSprites) {
        var count = 0;
        while (invalidSprites.length > 0) {
          _this.validateLayouts(key2);
          _this.validatePositions(key2);
          count++;
          if (count == 5) {
            if (Date.now() - time > _this.updateStepDuration) {
              break;
            }
            count = 0;
          }
          var sprite = invalidSprites[invalidSprites.length - 1];
          if (sprite && !sprite.isDisposed()) {
            if (!sprite._systemCheckIfValidate()) {
              skippedSprites.push(sprite);
            } else {
              if (!_this.checkIfValidate2(sprite)) {
                skippedSprites.push(sprite);
              } else {
                try {
                  sprite._systemUpdate(skippedSprites);
                } catch (e) {
                  sprite.invalid = false;
                  remove(invalidSprites, sprite);
                  sprite.raiseCriticalError(e);
                }
              }
            }
            sprite.invalid = false;
          }
          remove(invalidSprites, sprite);
        }
        registry.invalidSprites[key2] = registry.invalidSprites[key2].concat(skippedSprites);
      });
      each2(registry.invalidSprites, function(key2, value) {
        if (value.length > 0) {
          hasSkipped = true;
        }
      });
      each2(registry.invalidDatas, function(key2, value) {
        if (value.length > 0) {
          hasSkipped = true;
        }
      });
      each(copy(this.animations), function(x) {
        x.update();
      });
      each2(registry.invalidLayouts, function(key2) {
        _this.validateLayouts(key2);
      });
      each2(registry.invalidPositions, function(key2) {
        _this.validatePositions(key2);
      });
      triggerIdle();
      each2(registry.invalidLayouts, function(key2) {
        _this.validateLayouts(key2);
      });
      each2(registry.invalidPositions, function(key2) {
        _this.validatePositions(key2);
      });
      registry.dispatchImmediately("exitframe");
      if (hasSkipped || this.animations.length > 0 || skippedComponents.length > 0) {
        this.requestFrame();
      }
      if (this.updateStepDuration < 200) {
        var all0_1 = true;
        each2(registry.invalidDatas, function(key2, value) {
          if (value.length > 0) {
            all0_1 = false;
          }
        });
        each2(registry.invalidSprites, function(key2, value) {
          if (value.length > 0) {
            all0_1 = false;
          }
        });
        if (all0_1) {
          this.updateStepDuration = 200;
        }
      }
    };
    System2.prototype.checkIfValidate2 = function(sprite) {
      if (sprite.dataItem && sprite.dataItem.component && sprite.dataItem.component.dataInvalid && !sprite.dataItem.component.isTemplate) {
        return false;
      } else {
        return true;
      }
    };
    System2.prototype.requestFrame = function() {
      var _this = this;
      if (!this._frameRequested) {
        raf(function() {
          _this.update();
        });
        this._frameRequested = true;
      }
    };
    System2.prototype.softInvalidate = function(container) {
      var _this = this;
      container.children.each(function(child) {
        if (child instanceof Container) {
          _this.softInvalidate(child);
        }
        if (child.measureFailed) {
          if (is(child, "Label")) {
            child.hardInvalidate();
          } else {
            child.invalidate();
          }
          child.measureFailed = false;
        }
      });
    };
    System2.prototype.validatePositions = function(id) {
      var invalidPositions = registry.invalidPositions[id];
      while (invalidPositions.length > 0) {
        var sprite = invalidPositions[invalidPositions.length - 1];
        if (!sprite.isDisposed()) {
          try {
            sprite._systemValidatePositions();
          } catch (e) {
            sprite.positionInvalid = false;
            remove(invalidPositions, sprite);
            sprite.raiseCriticalError(e);
          }
        } else {
          remove(invalidPositions, sprite);
        }
      }
    };
    System2.prototype.validateLayouts = function(id) {
      var invalidLayouts = registry.invalidLayouts[id];
      while (invalidLayouts.length > 0) {
        var container = invalidLayouts[invalidLayouts.length - 1];
        if (!container.isDisposed()) {
          try {
            container.children.each(function(sprite) {
              sprite._systemValidateLayouts();
            });
            container.validateLayout();
          } catch (e) {
            container.layoutInvalid = false;
            remove(invalidLayouts, container);
            container.raiseCriticalError(e);
          }
        } else {
          remove(invalidLayouts, container);
        }
      }
    };
    System2.prototype.log = function(value) {
      log(value);
    };
    Object.defineProperty(System2.prototype, "isPaused", {
      /**
       * @return Is system on pause?
       */
      get: function() {
        return this._isPaused;
      },
      /**
       * Pauses all the processes of all the amCharts objects on the page
       *
       * @return is paused?
       */
      set: function(value) {
        this._isPaused = value;
        if (!value) {
          this._frameRequested = false;
          this.requestFrame();
        }
      },
      enumerable: true,
      configurable: true
    });
    System2.VERSION = "4.10.38";
    return System2;
  }()
);
var system = new System();

// node_modules/@amcharts/amcharts4/.internal/core/utils/Animation.js
function animate(duration, callback) {
  var disposed = false;
  var startTime = Date.now();
  function loop(now2) {
    if (!disposed) {
      var diff = now2 - startTime;
      if (diff >= duration) {
        callback(1);
      } else {
        nextFrame(loop);
        callback(diff / duration);
      }
    }
  }
  nextFrame(loop);
  return new Disposer(function() {
    disposed = true;
  });
}
function getProgressNumber(progress, from, to) {
  return from + (to - from) * progress;
}
function getProgressPercent(progress, from, to) {
  return new Percent(getProgressNumber(progress, from.percent, to.percent));
}
function getProgressColor(progress, from, to) {
  var color2 = new Color(interpolate(from.rgb, to.rgb, progress));
  if (from.alpha != to.alpha) {
    color2.alpha = from.alpha + (to.alpha - from.alpha) * progress;
  }
  return color2;
}
function getHybridProperty(property, type) {
  return type + property.charAt(0).toUpperCase() + property.substr(1);
}
var AnimationDisposer = (
  /** @class */
  function() {
    function AnimationDisposer2(array) {
      this._disposer = new Disposer(function() {
        while (array.length !== 0) {
          array[0].dispose();
        }
      });
    }
    AnimationDisposer2.prototype.isDisposed = function() {
      return this._disposer.isDisposed();
    };
    AnimationDisposer2.prototype.dispose = function() {
      this._disposer.dispose();
    };
    return AnimationDisposer2;
  }()
);
var Animation = (
  /** @class */
  function(_super) {
    __extends(Animation2, _super);
    function Animation2(object, animationOptions, duration, easing) {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.duration = 0;
      _this.easing = linear;
      _this.progress = 0;
      _this._loop = 0;
      _this._pause = false;
      _this._delayTimeout = null;
      _this._time = 0;
      _this._isFinished = false;
      _this.className = "Animation";
      if (options.animationsEnabled === false) {
        duration = 0;
      }
      _this.object = object;
      _this.animationOptions = toArray(animationOptions);
      _this.duration = duration;
      if (easing) {
        _this.easing = easing;
      }
      _this.applyTheme();
      return _this;
    }
    Animation2.prototype.debug = function() {
    };
    Animation2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      this.pause();
    };
    Animation2.prototype.delay = function(delay) {
      var _this = this;
      if (delay > 0) {
        this.pause();
        move(this.object.animations, this);
        var id_1 = setTimeout(function() {
          _this._delayTimeout = null;
          _this.start();
        }, delay);
        this._delayTimeout = new Disposer(function() {
          clearTimeout(id_1);
        });
      }
      return this;
    };
    Animation2.prototype._start = function() {
      this._isFinished = false;
      if (this._delayTimeout) {
        this.removeDispose(this._delayTimeout);
        this._delayTimeout = null;
      }
      this.stopSameAnimations();
      this._pause = false;
      move(system.animations, this);
      move(this.object.animations, this);
      system.requestFrame();
    };
    Animation2.prototype.start = function() {
      this._start();
      this._startTime = Date.now();
      this._time = 0;
      this.staticOptions = [];
      for (var i = this.animationOptions.length - 1; i >= 0; i--) {
        var options_1 = this.animationOptions[i];
        if (!hasValue(options_1.from)) {
          if (options_1.childObject) {
            options_1.from = options_1.childObject[options_1.property];
          } else {
            options_1.from = this.object[options_1.property];
            if (!hasValue(options_1.from)) {
              options_1.from = SVGDefaults[options_1.property];
            }
          }
        }
        if (options_1.from == options_1.to) {
          remove(this.animationOptions, options_1);
        } else if (!hasValue(options_1.from) || !(options_1.from instanceof Percent) && options_1.to instanceof Percent || options_1.from instanceof Percent && !(options_1.to instanceof Percent)) {
          this.staticOptions.push(options_1);
          remove(this.animationOptions, options_1);
        } else {
          if (isNumber(options_1.to)) {
            options_1.updateMethod = getProgressNumber;
            if (options_1.from instanceof Percent) {
              var convertedFrom = this.object[getHybridProperty(options_1.property, "pixel")];
              if (!isNaN(convertedFrom)) {
                options_1.from = convertedFrom;
              } else {
                this.staticOptions.push(options_1);
                remove(this.animationOptions, options_1);
              }
            } else if (isNaN(options_1.from)) {
              this.staticOptions.push(options_1);
              remove(this.animationOptions, options_1);
            }
          } else {
            if (options_1.to instanceof Color) {
              if (options_1.from) {
                options_1.updateMethod = getProgressColor;
              } else {
                this.staticOptions.push(options_1);
                remove(this.animationOptions, options_1);
              }
            } else if (options_1.to instanceof Percent) {
              options_1.updateMethod = getProgressPercent;
              if (!isNaN(options_1.from)) {
                var convertedFrom = this.object[getHybridProperty(options_1.property, "relative")];
                if (!isNaN(convertedFrom)) {
                  options_1.from = percent(convertedFrom * 100);
                }
              }
            } else {
              this.staticOptions.push(options_1);
              remove(this.animationOptions, options_1);
            }
          }
        }
      }
      this.applyStaticOptions();
      if (this.events.isEnabled("animationstarted")) {
        var event_1 = {
          type: "animationstarted",
          target: this,
          progress: this.progress
        };
        this.events.dispatchImmediately("animationstarted", event_1);
      }
      this.update();
      if (this.duration === 0) {
        this.end();
      }
      return this;
    };
    Animation2.prototype.loop = function(count) {
      if (!isNumber(count)) {
        count = Infinity;
      }
      this._loop = count;
      return this;
    };
    Animation2.prototype.pause = function() {
      this._pause = true;
      if (this._delayTimeout) {
        this.removeDispose(this._delayTimeout);
        this._delayTimeout = null;
      }
      remove(system.animations, this);
      remove(this.object.animations, this);
      return this;
    };
    Animation2.prototype.resume = function() {
      this._start();
      this._startTime = Date.now() - this._time;
      return this;
    };
    Animation2.prototype.end = function() {
      if (this._loop == 0) {
        this.pause();
      }
      this.setProgress(1);
      this.applyStaticOptions();
      if (this.events.isEnabled("animationended")) {
        var event_2 = {
          type: "animationended",
          target: this,
          progress: this.progress
        };
        this.events.dispatchImmediately("animationended", event_2);
      }
      if (this._loop > 0) {
        this._loop--;
        this.start();
      } else {
        this.stop();
        this._isFinished = true;
      }
      return this;
    };
    Animation2.prototype.kill = function() {
      this.pause();
      this._isFinished = true;
    };
    Animation2.prototype.isFinished = function() {
      return this._isFinished;
    };
    Animation2.prototype.applyStaticOptions = function() {
      var _this = this;
      each(this.staticOptions, function(options2) {
        if (options2.childObject) {
          options2.childObject[options2.property] = _this.progress == 1 ? options2.to : options2.from;
        } else {
          _this.object[options2.property] = _this.progress == 1 ? options2.to : options2.from;
        }
      });
    };
    Animation2.prototype.stop = function(skipEvent) {
      this.pause();
      if (!skipEvent) {
        if (this.events.isEnabled("animationstopped")) {
          var event_3 = {
            type: "animationstopped",
            target: this,
            progress: this.progress
          };
          this.events.dispatchImmediately("animationstopped", event_3);
        }
      }
      return this;
    };
    Animation2.prototype.setProgress = function(progress) {
      var _this = this;
      this._time = this.duration * progress;
      each(this.animationOptions, function(options2) {
        if (options2.updateMethod && hasValue(options2.from)) {
          var value = options2.updateMethod(progress, options2.from, options2.to);
          if (options2.childObject) {
            options2.childObject[options2.property] = value;
          } else {
            _this.object[options2.property] = value;
          }
        }
      });
      this.progress = progress;
      if (this.events.isEnabled("animationprogress")) {
        var event_4 = {
          type: "animationprogress",
          target: this,
          progress: this.progress
        };
        this.events.dispatchImmediately("animationprogress", event_4);
      }
      system.requestFrame();
    };
    Animation2.prototype.update = function() {
      if (!this._pause) {
        var progress = void 0;
        this._time = fitToRange(Date.now() - this._startTime, 0, this.duration);
        var timeProgress = this._time / this.duration;
        progress = this.easing(timeProgress);
        if (this.duration == 0 || !isNumber(progress) || timeProgress >= 1) {
          progress = 1;
        }
        this.setProgress(progress);
        if (round(this._time / this.duration, 6) == 1) {
          this.end();
        }
      }
      return this;
    };
    Object.defineProperty(Animation2.prototype, "delayed", {
      /**
       * Returns `true` if this animation is delayed.
       *
       * @readonly
       * @return [description]
       */
      get: function() {
        return this._delayTimeout ? true : false;
      },
      enumerable: true,
      configurable: true
    });
    Animation2.prototype.stopSameAnimations = function() {
      var _this = this;
      each(copy(this.object.animations), function(animation) {
        if (animation !== _this && !animation.delayed) {
          var killed_1 = [];
          each(_this.animationOptions, function(newOptions) {
            each(animation.animationOptions, function(oldOptions) {
              if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {
                killed_1.push(oldOptions);
                if (animation.animationOptions.length == 0) {
                  animation.kill();
                }
              }
            });
          });
          each(killed_1, function(oldOptions) {
            remove(animation.animationOptions, oldOptions);
          });
        }
      });
    };
    Animation2.prototype.asFunction = function(field) {
      return field == "easing" || _super.prototype.asIs.call(this, field);
    };
    return Animation2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/data/DataParser.js
var DataParser = (
  /** @class */
  function() {
    function DataParser2() {
    }
    DataParser2.prototype.parse = function(data) {
      return [];
    };
    ;
    Object.defineProperty(DataParser2.prototype, "parsableNumbers", {
      /**
       * Checks if there are any numeric fields that need to be converted to
       * numbers.
       *
       * @return Numeric fields?
       */
      get: function() {
        return this.options.numberFields && this.options.numberFields.length > 0;
      },
      enumerable: true,
      configurable: true
    });
    DataParser2.prototype.maybeToNumber = function(field, value) {
      if (this.options.numberFields.indexOf(field) !== -1) {
        return anyToNumber(value);
      }
      return value;
    };
    Object.defineProperty(DataParser2.prototype, "parsableDates", {
      /**
       * Checks if there are any date fields that need to be converted to `Date`
       * objects.
       *
       * @return Date fields?
       */
      get: function() {
        return this.options.dateFields && this.options.dateFields.length > 0;
      },
      enumerable: true,
      configurable: true
    });
    DataParser2.prototype.maybeToDate = function(field, value) {
      if (this.options.dateFields.indexOf(field) !== -1) {
        return this.options.dateFormatter.parse(value, this.dateFormat);
      }
      return value;
    };
    DataParser2.prototype.maybeToEmpty = function(value) {
      if ((!hasValue(value) || value == "") && hasValue(this.options.emptyAs)) {
        return this.options.emptyAs;
      }
      return value;
    };
    Object.defineProperty(DataParser2.prototype, "dateFormatter", {
      /**
       * [[DateFormatter]] object for date parsing.
       *
       * If there was not [[DateFormatter]] supplied in parser options, a new one
       * is created.
       *
       * @return Date formatter
       * @see {@link DateFormatter}
       */
      get: function() {
        if (!this.options.dateFormatter) {
          this.options.dateFormatter = new DateFormatter();
          if (this.options.dateFormat) {
            this.options.dateFormat = this.options.dateFormat;
          }
        }
        return this.options.dateFormatter;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataParser2.prototype, "dateFormat", {
      /**
       * A date format to use when parsing dates.
       *
       * @return Date format
       * @see {@link DateFormatter}
       */
      get: function() {
        return this.options.dateFormat || this.dateFormatter.inputDateFormat;
      },
      enumerable: true,
      configurable: true
    });
    return DataParser2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/data/CSVParser.js
var separators = [",", ";", "	"];
var CSVParser = (
  /** @class */
  function(_super) {
    __extends(CSVParser2, _super);
    function CSVParser2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.contentType = "text/csv";
      _this.options = {
        delimiter: "",
        reverse: false,
        skipRows: 0,
        skipEmpty: true,
        useColumnNames: false
      };
      return _this;
    }
    CSVParser2.isCSV = function(data) {
      return CSVParser2.getDelimiterFromData(data) ? true : false;
    };
    CSVParser2.getDelimiterFromData = function(data) {
      var lines = data.split("\n");
      var len = lines.length;
      var separator;
      each(separators, function(sep) {
        var columns = 0, lineColums = 0;
        for (var i = 0; i < len; ++i) {
          columns = lines[i].split(sep).length;
          if (columns > 1) {
            if (lineColums === 0) {
              lineColums = columns;
            } else if (columns != lineColums) {
              lineColums = 0;
              break;
            }
          } else {
            lineColums = 0;
            break;
          }
        }
        if (lineColums) {
          separator = sep;
        }
      });
      return separator;
    };
    CSVParser2.prototype.parse = function(csv) {
      if (!this.options.delimiter) {
        this.options.delimiter = CSVParser2.getDelimiterFromData(csv);
      }
      var data = this.CSVToArray(csv, this.options.delimiter);
      var empty = hasValue(this.options.emptyAs);
      var numbers = this.parsableNumbers;
      var dates = this.parsableDates;
      var res = [], cols = [], col, i;
      for (i = 0; i < this.options.skipRows; i++) {
        data.shift();
      }
      if (this.options.useColumnNames) {
        cols = data.shift();
        for (var x = 0; x < cols.length; x++) {
          col = hasValue(cols[x]) ? cols[x].replace(/^\s+|\s+$/gm, "") : "";
          if ("" === col) {
            col = "col" + x;
          }
          cols[x] = col;
        }
      }
      var row;
      while (true) {
        row = this.options.reverse ? data.pop() : data.shift();
        if (!row) {
          break;
        }
        if (this.options.skipEmpty && row.length === 1 && row[0] === "") {
          continue;
        }
        var dataPoint = {};
        for (i = 0; i < row.length; i++) {
          col = void 0 === cols[i] ? "col" + i : cols[i];
          dataPoint[col] = row[i] === "" ? this.options.emptyAs : row[i];
          if (empty) {
            dataPoint[col] = this.maybeToEmpty(dataPoint[col]);
          }
          if (numbers) {
            dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);
          }
          if (dates) {
            dataPoint[col] = this.maybeToDate(col, dataPoint[col]);
          }
        }
        res.push(dataPoint);
      }
      return res;
    };
    CSVParser2.prototype.CSVToArray = function(data, delimiter) {
      delimiter = delimiter || ",";
      var objPattern = new RegExp(
        // Delimiters.
        "(\\" + delimiter + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + delimiter + "\\r\\n]*))",
        "gi"
      );
      var arrData = [
        []
      ];
      var arrMatches = null;
      while (true) {
        arrMatches = objPattern.exec(data);
        if (!arrMatches) {
          break;
        }
        var strMatchedDelimiter = arrMatches[1];
        if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {
          arrData.push([]);
        }
        var strMatchedValue = void 0;
        if (arrMatches[2]) {
          strMatchedValue = arrMatches[2].replace(new RegExp('""', "g"), '"');
        } else {
          strMatchedValue = arrMatches[3];
        }
        arrData[arrData.length - 1].push(strMatchedValue);
      }
      return arrData;
    };
    return CSVParser2;
  }(DataParser)
);

// node_modules/@amcharts/amcharts4/.internal/core/data/JSONParser.js
var JSONParser = (
  /** @class */
  function(_super) {
    __extends(JSONParser2, _super);
    function JSONParser2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.contentType = "application/json";
      _this.options = {};
      return _this;
    }
    JSONParser2.isJSON = function(data) {
      try {
        JSON.parse(data);
        return true;
      } catch (e) {
        return false;
      }
    };
    JSONParser2.prototype.parse = function(data) {
      var _this = this;
      var res;
      try {
        if (hasValue(JSON)) {
          res = JSON.parse(data);
        }
      } catch (e) {
        return void 0;
      }
      var empty = hasValue(this.options.emptyAs);
      var numbers = this.parsableNumbers;
      var dates = this.parsableDates;
      if (Array.isArray(res) && (numbers || dates || empty)) {
        var _loop_1 = function(i2, len2) {
          var row = res[i2];
          each2(row, function(key, value) {
            if (empty) {
              row[key] = _this.maybeToEmpty(row[key]);
            }
            if (numbers) {
              row[key] = _this.maybeToNumber(key, row[key]);
            }
            if (dates) {
              row[key] = _this.maybeToDate(key, row[key]);
            }
          });
        };
        for (var i = 0, len = res.length; i < len; i++) {
          _loop_1(i, len);
        }
      }
      return res;
    };
    return JSONParser2;
  }(DataParser)
);

// node_modules/@amcharts/amcharts4/.internal/core/data/DataLoader.js
var DataLoader = (
  /** @class */
  function() {
    function DataLoader2() {
      this.adapter = new Adapter(this);
    }
    DataLoader2.prototype.load = function(source) {
      var sources = Array.isArray(source) ? source : [source];
      var promises = map(sources, function(x) {
        x.dispatchImmediately("started");
        x.dispatchImmediately("loadstarted");
        return load(x.url, x, x.requestOptions);
      });
      Promise.all(promises).then(function(res) {
        each(res, function(result) {
          var source2 = result.target;
          source2.dispatchImmediately("loadended");
          if (result.error) {
            if (source2.events.isEnabled("error")) {
              source2.events.dispatchImmediately("error", {
                type: "error",
                code: result.xhr.status,
                message: source2.language.translate("Unable to load file: %1", null, source2.url),
                target: source2
              });
            }
          } else {
            source2.processData(result.response, result.type);
          }
          source2.dispatchImmediately("ended");
        });
      }).catch(function(res) {
        if (res.target) {
          res.target.dispatchImmediately("loadended");
          if (res.target.events.isEnabled("error")) {
            res.target.events.dispatchImmediately("error", {
              type: "error",
              code: res.xhr.status,
              message: res.target.language.translate("Unable to load file: %1", null, res.target.url),
              target: res.target
            });
          }
          res.target.dispatchImmediately("ended");
        }
      });
    };
    DataLoader2.prototype.getParserByType = function(contentType) {
      var parser = this.adapter.apply("getParserByType", {
        parser: null,
        type: contentType
      }).parser;
      if (parser) {
        return parser;
      }
      if (contentType == "csv" || contentType == "text/csv" || contentType == "application/vnd.ms-excel") {
        return new CSVParser();
      }
      if (contentType == "json" || contentType == "application/json") {
        return new JSONParser();
      }
      return;
    };
    DataLoader2.prototype.getParserByData = function(data, contentType) {
      var parser = this.adapter.apply("getParserByData", {
        parser: null,
        data,
        type: contentType
      }).parser;
      if (!parser) {
        parser = this.getParserByType(contentType);
        if (parser) {
          return parser;
        } else if (JSONParser.isJSON(data)) {
          return this.getParserByType("json");
        } else if (CSVParser.isCSV(data)) {
          return this.getParserByType("csv");
        }
      }
      return parser;
    };
    return DataLoader2;
  }()
);
var dataLoader = new DataLoader();

// node_modules/@amcharts/amcharts4/.internal/core/data/DataSource.js
var DataSource = (
  /** @class */
  function(_super) {
    __extends(DataSource2, _super);
    function DataSource2(url, parser) {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.adapter = new Adapter(_this);
      _this._requestOptions = {};
      _this._incremental = false;
      _this._incrementalParams = {};
      _this._keepCount = false;
      _this._updateCurrentData = false;
      _this.showPreloader = true;
      _this.className = "DataSource";
      if (url) {
        _this.url = url;
      }
      if (parser) {
        if (typeof parser == "string") {
          _this.parser = dataLoader.getParserByType(parser);
        } else {
          _this.parser = parser;
        }
      }
      return _this;
    }
    DataSource2.prototype.processData = function(data, contentType) {
      this.dispatchImmediately("parsestarted");
      if (!this.parser) {
        this.parser = dataLoader.getParserByData(data, contentType);
        if (!this.parser) {
          if (this.events.isEnabled("parseerror")) {
            var event_1 = {
              type: "parseerror",
              message: this.language.translate("No parser available for file: %1", null, this.url),
              target: this
            };
            this.events.dispatchImmediately("parseerror", event_1);
          }
          this.dispatchImmediately("parseended");
          return;
        }
      }
      this.parser.options = this.adapter.apply("parserOptions", this.parser.options);
      this.parser.options.dateFields = this.adapter.apply("dateFields", this.parser.options.dateFields || []);
      this.parser.options.numberFields = this.adapter.apply("numberFields", this.parser.options.numberFields || []);
      if (this.parser.options.dateFields && !this.parser.options.dateFormatter) {
        this.parser.options.dateFormatter = this.dateFormatter;
      }
      this.data = this.adapter.apply("parsedData", this.parser.parse(this.adapter.apply("unparsedData", data)));
      if (!hasValue(this.data) && this.events.isEnabled("parseerror")) {
        var event_2 = {
          type: "parseerror",
          message: this.language.translate("Error parsing file: %1", null, this.url),
          target: this
        };
        this.events.dispatchImmediately("parseerror", event_2);
      }
      this.dispatchImmediately("parseended");
      if (hasValue(this.data)) {
        this.dispatchImmediately("done", {
          "data": this.data
        });
      }
      this.lastLoad = /* @__PURE__ */ new Date();
    };
    Object.defineProperty(DataSource2.prototype, "url", {
      /**
       * @return URL
       */
      get: function() {
        var url = this.disableCache ? this.timestampUrl(this._url) : this._url;
        if (this.incremental && this.component.data.length) {
          url = this.addUrlParams(url, this.incrementalParams);
        }
        return this.adapter.apply("url", url);
      },
      /**
       * URL of the data source.
       *
       * @param value  URL
       */
      set: function(value) {
        this._url = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "requestOptions", {
      /**
       * @return Options
       */
      get: function() {
        return this.adapter.apply("requestOptions", this._requestOptions);
      },
      /**
       * Custom options for HTTP(S) request.
       *
       * At this moment the only option supported is: `requestHeaders`, which holds
       * an array of objects for custom request headers, e.g.:
       *
       * ```TypeScript
       * chart.dataSource.requestOptions.requestHeaders = [{
       *   "key": "x-access-token",
       *   "value": "123456789"
       * }];
       * ``````JavaScript
       * chart.dataSource.requestOptions.requestHeaders = [{
       *   "key": "x-access-token",
       *   "value": "123456789"
       * }];
       * ```
       * ```JSON
       * {
       *   // ...
       *   "dataSource": {
       *     // ...
       *     "requestOptions": {
       *       "requestHeaders": [{
       *         "key": "x-access-token",
       *         "value": "123456789"
       *       }]
       *     }
       *   }
       * }
       * ```
       *
       * NOTE: setting this options on an-already loaded DataSource will not
       * trigger a reload.
       *
       * @param value  Options
       */
      set: function(value) {
        this._requestOptions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "parser", {
      /**
       * @return Data parser
       */
      get: function() {
        if (!this._parser) {
          this._parser = new JSONParser();
        }
        return this.adapter.apply("parser", this._parser);
      },
      /**
       * A parser to be used to parse data.
       *
       * ```TypeScript
       * chart.dataSource.url = "http://www.myweb.com/data.json";
       * chart.dataSource.parser = am4core.JSONParser;
       * ```
       * ```JavaScript
       * chart.dataSource.url = "http://www.myweb.com/data.json";
       * chart.dataSource.parser = am4core.JSONParser;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "dataSource": {
       *     "url": "http://www.myweb.com/data.json",
       *     "parser": {
       *       "type": "JSONParser"
       *     }
       *   },
       *   // ...
       * }
       * ```
       *
       * @default JSONParser
       * @param value  Data parser
       */
      set: function(value) {
        this._parser = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "reloadFrequency", {
      /**
       * @return Reload frequency (ms)
       */
      get: function() {
        return this.adapter.apply("reloadTimeout", this._reloadFrequency);
      },
      /**
       * Data source reload frequency.
       *
       * If set, it will reload the same URL every X milliseconds.
       *
       * @param value Reload frequency (ms)
       */
      set: function(value) {
        var _this = this;
        if (this._reloadFrequency != value) {
          this._reloadFrequency = value;
          if (value) {
            if (!hasValue(this._reloadDisposer)) {
              this._reloadDisposer = this.events.on("ended", function(ev) {
                _this._reloadTimeout = setTimeout(function() {
                  _this.load();
                }, _this.reloadFrequency);
              });
            }
          } else if (hasValue(this._reloadDisposer)) {
            this._reloadDisposer.dispose();
            this._reloadDisposer = void 0;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "incremental", {
      /**
       * @return Incremental load?
       */
      get: function() {
        return this.adapter.apply("incremental", this._incremental);
      },
      /**
       * Should subsequent reloads be treated as incremental?
       *
       * Incremental loads will assume that they contain only new data items
       * since the last load.
       *
       * If `incremental = false` the loader will replace all of the target's
       * data with each load.
       *
       * This setting does not have any effect trhe first time data is loaded.
       *
       * NOTE: this setting works only with element's `data` property. It won't
       * work with any other externally-loadable data property.
       *
       * @default false
       * @param Incremental load?
       */
      set: function(value) {
        this._incremental = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "incrementalParams", {
      /**
       * @return Incremental request parameters
       */
      get: function() {
        return this.adapter.apply("incrementalParams", this._incrementalParams);
      },
      /**
       * An object consisting of key/value pairs to apply to an URL when data
       * source is making an incremental request.
       *
       * @param value  Incremental request parameters
       */
      set: function(value) {
        this._incrementalParams = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "keepCount", {
      /**
       * @return keepCount load?
       */
      get: function() {
        return this.adapter.apply("keepCount", this._keepCount);
      },
      /**
       * This setting is used only when `incremental = true`. If set to `true`,
       * it will try to retain the same number of data items across each load.
       *
       * E.g. if incremental load yeilded 5 new records, then 5 items from the
       * beginning of data will be removed so that we end up with the same number
       * of data items.
       *
       * @default false
       * @param Keep record count?
       */
      set: function(value) {
        this._keepCount = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "updateCurrentData", {
      /**
       * @return Update current data?
       */
      get: function() {
        return this.adapter.apply("updateCurrentData", this._updateCurrentData);
      },
      /**
       * If set to `true`, each subsequent load will be treated as an update to
       * currently loaded data, meaning that it will try to update values on
       * existing data items, not overwrite the whole data.
       *
       * This will work faster than complete update, and also will animate the
       * values to their new positions.
       *
       * Data sources across loads must contain the same number of data items.
       *
       * Loader will not truncate the data set if loaded data has fewer data items,
       * and if it is longer, the excess data items will be ignored.
       *
       * NOTE: this setting is ignored if `incremental = true`.
       *
       * @default false
       * @since 2.5.5
       * @param Update current data?
       */
      set: function(value) {
        this._updateCurrentData = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "language", {
      /**
       * @return A [[Language]] instance to be used
       */
      get: function() {
        if (this._language) {
          return this._language;
        } else if (this.component) {
          this._language = this.component.language;
          return this._language;
        }
        this.language = new Language();
        return this.language;
      },
      /**
       * Language instance to use.
       *
       * Will inherit and use chart's language, if not set.
       *
       * @param value An instance of Language
       */
      set: function(value) {
        this._language = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataSource2.prototype, "dateFormatter", {
      /**
       * @return A [[DateFormatter]] instance to be used
       */
      get: function() {
        if (this._dateFormatter) {
          return this._dateFormatter;
        } else if (this.component) {
          this._dateFormatter = this.component.dateFormatter;
          return this._dateFormatter;
        }
        this.dateFormatter = new DateFormatter();
        return this.dateFormatter;
      },
      /**
       * A [[DateFormatter]] to use when parsing dates from string formats.
       *
       * Will inherit and use chart's DateFormatter if not ser.
       *
       * @param value An instance of [[DateFormatter]]
       */
      set: function(value) {
        this._dateFormatter = value;
      },
      enumerable: true,
      configurable: true
    });
    DataSource2.prototype.timestampUrl = function(url) {
      var tstamp = (/* @__PURE__ */ new Date()).getTime().toString();
      var params = {};
      params[tstamp] = "";
      return this.addUrlParams(url, params);
    };
    DataSource2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      if (this._reloadTimeout) {
        clearTimeout(this._reloadTimeout);
      }
      if (hasValue(this._reloadDisposer)) {
        this._reloadDisposer.dispose();
        this._reloadDisposer = void 0;
      }
    };
    DataSource2.prototype.load = function() {
      if (this.url) {
        if (this._reloadTimeout) {
          clearTimeout(this._reloadTimeout);
        }
        dataLoader.load(this);
      }
    };
    DataSource2.prototype.addUrlParams = function(url, params) {
      var join = url.match(/\?/) ? "&" : "?";
      var add2 = [];
      each2(params, function(key, value) {
        if (value != "") {
          add2.push(key + "=" + encodeURIComponent(value));
        } else {
          add2.push(key);
        }
      });
      if (add2.length) {
        return url + join + add2.join("&");
      }
      return url;
    };
    DataSource2.prototype.processConfig = function(config) {
      registry.registeredClasses["json"] = JSONParser;
      registry.registeredClasses["JSONParser"] = JSONParser;
      registry.registeredClasses["csv"] = CSVParser;
      registry.registeredClasses["CSVParser"] = CSVParser;
      _super.prototype.processConfig.call(this, config);
    };
    return DataSource2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/utils/Responsive.js
var Responsive = (
  /** @class */
  function(_super) {
    __extends(Responsive2, _super);
    function Responsive2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._rules = new List();
      _this._appliedRules = {};
      _this._appliedTargets = [];
      _this._useDefault = true;
      _this.adapter = new Adapter(_this);
      _this._enabled = false;
      _this._responsiveDisposers = [];
      _this._noStates = [];
      _this.className = "Responsive";
      _this.rules.events.on("inserted", function() {
        _this.checkRules();
      }, true);
      _this.rules.events.on("removed", function() {
        _this.checkRules();
      }, true);
      _this._disposers.push(_this.rules.events);
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(Responsive2.prototype, "component", {
      /**
       * @return Target object
       */
      get: function() {
        return this._component;
      },
      /**
       * A target object that responsive rules will need to be applied to.
       *
       * @param value  Target object
       */
      set: function(value) {
        var _this = this;
        if (value == this._component) {
          return;
        }
        this.disposeResponsiveHandlers();
        this._component = value;
        this._responsiveDisposers.push(getValue(this.component).events.on("sizechanged", function() {
          _this.checkRules();
        }, this));
        this._responsiveDisposers.push(getValue(this.component).events.once("datavalidated", function() {
          if (_this._component.isReady()) {
            _this.checkRules(true);
          }
        }, this));
        this.enabled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Responsive2.prototype, "enabled", {
      /**
       * @return Apply responsive rules?
       */
      get: function() {
        return this.adapter.apply("enabled", this._enabled);
      },
      /**
       * Should responsive rules be checked against and applied?
       *
       * @default false
       * @param value  Apply responsive rules?
       */
      set: function(value) {
        if (this._enabled != value) {
          this._enabled = value;
          this.applyRules();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Responsive2.prototype, "useDefault", {
      /**
       * @return Use default rules?
       */
      get: function() {
        return this.adapter.apply("useDefault", this._useDefault);
      },
      /**
       * Should default responsive rules be applied in addition to user-defined
       * ones.
       *
       * User-defined rules will take precedence over default rules whenever they
       * produce conflicting settings.
       *
       * @default true
       * @param value  Use default rules?
       */
      set: function(value) {
        if (this._useDefault != value) {
          this._useDefault = value;
          this.applyRules();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Responsive2.prototype, "rules", {
      /**
       * @return User-defined rules
       */
      get: function() {
        return this.adapter.apply("rules", this._rules);
      },
      /**
       * User-defined responsive rules.
       *
       * User-defined rules will take precedence over default rules whenever they
       * produce conflicting settings.
       *
       * Use `allRules` to get all applicable rules including default and
       * user-defined ones.
       *
       * @param value  User-defined rules
       */
      set: function(value) {
        this._rules = value;
        this._enabled = true;
        this.applyRules();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Responsive2.prototype, "defaultRules", {
      /**
       * Default responsive rules.
       *
       * @readonly
       * @return List of responsive rules
       */
      get: function() {
        return this.adapter.apply("defaultRules", defaultRules);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Responsive2.prototype, "allRules", {
      /**
       * Returns all rules: default rules (if not disabled) combined with
       * user-defined ones.
       *
       * @readonly
       * @return List of all applicable rules
       */
      get: function() {
        var rules3 = new List();
        if (this.useDefault) {
          rules3.copyFrom(this.defaultRules);
        }
        rules3.copyFrom(this.rules);
        return this.adapter.apply("allRules", rules3);
      },
      enumerable: true,
      configurable: true
    });
    Responsive2.prototype.isApplied = function(ruleId) {
      var rule = this._appliedRules[ruleId];
      return hasValue(rule) ? rule : false;
    };
    Responsive2.prototype.checkRules = function(force) {
      var _this = this;
      if (force === void 0) {
        force = false;
      }
      var rules3 = this.allRules;
      if (!rules3 || rules3.length == 0) {
        return;
      }
      var rulesChanged = false;
      var component = getValue(this.component);
      if (component.pixelWidth == 0 || component.pixelHeight == 0) {
        return;
      }
      each3(rules3.iterator(), function(rule) {
        if (!rule.id) {
          rule.id = registry.getUniqueId();
        }
        var apply = rule.relevant(component);
        if (apply && !_this.isApplied(rule.id) || !apply && _this.isApplied(rule.id)) {
          rulesChanged = true;
        }
        _this._appliedRules[rule.id] = apply;
      });
      if (force) {
        rulesChanged = true;
      }
      if (rulesChanged) {
        if (!this.component.isReady()) {
          component.hidden = true;
          component.events.once("ready", function(ev) {
            ev.target.show(0);
            _this._applyRules();
          });
          return;
        }
        this.dispatchImmediately("ruleschanged");
        this._applyRules();
      }
    };
    Responsive2.prototype._applyRules = function() {
      var _this = this;
      if (this._timeout) {
        this._timeout.dispose();
      }
      this._timeout = this.setTimeout(function() {
        _this.applyRules();
      }, 10);
    };
    Responsive2.prototype.applyRules = function(target) {
      var _this = this;
      var newTarget = hasValue(target) ? target : getValue(this.component);
      var defaultStateApplied = false;
      if (this.enabled) {
        var isApplied_1 = false;
        each3(this.allRules.iterator(), function(rule) {
          var state = _this.getState(rule, newTarget);
          if (state) {
            if (!defaultStateApplied) {
              if (indexOf(_this._appliedTargets, newTarget.uid) !== -1) {
                newTarget.setState(_this.getDefaultState(newTarget), 0);
              }
              defaultStateApplied = true;
            }
            if (_this.isApplied(getValue(rule.id))) {
              state.transitionDuration = 0;
              _this.setTargetState(newTarget, state);
              _this.dispatchImmediately("ruleapplied", {
                rule
              });
              isApplied_1 = true;
            }
          }
        });
        if (isApplied_1) {
          replace(this._appliedTargets, newTarget.uid);
        } else {
          remove(this._appliedTargets, newTarget.uid);
        }
      }
      if (newTarget.children) {
        each3(newTarget.children.iterator(), function(child) {
          _this.applyRules(child);
        });
      }
    };
    Responsive2.prototype.getState = function(rule, target) {
      var stateId = "responsive-" + rule.id;
      var tmpId = target.uid + "_" + stateId;
      if (indexOf(this._noStates, tmpId) !== -1) {
        return;
      } else if (!target.states.hasKey(stateId)) {
        var state = rule.state(target, stateId);
        if (!state) {
          this._noStates.push(tmpId);
        }
        return state;
      } else {
        return target.states.getKey(stateId);
      }
    };
    Responsive2.prototype.getDefaultState = function(target) {
      if (target.states.hasKey("responsive-default")) {
        return target.states.getKey("responsive-default");
      }
      return target.states.create("responsive-default");
    };
    Responsive2.prototype.setTargetState = function(target, state) {
      var _this = this;
      var defaultState = this.getDefaultState(target);
      each2(state.properties, function(key, val) {
        if (!hasValue(defaultState.properties[key])) {
          defaultState.properties[key] = _this.getValue(target, key);
        }
      });
      target.setState(state);
    };
    Responsive2.prototype.getValue = function(target, property) {
      var value = target.getPropertyValue(property);
      if (!hasValue(value) && hasValue(target[property])) {
        value = target[property];
      }
      return value;
    };
    Responsive2.prototype.dispose = function() {
      this.disposeResponsiveHandlers();
      _super.prototype.dispose.call(this);
    };
    Responsive2.prototype.disposeResponsiveHandlers = function() {
      var disposer = this._responsiveDisposers.pop();
      while (disposer) {
        disposer.dispose();
        disposer = this._responsiveDisposers.pop();
      }
    };
    return Responsive2;
  }(BaseObjectEvents)
);
var defaultRules = new List();
defaultRules.events.on("inserted", function(ev) {
  ev.newValue.id = registry.getUniqueId();
});
var ResponsiveBreakpoints = (
  /** @class */
  function() {
    function ResponsiveBreakpoints2() {
    }
    ResponsiveBreakpoints2.widthXXS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XXS;
    };
    ResponsiveBreakpoints2.widthXS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XS;
    };
    ResponsiveBreakpoints2.widthS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.S;
    };
    ResponsiveBreakpoints2.widthM = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.M;
    };
    ResponsiveBreakpoints2.widthL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.L;
    };
    ResponsiveBreakpoints2.widthXL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XL;
    };
    ResponsiveBreakpoints2.widthXXL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XXL;
    };
    ResponsiveBreakpoints2.heightXXS = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.XXS;
    };
    ResponsiveBreakpoints2.heightXS = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.XS;
    };
    ResponsiveBreakpoints2.heightS = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.S;
    };
    ResponsiveBreakpoints2.heightM = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.M;
    };
    ResponsiveBreakpoints2.heightL = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.L;
    };
    ResponsiveBreakpoints2.heightXL = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.XL;
    };
    ResponsiveBreakpoints2.heightXXL = function(container) {
      return container.pixelHeight <= ResponsiveBreakpoints2.XXL;
    };
    ResponsiveBreakpoints2.isXXS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XXS && container.pixelHeight <= ResponsiveBreakpoints2.XXS;
    };
    ResponsiveBreakpoints2.isXS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XS && container.pixelHeight <= ResponsiveBreakpoints2.XS;
    };
    ResponsiveBreakpoints2.isS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.S && container.pixelHeight <= ResponsiveBreakpoints2.S;
    };
    ResponsiveBreakpoints2.isM = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.M && container.pixelHeight <= ResponsiveBreakpoints2.M;
    };
    ResponsiveBreakpoints2.isL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.L && container.pixelHeight <= ResponsiveBreakpoints2.L;
    };
    ResponsiveBreakpoints2.isXL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XL && container.pixelHeight <= ResponsiveBreakpoints2.XL;
    };
    ResponsiveBreakpoints2.isXXL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XXL && container.pixelHeight <= ResponsiveBreakpoints2.XXL;
    };
    ResponsiveBreakpoints2.maybeXXS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XXS || container.pixelHeight <= ResponsiveBreakpoints2.XXS;
    };
    ResponsiveBreakpoints2.maybeXS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XS || container.pixelHeight <= ResponsiveBreakpoints2.XS;
    };
    ResponsiveBreakpoints2.maybeS = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.S || container.pixelHeight <= ResponsiveBreakpoints2.S;
    };
    ResponsiveBreakpoints2.maybeM = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.M || container.pixelHeight <= ResponsiveBreakpoints2.M;
    };
    ResponsiveBreakpoints2.maybeL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.L || container.pixelHeight <= ResponsiveBreakpoints2.L;
    };
    ResponsiveBreakpoints2.maybeXL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XL || container.pixelHeight <= ResponsiveBreakpoints2.XL;
    };
    ResponsiveBreakpoints2.maybeXXL = function(container) {
      return container.pixelWidth <= ResponsiveBreakpoints2.XXL || container.pixelHeight <= ResponsiveBreakpoints2.XXL;
    };
    ResponsiveBreakpoints2.XXS = 100;
    ResponsiveBreakpoints2.XS = 200;
    ResponsiveBreakpoints2.S = 300;
    ResponsiveBreakpoints2.M = 400;
    ResponsiveBreakpoints2.L = 600;
    ResponsiveBreakpoints2.XL = 800;
    ResponsiveBreakpoints2.XXL = 1e3;
    return ResponsiveBreakpoints2;
  }()
);

// node_modules/@amcharts/amcharts4/.internal/core/DataItem.js
var DataItem = (
  /** @class */
  function(_super) {
    __extends(DataItem2, _super);
    function DataItem2() {
      var _this = _super.call(this) || this;
      _this._disabled = false;
      _this.hasProperties = false;
      _this.values = {};
      _this.categories = {};
      _this.dates = {};
      _this.locations = {};
      _this.workingLocations = {};
      _this.properties = {};
      _this.sprites = [];
      _this.isTemplate = false;
      _this._index = null;
      _this._visible = true;
      _this._hidden = false;
      _this._ignoreMinMax = false;
      _this.hasChildren = {};
      _this.isHiding = false;
      _this._valueAnimations = {};
      _this._locationAnimations = {};
      _this.className = "DataItem";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(DataItem2.prototype, "adapter", {
      /**
       * Holds Adapter.
       */
      get: function() {
        if (!this._adapterO) {
          this._adapterO = new Adapter(this);
        }
        return this._adapterO;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "index", {
      /**
       * Data Item's position index in Component's data.
       *
       * @return Index
       */
      get: function() {
        if (this.component) {
          if (this._index != null) {
            return this._index;
          } else {
            return -1;
          }
        } else {
          return -1;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "animations", {
      /**
       * A list of [[Animations]] objects currently mutating Data Item's values.
       *
       * @return [description]
       */
      get: function() {
        if (!this._animations) {
          this._animations = [];
          this._disposers.push(new AnimationDisposer(this._animations));
        }
        return this._animations;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "visible", {
      /**
       * Returns `true` if this Data Item is currently visible.
       *
       * @return Visible?
       */
      get: function() {
        if (this._hidden) {
          return false;
        }
        return this._visible;
      },
      /**
       * Sets visibility of the Data Item.
       *
       * @param value Visible?
       */
      set: function(value) {
        if (value) {
          this.hidden = false;
        }
        if (this._visible != value) {
          this.setVisibility(value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "hidden", {
      /**
       * Returns `true` if this Data Item is currently hidden.
       *
       * @return Hidden?
       */
      get: function() {
        return this._hidden;
      },
      /**
       * Sets hidden flag for data item. Mostly used to initially hide data item.
       *
       * @param value Hidden?
       */
      set: function(value) {
        if (this._hidden != value) {
          this._hidden = value;
          if (value) {
            this.setVisibility(false);
          } else {
            this.setVisibility(true, true);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "__disabled", {
      /**
       * Is this Data Item currently disabled?
       *
       * @ignore Exclude from docs
       * @param {boolean}
       */
      get: function() {
        return this._disabled;
      },
      /**
       * Disables all Sprites associated with this Data Item.
       *
       * @ignore Exclude from docs
       * @param {boolean}
       */
      set: function(value) {
        this._disabled = value;
        each(this.sprites, function(sprite) {
          sprite.__disabled = value;
        });
      },
      enumerable: true,
      configurable: true
    });
    DataItem2.prototype.setVisibility = function(value, noChangeValues) {
      each(this.sprites, function(sprite) {
        if (value) {
          sprite.visible = sprite.defaultState.properties.visible;
        } else {
          if (sprite.hiddenState) {
            sprite.visible = sprite.hiddenState.properties.visible;
          } else {
            sprite.visible = false;
          }
        }
      });
      this._visible = value;
      if (this._eventDispatcher && !this.__disabled) {
        if (this.events.isEnabled("visibilitychanged")) {
          var event_1 = {
            type: "visibilitychanged",
            target: this,
            visible: value
          };
          this.events.dispatchImmediately("visibilitychanged", event_1);
        }
      }
    };
    DataItem2.prototype.show = function(duration, delay, fields) {
      var _this = this;
      if (!this.hidden) {
        this.setVisibility(true, true);
        this.isHiding = false;
        if (this._hideDisposer) {
          this.removeDispose(this._hideDisposer);
        }
        var animation_1;
        if (fields) {
          each(fields, function(field) {
            animation_1 = _this.setWorkingValue(field, _this.values[field].value, duration, delay);
          });
        }
        each(this.sprites, function(sprite) {
          var animation = sprite.show(duration);
          if (animation != null && !animation.isFinished()) {
            _this._disposers.push(animation);
            if (delay != null && delay > 0) {
              animation.delay(delay);
            }
          }
        });
        return animation_1;
      }
    };
    DataItem2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      each(this.sprites, function(sprite) {
        sprite.dispose();
      });
      this.sprites = [];
    };
    DataItem2.prototype.hide = function(duration, delay, toValue, fields) {
      var _this = this;
      this.isHiding = true;
      each(this.sprites, function(sprite) {
        var animation = sprite.hide(duration);
        if (animation != null && !animation.isFinished()) {
          _this._disposers.push(animation);
          if (delay != null && delay > 0) {
            animation.delay(delay);
          }
        }
      });
      if (isNumber(toValue) && fields) {
        var animation_2;
        each(fields, function(field) {
          var anim = _this.setWorkingValue(field, toValue, duration, delay);
          if (anim) {
            animation_2 = anim;
          }
        });
        if (animation_2 && !animation_2.isFinished()) {
          this._hideDisposer = animation_2.events.on("animationended", function() {
            _this.setVisibility(false, true);
            _this.isHiding = false;
          });
          this._disposers.push(this._hideDisposer);
          return animation_2;
        } else {
          this.isHiding = false;
          this.setVisibility(false, true);
        }
      } else {
        this.isHiding = false;
        this.setVisibility(false);
      }
    };
    DataItem2.prototype.getDuration = function(duration) {
      if (!isNumber(duration)) {
        var component = this.component;
        if (component) {
          duration = component.interpolationDuration;
        }
      }
      if (duration != null) {
        if (!this._adapterO) {
          return duration;
        } else {
          return this._adapterO.apply("duration", duration);
        }
      }
    };
    DataItem2.prototype.getValue = function(name, calculated) {
      if (name && this.component) {
        if (!calculated) {
          calculated = this.component.dataFields[name + "Show"];
          if (!calculated) {
            calculated = "value";
          }
        }
        var value = this.values[name][calculated];
        if (this._adapterO && this._adapterO.isEnabled("value")) {
          return this._adapterO.apply("value", {
            value,
            field: name
          }).value;
        } else {
          return value;
        }
      }
    };
    DataItem2.prototype.getWorkingValue = function(name) {
      if (name && this.component) {
        var realName = this.component.dataFields[name + "Show"];
        if (!realName) {
          realName = "workingValue";
        }
        if (this._adapterO) {
          return this._adapterO.apply("workingValue", {
            workingValue: this.values[name][realName],
            field: name
          }).workingValue;
        } else {
          return this.values[name][realName];
        }
      }
    };
    DataItem2.prototype.getActualWorkingValue = function(name) {
      return this.values[name].workingValue;
    };
    DataItem2.prototype.setValue = function(name, value, duration, delay) {
      var currentValue = this.values[name].value;
      var newDuration = this.getDuration(duration);
      value = toNumber(value);
      if (currentValue !== value) {
        this.values[name].value = value;
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("valuechanged")) {
            var event_2 = {
              type: "valuechanged",
              target: this,
              property: name
            };
            this.events.dispatchImmediately("valuechanged", event_2);
          }
        }
        if (this.component) {
          this.component.handleDataItemValueChange(this, name);
        }
      }
      this.setWorkingValue(name, value, newDuration, delay);
    };
    DataItem2.prototype.setCalculatedValue = function(name, value, calculated) {
      var currentValue = this.values[name][calculated];
      if (currentValue !== value && isNumber(value)) {
        this.values[name][calculated] = value;
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("calculatedvaluechanged")) {
            var event_3 = {
              type: "calculatedvaluechanged",
              target: this,
              property: name
            };
            this.events.dispatchImmediately("calculatedvaluechanged", event_3);
          }
        }
        if (this.component) {
          this.component.handleDataItemCalculatedValueChange(this, name);
        }
      }
    };
    DataItem2.prototype.setWorkingValue = function(name, value, duration, delay) {
      if (isNumber(this.values[name].value)) {
        var newDuration = this.getDuration(duration);
        var workingValue = this.values[name].workingValue;
        if (newDuration != null && newDuration > 0 && isNumber(workingValue) && this.component) {
          if (workingValue != value) {
            var animation = this.animate({ childObject: this.values[name], property: "workingValue", from: workingValue, to: value, dummyData: name }, newDuration, this.component.interpolationEasing);
            if (delay != null) {
              animation.delay(delay);
            }
            animation.events.on("animationstarted", this.handleInterpolationProgress, this);
            animation.events.on("animationprogress", this.handleInterpolationProgress, this);
            animation.events.on("animationended", this.handleInterpolationProgress, this);
            this._valueAnimations[name] = animation;
            return animation;
          } else {
            var valueAnimation = this._valueAnimations[name];
            if (valueAnimation) {
              valueAnimation.stop();
            }
            this.values[name].workingValue = value;
          }
        } else {
          var valueAnimation = this._valueAnimations[name];
          if (valueAnimation) {
            valueAnimation.stop();
          }
          this.values[name].workingValue = value;
          if (this._eventDispatcher && !this.__disabled) {
            if (this.events.isEnabled("workingvaluechanged")) {
              var event_4 = {
                type: "workingvaluechanged",
                target: this,
                property: name
              };
              this.events.dispatchImmediately("workingvaluechanged", event_4);
            }
          }
          if (this.component) {
            this.component.handleDataItemWorkingValueChange(this, name);
          }
        }
      }
    };
    DataItem2.prototype.setLocation = function(name, value, duration, delay) {
      var currentLocation = this.locations[name];
      if (currentLocation !== value) {
        this.locations[name] = value;
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("locationchanged")) {
            var event_5 = {
              type: "locationchanged",
              target: this,
              property: name
            };
            this.events.dispatchImmediately("locationchanged", event_5);
          }
        }
        if (this.component) {
          this.component.handleDataItemValueChange(this, name);
        }
        this.setWorkingLocation(name, value, duration, delay);
      }
    };
    DataItem2.prototype.setWorkingLocation = function(name, value, duration, delay) {
      var newDuration = this.getDuration(duration);
      var workingLocation = this.workingLocations[name];
      if (newDuration != null && newDuration > 0 && isNumber(workingLocation) && this.component) {
        if (workingLocation != value) {
          var animation = this.animate({ childObject: this.workingLocations, property: name, from: workingLocation, to: value, dummyData: name }, newDuration, this.component.interpolationEasing);
          if (delay != null) {
            animation.delay(delay);
          }
          animation.events.on("animationstarted", this.handleInterpolationProgress, this);
          animation.events.on("animationprogress", this.handleInterpolationProgress, this);
          animation.events.on("animationended", this.handleInterpolationProgress, this);
          this._locationAnimations[name] = animation;
          return animation;
        } else {
          var locationAnimation = this._locationAnimations[name];
          if (locationAnimation) {
            locationAnimation.stop();
          }
          this.workingLocations[name] = value;
        }
      } else {
        var locationAnimation = this._locationAnimations[name];
        if (locationAnimation) {
          locationAnimation.stop();
        }
        this.workingLocations[name] = value;
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("workinglocationchanged")) {
            var event_6 = {
              type: "workinglocationchanged",
              target: this,
              property: name
            };
            this.events.dispatchImmediately("workinglocationchanged", event_6);
          }
        }
        if (this.component) {
          this.component.handleDataItemWorkingLocationChange(this, name);
        }
      }
    };
    DataItem2.prototype.setDate = function(name, date, duration) {
      if (!isDate(date) && this.component) {
        date = this.component.dateFormatter.parse(date);
      }
      var currentDate = this.dates[name];
      if (currentDate !== date) {
        this.dates[name] = date;
        this.setValue(name, date.getTime(), duration);
      }
    };
    DataItem2.prototype.getDate = function(name) {
      if (this._adapterO) {
        return this._adapterO.apply("date", {
          date: this.dates[name],
          field: name
        }).date;
      } else {
        return this.dates[name];
      }
    };
    DataItem2.prototype.setProperty = function(name, value) {
      if (this.properties[name] !== value) {
        this.hasProperties = true;
        this.properties[name] = value;
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("propertychanged")) {
            var event_7 = {
              type: "propertychanged",
              target: this,
              property: name,
              value
            };
            this.events.dispatchImmediately("propertychanged", event_7);
          }
        }
        if (this.component) {
          this.component.handleDataItemPropertyChange(this, name);
        }
      }
    };
    DataItem2.prototype.setCategory = function(name, value) {
      if (!isString(value)) {
        value = castString(value);
      }
      if (this.categories[name] !== value) {
        this.categories[name] = value;
      }
    };
    DataItem2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (source.dataContext) {
        this.dataContext = copy2(source.dataContext, {});
      }
      copyProperties(source.locations, this.locations);
      if (source._adapterO) {
        this.adapter.copyFrom(source._adapterO);
      }
      this.component = source.component;
    };
    Object.defineProperty(DataItem2.prototype, "opacity", {
      /**
       * Sets opacity for all Data Item's related elements (Sprites).
       *
       * @param value Opacity (0-1)
       */
      set: function(value) {
        each(this.sprites, function(sprite) {
          sprite.opacity = value;
        });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "ignoreMinMax", {
      /**
       * Exclude from min/max calculations?
       * @return Exclude from min/max calculations?
       */
      get: function() {
        return this._ignoreMinMax;
      },
      /**
       * Sets whether this data point should not be included in the scale and
       * minimum/maximum calculations.
       *
       * E.g. some we may want to exclude a particular data point from influencing
       * [[ValueAxis]] scale.
       *
       * @param value  Exclude from min/max calculations?
       */
      set: function(value) {
        this._ignoreMinMax = value;
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("propertychanged")) {
            var event_8 = {
              type: "propertychanged",
              target: this,
              property: "ignoreMinMax",
              value
            };
            this.events.dispatchImmediately("propertychanged", event_8);
          }
        }
        if (this.component) {
          this.component.handleDataItemPropertyChange(this, "ignoreMinMax");
        }
      },
      enumerable: true,
      configurable: true
    });
    DataItem2.prototype.animate = function(animationOptions, duration, easing) {
      return new Animation(this, animationOptions, duration, easing).start();
    };
    DataItem2.prototype.handleInterpolationProgress = function(event) {
      var animation = event.target;
      var animationOptions = animation.animationOptions[0];
      if (animationOptions) {
        if (this._eventDispatcher && !this.__disabled) {
          if (this.events.isEnabled("workingvaluechanged")) {
            var event_9 = {
              type: "workingvaluechanged",
              target: this,
              property: animationOptions.dummyData
            };
            this.events.dispatchImmediately("workingvaluechanged", event_9);
          }
        }
        if (this.component) {
          this.component.handleDataItemWorkingValueChange(this, animationOptions.dummyData);
        }
      }
    };
    DataItem2.prototype.hasValue = function(fields) {
      for (var i = 0, len = fields.length; i < len; i++) {
        var values = this.values[fields[i]];
        if (!values || !hasValue(values.value)) {
          return false;
        }
      }
      return true;
    };
    Object.defineProperty(DataItem2.prototype, "depth", {
      /**
       * Depth of the Data Item.
       *
       * In nested data structures, like TreeMap, this indicates the level this
       * data point is at, in relation to the parent Data Item.
       *
       * @return Depth
       */
      get: function() {
        if (!this.parent) {
          return 0;
        } else {
          return this.parent.depth + 1;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DataItem2.prototype, "dataContext", {
      /**
       * Sets to a reference to an original object from Component's data.
       *
       * @return [description]
       */
      get: function() {
        return this._dataContext;
      },
      /**
       * A reference to an original object in Component's data, that this Data Item
       * is derived from.
       *
       * @param value Original data object
       */
      set: function(value) {
        this._dataContext = value;
      },
      enumerable: true,
      configurable: true
    });
    DataItem2.prototype.addSprite = function(sprite) {
      if (sprite.dataItem && sprite.dataItem != this) {
        remove(sprite.dataItem.sprites, sprite);
      }
      if (!this.visible) {
        sprite.hide(0);
      }
      if (this.isHiding) {
        sprite.hide();
      }
      this.sprites.push(sprite);
      sprite.dataItem = this;
    };
    return DataItem2;
  }(BaseObjectEvents)
);

// node_modules/@amcharts/amcharts4/.internal/core/Component.js
var Component = (
  /** @class */
  function(_super) {
    __extends(Component2, _super);
    function Component2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.dataFields = {};
      _this._dataSources = {};
      _this._parseDataFrom = 0;
      _this._dataDisposers = [];
      _this._currentDataSetId = "";
      _this._start = 0;
      _this._end = 1;
      _this.skipRangeEvent = false;
      _this.rangeChangeDuration = 0;
      _this.rangeChangeEasing = cubicOut;
      _this.parsingStepDuration = 50;
      _this.dataInvalid = false;
      _this.rawDataInvalid = false;
      _this.dataRangeInvalid = false;
      _this.dataItemsInvalid = false;
      _this.interpolationDuration = 0;
      _this.interpolationEasing = cubicOut;
      _this.sequencedInterpolation = true;
      _this.sequencedInterpolationDelay = 0;
      _this.dataValidationProgress = 0;
      _this._addAllDataItems = true;
      _this._usesData = true;
      _this.className = "Component";
      _this.minZoomCount = 1;
      _this.maxZoomCount = 0;
      _this._dataItems = new OrderedListTemplate(_this.createDataItem());
      _this._dataItems.events.on("inserted", _this.handleDataItemAdded, _this, false);
      _this._dataItems.events.on("removed", _this.handleDataItemRemoved, _this, false);
      _this._disposers.push(new ListDisposer(_this._dataItems));
      _this._disposers.push(_this._dataItems.template);
      _this.invalidateData();
      _this.dataUsers.events.on("inserted", _this.handleDataUserAdded, _this, false);
      _this._disposers.push(new MultiDisposer(_this._dataDisposers));
      _this._start = 0;
      _this._end = 1;
      _this.maxZoomDeclination = 1;
      _this.applyTheme();
      return _this;
    }
    Component2.prototype.createDataItem = function() {
      return new DataItem();
    };
    Component2.prototype.handleDataUserAdded = function(event) {
      var dataUser = event.newValue;
      dataUser.dataProvider = this;
    };
    Component2.prototype.handleDataItemValueChange = function(dataItem, name) {
      if (!this.dataItemsInvalid) {
        this.invalidateDataItems();
      }
    };
    Component2.prototype.handleDataItemWorkingValueChange = function(dataItem, name) {
    };
    Component2.prototype.handleDataItemWorkingLocationChange = function(dataItem, name) {
    };
    Component2.prototype.handleDataItemCalculatedValueChange = function(dataItem, name) {
    };
    Component2.prototype.handleDataItemPropertyChange = function(dataItem, name) {
    };
    Component2.prototype.processDataItem = function(dataItem, dataContext) {
      var _this = this;
      if (dataItem) {
        if (!dataContext) {
          dataContext = {};
        }
        dataItem.dataContext = dataContext;
        var hasSomeValues_1 = false;
        each2(this.dataFields, function(key, fieldValue) {
          var fieldName = key;
          var value = dataContext[fieldValue];
          if (_this._adapterO) {
            if (_this._adapterO.isEnabled("dataContextValue")) {
              value = _this._adapterO.apply("dataContextValue", {
                field: fieldName,
                value,
                dataItem
              }).value;
            }
          }
          if (hasValue(value)) {
            hasSomeValues_1 = true;
            if (dataItem.hasChildren[fieldName]) {
              var template = _this.createDataItem();
              template.copyFrom(_this.mainDataSet.template);
              var children = new OrderedListTemplate(template);
              children.events.on("inserted", _this.handleDataItemAdded, _this, false);
              children.events.on("removed", _this.handleDataItemRemoved, _this, false);
              _this._dataDisposers.push(new ListDisposer(children));
              var count = value.length;
              for (var i = 0; i < count; i++) {
                var rawDataItem = value[i];
                var childDataItem = children.create();
                childDataItem.parent = dataItem;
                _this.processDataItem(childDataItem, rawDataItem);
              }
              var anyDataItem = dataItem;
              anyDataItem[fieldName] = children;
            } else {
              dataItem[fieldName] = value;
            }
          }
        });
        each2(this.propertyFields, function(key, fieldValue) {
          var f = key;
          var value = dataContext[fieldValue];
          if (hasValue(value)) {
            hasSomeValues_1 = true;
            dataItem.setProperty(f, value);
          }
        });
        if (!this._addAllDataItems && !hasSomeValues_1) {
          this.mainDataSet.remove(dataItem);
        }
      }
    };
    Component2.prototype.updateDataItem = function(dataItem) {
      var _this = this;
      if (dataItem) {
        var dataContext_1 = dataItem.dataContext;
        each2(this.dataFields, function(key, fieldValue) {
          var fieldName = key;
          var value = dataContext_1[fieldValue];
          if (_this._adapterO) {
            value = _this._adapterO.apply("dataContextValue", {
              field: fieldName,
              value,
              dataItem
            }).value;
          }
          if (hasValue(value)) {
            if (dataItem.hasChildren[fieldName]) {
              var anyDataItem = dataItem;
              var children = anyDataItem[fieldName];
              children.each(function(child) {
                _this.updateDataItem(child);
              });
            } else {
              dataItem[fieldName] = value;
            }
          }
        });
        each2(this.propertyFields, function(key, fieldValue) {
          var f = key;
          var value = dataContext_1[fieldValue];
          if (hasValue(value)) {
            dataItem.setProperty(f, value);
          }
        });
      }
    };
    Component2.prototype.validateDataElements = function() {
      var count = this.endIndex;
      for (var i = this.startIndex; i < count; i++) {
        var dataItem = this.dataItems.getIndex(i);
        if (dataItem) {
          this.validateDataElement(dataItem);
        }
      }
    };
    Component2.prototype.validate = function() {
      this.validateDataElements();
      _super.prototype.validate.call(this);
    };
    Component2.prototype.validateDataElement = function(dataItem) {
    };
    Component2.prototype.addData = function(rawDataItem, removeCount, skipRaw) {
      var _this = this;
      if (!this.dataInvalid && this.inited) {
        this._parseDataFrom = this.data.length;
      }
      if (!skipRaw) {
        if (rawDataItem instanceof Array) {
          each(rawDataItem, function(dataItem) {
            _this.data.push(dataItem);
          });
        } else {
          this.data.push(rawDataItem);
        }
      }
      if (this.inited) {
        this.removeData(removeCount, skipRaw);
      } else {
        if (isNumber(removeCount)) {
          while (removeCount > 0) {
            this.data.shift();
            removeCount--;
          }
        }
      }
      this.invalidateData();
    };
    Component2.prototype.removeData = function(count, skipRaw) {
      if (isNumber(count) && count > 0) {
        while (count > 0) {
          var dataItem = this.mainDataSet.getIndex(0);
          if (dataItem) {
            this.mainDataSet.remove(dataItem);
          }
          this.dataUsers.each(function(dataUser) {
            if (!dataUser.data || dataUser.data.length == 0) {
              var dataItem_1 = dataUser.mainDataSet.getIndex(0);
              if (dataItem_1) {
                dataUser.mainDataSet.remove(dataItem_1);
              }
            }
          });
          if (!skipRaw) {
            this.data.shift();
          }
          if (this._parseDataFrom > 0) {
            this._parseDataFrom--;
          }
          count--;
        }
        this.invalidateDataItems();
      }
    };
    Component2.prototype.invalidateData = function() {
      if (this.disabled || this.isTemplate) {
        return;
      }
      registry.addToInvalidComponents(this);
      system.requestFrame();
      this.dataInvalid = true;
      each3(this.dataUsers.iterator(), function(x) {
        x.invalidateDataItems();
      });
    };
    Component2.prototype.invalidateDataUsers = function() {
      each3(this.dataUsers.iterator(), function(x) {
        x.invalidate();
      });
    };
    Component2.prototype.invalidateDataItems = function() {
      if (this.disabled || this.isTemplate) {
        return;
      }
      move(registry.invalidDataItems, this);
      system.requestFrame();
      this.dataItemsInvalid = true;
      each3(this.dataUsers.iterator(), function(x) {
        x.invalidateDataItems();
      });
    };
    Component2.prototype.invalidateDataRange = function() {
      if (this.disabled || this.isTemplate) {
        return;
      }
      this.dataRangeInvalid = true;
      move(registry.invalidDataRange, this);
      system.requestFrame();
    };
    Component2.prototype.validateDataRange = function() {
      remove(registry.invalidDataRange, this);
      this.dataRangeInvalid = false;
      if (this.startIndex != this._prevStartIndex || this.endIndex != this._prevEndIndex) {
        this.rangeChangeUpdate();
        this.appendDataItems();
        this.invalidate();
        this.dispatchImmediately("datarangechanged");
      }
    };
    Component2.prototype.sliceData = function() {
      this._workingStartIndex = this.startIndex;
      this._workingEndIndex = this.endIndex;
    };
    Component2.prototype.rangeChangeUpdate = function() {
      this.sliceData();
      this._prevStartIndex = this.startIndex;
      this._prevEndIndex = this.endIndex;
    };
    Component2.prototype.appendDataItems = function() {
      var count = this.endIndex;
      for (var i = this.startIndex; i < count; i++) {
        var dataItem = this.dataItems.getIndex(i);
        if (dataItem) {
          dataItem.__disabled = false;
        }
      }
      for (var i = 0; i < this.startIndex; i++) {
        var dataItem = this.dataItems.getIndex(i);
        if (dataItem) {
          dataItem.__disabled = true;
        }
      }
      for (var i = this.endIndex; i < this.dataItems.length; i++) {
        var dataItem = this.dataItems.getIndex(i);
        if (dataItem) {
          dataItem.__disabled = true;
        }
      }
    };
    Component2.prototype.invalidateRawData = function() {
      if (this.disabled || this.isTemplate) {
        return;
      }
      move(registry.invalidRawDatas, this);
      system.requestFrame();
      this.rawDataInvalid = true;
      each3(this.dataUsers.iterator(), function(x) {
        x.invalidateRawData();
      });
    };
    Component2.prototype.validateRawData = function() {
      var _this = this;
      remove(registry.invalidRawDatas, this);
      each3(this.mainDataSet.iterator(), function(dataItem) {
        if (dataItem) {
          _this.updateDataItem(dataItem);
        }
      });
    };
    Component2.prototype.dispose = function() {
      var _this = this;
      this.mainDataSet.template.clones.clear();
      each2(this._dataSources, function(key, source) {
        _this.removeDispose(source);
      });
      this.disposeData();
      _super.prototype.dispose.call(this);
    };
    Component2.prototype.disposeData = function() {
      this.mainDataSet.template.clones.clear();
      each(this._dataDisposers, function(x) {
        x.dispose();
      });
      each3(this.dataUsers.iterator(), function(dataUser) {
        dataUser.disposeData();
      });
      this._dataDisposers.length = 0;
      this._startIndex = void 0;
      this._endIndex = void 0;
      this.mainDataSet.clear();
      this.mainDataSet.template.clones.clear();
      if (this._dataSets) {
        this._dataSets.clear();
      }
    };
    Component2.prototype.getDataItem = function(dataContext) {
      return this.mainDataSet.create();
    };
    Component2.prototype.validateData = function() {
      this.dispatchImmediately("beforedatavalidated");
      this.dataInvalid = false;
      registry.removeFromInvalidComponents(this);
      if (this.__disabled) {
        return;
      }
      this.dataValidationProgress = 0;
      this._prevStartIndex = void 0;
      this._prevEndIndex = void 0;
      this._startIndex = void 0;
      this._endIndex = void 0;
      if (this.dataFields.data && this.dataItem) {
        var dataContext = this.dataItem.dataContext;
        this._data = dataContext[this.dataFields.data];
      }
      if (this._parseDataFrom === 0 && this.data.length > 0) {
        this.disposeData();
      }
      if (this.data.length > 0) {
        var preloader = this.preloader;
        each3(this.dataUsers.iterator(), function(dataUser) {
          dataUser._startIndex = void 0;
          dataUser._endIndex = void 0;
        });
        var counter = 0;
        var startTime = Date.now();
        var i = this._parseDataFrom;
        var n = this.data.length;
        var _loop_1 = function() {
          var rawDataItem = this_1.data[i];
          if (this_1._usesData) {
            var dataItem = this_1.getDataItem(rawDataItem);
            this_1.processDataItem(dataItem, rawDataItem);
          }
          this_1.dataUsers.each(function(dataUser) {
            if (dataUser.data.length == 0) {
              var dataUserDataItem = dataUser.getDataItem(rawDataItem);
              dataUser.processDataItem(dataUserDataItem, rawDataItem);
            }
          });
          counter++;
          if (counter == 100) {
            counter = 0;
            var elapsed = Date.now() - startTime;
            if (elapsed > this_1.parsingStepDuration) {
              if (i < this_1.data.length - 10) {
                this_1._parseDataFrom = i + 1;
                if (preloader) {
                  if (i / this_1.data.length > 0.5 && !preloader.visible) {
                  } else {
                    preloader.progress = i / this_1.data.length;
                  }
                }
                this_1.dataValidationProgress = i / this_1.data.length;
                i = this_1.data.length;
                this_1.invalidateData();
                return { value: void 0 };
              }
            }
          }
        };
        var this_1 = this;
        for (i; i < n; i++) {
          var state_1 = _loop_1();
          if (typeof state_1 === "object")
            return state_1.value;
        }
        if (preloader) {
          preloader.progress = 1;
        }
        this.dataUsers.each(function(dataUser) {
          if (dataUser.hidden || dataUser.appeared && !dataUser.visible && dataUser.stacked) {
            dataUser.hide(0);
          }
        });
      }
      this.dataValidationProgress = 1;
      this._parseDataFrom = 0;
      this.invalidateDataItems();
      if (!this._internalDefaultsApplied) {
        this.applyInternalDefaults();
      }
      this.dispatch("datavalidated");
    };
    Component2.prototype.validateDataItems = function() {
      remove(registry.invalidDataItems, this);
      this.dataItemsInvalid = false;
      this.invalidateDataRange();
      this.invalidate();
      this.dispatch("dataitemsvalidated");
    };
    Object.defineProperty(Component2.prototype, "data", {
      /**
       * Returns element's source (raw) data.
       *
       * @return Data
       */
      get: function() {
        if (!this._data) {
          this._data = [];
        }
        if (!this._adapterO) {
          return this._data;
        } else {
          return this._adapterO.apply("data", this._data);
        }
      },
      /**
       * Sets source (raw) data for the element. The "data" is always an `Array`
       * of objects.
       *
       * IMPORTANT: The order of data items in `data` array is important as it
       * might affect chart look and behavior. [More details](https://www.amcharts.com/docs/v4/concepts/data/#Order_of_data_items).
       *
       * @param value Data
       */
      set: function(value) {
        this.setData(value);
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.setData = function(value) {
      if (!this.isDisposed()) {
        this._parseDataFrom = 0;
        this.disposeData();
        this._data = value;
        if (value && value.length > 0) {
          this.invalidateData();
        } else {
          this.dispatchImmediately("beforedatavalidated");
          this.dispatch("datavalidated");
        }
      }
    };
    Component2.prototype.getDataSource = function(property) {
      var _this = this;
      if (!hasValue(this._dataSources[property])) {
        this._dataSources[property] = new DataSource();
        this._dataSources[property].component = this;
        this.setDataSourceEvents(this._dataSources[property], property);
        this._dataSources[property].adapter.add("dateFields", function(val) {
          return _this.dataSourceDateFields(val);
        });
        this._dataSources[property].adapter.add("numberFields", function(val) {
          return _this.dataSourceNumberFields(val);
        });
        this.events.on("inited", function() {
          _this.loadData(property);
        }, this, false);
      }
      return this._dataSources[property];
    };
    Object.defineProperty(Component2.prototype, "dataSource", {
      /**
       * @return Data source
       */
      get: function() {
        if (!this._dataSources["data"]) {
          this.getDataSource("data");
        }
        return this._dataSources["data"];
      },
      /**
       *A [[DataSource]] to be used for loading Component's data.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/loading-external-data/} for more on loading external data
       * @param value  Data source
       */
      set: function(value) {
        var _this = this;
        if (this._dataSources["data"]) {
          this.removeDispose(this._dataSources["data"]);
        }
        this._dataSources["data"] = value;
        this._dataSources["data"].component = this;
        this.events.on("inited", function() {
          _this.loadData("data");
        }, this, false);
        this.setDataSourceEvents(value, "data");
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.loadData = function(property) {
      this._dataSources[property].load();
    };
    Component2.prototype.dataSourceDateFields = function(value) {
      return value;
    };
    Component2.prototype.dataSourceNumberFields = function(value) {
      return value;
    };
    Component2.prototype.populateDataSourceFields = function(list, dataFields, targetList) {
      each(targetList, function(value) {
        if (dataFields[value] && indexOf(list, dataFields[value]) === -1) {
          list.push(dataFields[value]);
        }
      });
      return list;
    };
    Component2.prototype.setDataSourceEvents = function(ds, property) {
      var _this = this;
      ds.events.on("started", function(ev) {
        var preloader = _this.preloader;
        if (preloader) {
          preloader.progress = 0;
        }
      }, void 0, false);
      ds.events.on("loadstarted", function(ev) {
        var preloader = _this.preloader;
        if (preloader) {
          preloader.progress = 0.25;
        }
      }, void 0, false);
      ds.events.on("loadended", function(ev) {
        var preloader = _this.preloader;
        if (preloader) {
          preloader.progress = 0.5;
        }
      }, void 0, false);
      ds.events.on("parseended", function(ev) {
        var preloader = _this.preloader;
        if (preloader) {
          preloader.progress = 0.75;
        }
      }, void 0, false);
      ds.events.on("ended", function(ev) {
        var preloader = _this.preloader;
        if (preloader) {
          preloader.progress = 1;
        }
      }, void 0, false);
      ds.events.on("error", function(ev) {
        var preloader = _this.preloader;
        if (preloader) {
          preloader.progress = 1;
        }
        _this.openModal(ev.message);
      }, void 0, false);
      if (property) {
        ds.events.on("done", function(ev) {
          var preloader = _this.preloader;
          if (preloader) {
            preloader.progress = 1;
          }
          if (property == "data" && !isArray(ev.data)) {
            ev.data = [ev.data];
          }
          if (ds.incremental && property == "data" && _this.data.length) {
            _this.addData(ev.data, ds.keepCount ? ev.data.length : 0);
          } else if (ds.updateCurrentData && property == "data" && _this.data.length) {
            each(_this.data, function(item, index) {
              if (hasValue(ev.data[index])) {
                each2(item, function(key, val) {
                  if (hasValue(ev.data[index][key])) {
                    item[key] = ev.data[index][key];
                  }
                });
              }
            });
            _this.invalidateRawData();
          } else {
            _this[property] = ev.data;
          }
        });
      }
    };
    Object.defineProperty(Component2.prototype, "responsive", {
      /**
       * @return Responsive rules handler
       */
      get: function() {
        if (!this._responsive) {
          this._responsive = new Responsive();
          this._responsive.component = this;
        }
        return this._responsive;
      },
      /**
       * A [[Responsive]] instance to be used when applying conditional
       * property values.
       *
       * NOTE: Responsive features are currently in development and may not work
       * as expected, if at all.
       *
       * @param value  Responsive rules handler
       */
      set: function(value) {
        this._responsive = value;
        this._responsive.component = this;
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.zoom = function(range, skipRangeEvent, instantly, declination) {
      var _this = this;
      if (skipRangeEvent === void 0) {
        skipRangeEvent = false;
      }
      if (instantly === void 0) {
        instantly = false;
      }
      var start = range.start;
      var end = range.end;
      var priority = range.priority;
      if (range.start == range.end) {
        range.start = range.start - 0.5 / this.maxZoomFactor;
        range.end = range.end + 0.5 / this.maxZoomFactor;
      }
      if (priority == "end" && end == 1 && start != 0) {
        if (start < this.start) {
          priority = "start";
        }
      }
      if (priority == "start" && start == 0) {
        if (end > this.end) {
          priority = "end";
        }
      }
      if (!isNumber(declination)) {
        declination = this.maxZoomDeclination;
      }
      if (!isNumber(start) || !isNumber(end)) {
        return { start: this.start, end: this.end };
      }
      if (this._finalStart != start || this._finalEnd != end) {
        var maxZoomFactor = this.maxZoomFactor / this.minZoomCount;
        var minZoomFactor = this.maxZoomFactor / this.maxZoomCount;
        if (priority == "start") {
          if (this.maxZoomCount > 0) {
            if (1 / (end - start) < minZoomFactor) {
              end = start + 1 / minZoomFactor;
            }
          }
          if (1 / (end - start) > maxZoomFactor) {
            end = start + 1 / maxZoomFactor;
          }
          if (end > 1 && end - start < 1 / maxZoomFactor) {
            start = end - 1 / maxZoomFactor;
          }
        } else {
          if (this.maxZoomCount > 0) {
            if (1 / (end - start) < minZoomFactor) {
              start = end - 1 / minZoomFactor;
            }
          }
          if (1 / (end - start) > maxZoomFactor) {
            if (start <= 0) {
              end = start + 1 / maxZoomFactor;
            } else {
              start = end - 1 / maxZoomFactor;
            }
          }
          if (start < 0 && end - start < 1 / maxZoomFactor) {
            end = start + 1 / maxZoomFactor;
          }
        }
        if (start < -declination) {
          start = -declination;
        }
        if (1 / (end - start) > maxZoomFactor) {
          end = start + 1 / maxZoomFactor;
        }
        if (end > 1 + declination) {
          end = 1 + declination;
        }
        if (1 / (end - start) > maxZoomFactor) {
          start = end - 1 / maxZoomFactor;
        }
        this._finalEnd = end;
        this._finalStart = start;
        this.skipRangeEvent = skipRangeEvent;
        this.dispatchImmediately("rangechangestarted");
        if (this.rangeChangeDuration > 0 && !instantly) {
          var rangeChangeAnimation = this.rangeChangeAnimation;
          if (rangeChangeAnimation && rangeChangeAnimation.progress < 1) {
            var options2 = rangeChangeAnimation.animationOptions;
            if (options2.length > 1) {
              if (options2[0].to == start && options2[1].to == end) {
                return { start, end };
              } else {
                if (!rangeChangeAnimation.isDisposed()) {
                  rangeChangeAnimation.stop();
                }
              }
            }
          }
          if (this.rangeChangeAnimation) {
            this.rangeChangeAnimation.kill();
          }
          rangeChangeAnimation = this.animate([{ property: "start", to: start }, { property: "end", to: end }], this.rangeChangeDuration, this.rangeChangeEasing);
          this.rangeChangeAnimation = rangeChangeAnimation;
          if (rangeChangeAnimation && !rangeChangeAnimation.isFinished()) {
            rangeChangeAnimation.events.on("animationended", function() {
              _this.dispatchImmediately("rangechangeended");
            });
          } else {
            this.dispatchImmediately("rangechangeended");
          }
        } else {
          this.start = start;
          this.end = end;
          this.dispatch("rangechangeended");
        }
      }
      return { start, end };
    };
    Component2.prototype.zoomToIndexes = function(startIndex, endIndex, skipRangeEvent, instantly) {
      if (!isNumber(startIndex) || !isNumber(endIndex)) {
        return;
      }
      var start = startIndex / this.dataItems.length;
      var end = endIndex / this.dataItems.length;
      this.zoom({ start, end }, skipRangeEvent, instantly);
    };
    Object.defineProperty(Component2.prototype, "zoomFactor", {
      /**
       * A current zoom factor (0-1). 1 meaning fully zoomed out. (showing all of
       * the available data)
       *
       * @return Zoom factor
       */
      get: function() {
        return fitToRange(1 / (this.end - this.start), 1, this.maxZoomFactor);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "maxZoomFactor", {
      /**
       * @return Maximum zoomFactor
       */
      get: function() {
        return this.getPropertyValue("maxZoomFactor");
      },
      /**
       * Max available `zoomFactor`.
       *
       * The element will not allow zoom to occur beyond this factor.
       *
       * [[DateAxis]] and [[CategoryAxis]] calculate this atutomatically so that
       * category axis could be zoomed to one category and date axis allows to be
       * zoomed up to one base interval.
       *
       * In case you want to restrict category or date axis to be zoomed to more
       * than one category or more than one base interval, use `minZoomCount`
       * property (set it to `> 1`).
       *
       * Default value of [[ValueAxis]]'s `maxZoomFactor` is `1000`.
       *
       * Feel free to modify it to allow bigger zoom or to restrict zooming.
       *
       * @param value  Maximum zoomFactor
       */
      set: function(value) {
        if (this.setPropertyValue("maxZoomFactor", value)) {
          if (value == 1) {
            this.maxZoomDeclination = 0;
          }
          this.invalidateDataRange();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "maxZoomDeclination", {
      /**
       * @ignore
       * @return Maximum zoom declination
       */
      get: function() {
        return this.getPropertyValue("maxZoomDeclination");
      },
      /**
       * Max zoom declination.
       *
       * @ignore
       * @default 1
       * @param value  Maximum zoom declination
       */
      set: function(value) {
        if (this.setPropertyValue("maxZoomDeclination", value)) {
          this.invalidateDataRange();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "startIndex", {
      /**
       * Current starting index.
       *
       * @return Start index
       */
      get: function() {
        if (!isNumber(this._startIndex)) {
          this._startIndex = 0;
        }
        return this._startIndex;
      },
      /**
       * Sets current starting index.
       *
       * @ignore Exclude from docs
       * @param value Start index
       */
      set: function(value) {
        this._startIndex = fitToRange(Math.round(value), 0, this.dataItems.length);
        this.start = this.indexToPosition(this._startIndex);
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.indexToPosition = function(index) {
      return index / this.dataItems.length;
    };
    Object.defineProperty(Component2.prototype, "endIndex", {
      /**
       * Current ending index.
       *
       * @return End index
       */
      get: function() {
        var count = this.dataItems.length;
        if (!isNumber(this._endIndex) || this._endIndex > count) {
          this._endIndex = count;
        }
        return this._endIndex;
      },
      /**
       * Sets current ending index.
       *
       * @ignore Exclude from docs
       * @param value End index
       */
      set: function(value) {
        this._endIndex = fitToRange(Math.round(value), 0, this.dataItems.length);
        this.end = this.indexToPosition(this._endIndex);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "start", {
      /**
       * @return Start (0-1)
       */
      get: function() {
        if (!this._adapterO) {
          return this._start;
        } else {
          return this._adapterO.apply("start", this._start);
        }
      },
      /**
       * Start of the current data range (zoom).
       *
       * These are relative values from 0 (beginning) to 1 (end).
       *
       * @param value Start (0-1)
       */
      set: function(value) {
        if (this._start != value) {
          this._start = value;
          var startIndex = Math.max(0, Math.floor(this.dataItems.length * value) || 0);
          this._startIndex = Math.min(startIndex, this.dataItems.length);
          this.invalidateDataRange();
          this.invalidate();
          this.dispatchImmediately("startchanged");
          this.dispatch("startendchanged");
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "end", {
      /**
       * @return End (0-1)
       */
      get: function() {
        if (!this._adapterO) {
          return this._end;
        } else {
          return this._adapterO.apply("end", this._end);
        }
      },
      /**
       * End of the current data range (zoom).
       *
       * These are relative values from 0 (beginning) to 1 (end).
       *
       * @param value End (0-1)
       */
      set: function(value) {
        if (this._end != value) {
          this._end = value;
          this._endIndex = Math.min(this.dataItems.length, Math.ceil(this.dataItems.length * value) || 0);
          this.invalidateDataRange();
          this.invalidate();
          this.dispatchImmediately("endchanged");
          this.dispatch("startendchanged");
        }
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.removeFromInvalids = function() {
      _super.prototype.removeFromInvalids.call(this);
      registry.removeFromInvalidComponents(this);
      remove(registry.invalidDataItems, this);
      remove(registry.invalidDataRange, this);
      remove(registry.invalidRawDatas, this);
    };
    Object.defineProperty(Component2.prototype, "dataItems", {
      /**
       * Returns a list of source [[DataItem]] objects currently used in the chart.
       *
       * @return List of data items
       */
      get: function() {
        if (this._currentDataSetId != "") {
          var dataItems = this.dataSets.getKey(this._currentDataSetId);
          if (dataItems) {
            return dataItems;
          }
        }
        return this._dataItems;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "dataSets", {
      /**
       * Holds data items for data sets (usually aggregated data).
       *
       * @ignore
       * @since 4.7.0
       * @return  Data sets
       */
      get: function() {
        if (!this._dataSets) {
          this._dataSets = new Dictionary();
        }
        return this._dataSets;
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.setDataSet = function(id) {
      if (this._currentDataSetId != id) {
        var dataSet = this.dataSets.getKey(id);
        if (!dataSet) {
          if (this._currentDataSetId != "") {
            this.dataItems.each(function(dataItem) {
              dataItem.__disabled = true;
            });
            this._currentDataSetId = "";
            this.invalidateDataRange();
            this._prevStartIndex = void 0;
            this.dataItems.each(function(dataItem) {
              dataItem.__disabled = false;
            });
            return true;
          }
        } else {
          this.dataItems.each(function(dataItem) {
            dataItem.__disabled = true;
          });
          this._currentDataSetId = id;
          this.invalidateDataRange();
          this._prevStartIndex = void 0;
          this.dataItems.each(function(dataItem) {
            dataItem.__disabled = false;
          });
          return true;
        }
      }
      return false;
    };
    Object.defineProperty(Component2.prototype, "currentDataSetId", {
      /**
       * Returns id of the currently used data set, or `undefined` if main data set
       * is in use.
       *
       * @since 4.7.0
       * @return Current data set id
       */
      get: function() {
        return this._currentDataSetId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "mainDataSet", {
      /**
       * Returns reference to "main" data set (unaggregated data as it was supplied
       * in `data`).
       *
       * @since 4.7.0
       * @return Main data set
       */
      get: function() {
        return this._dataItems;
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype._updateDataItemIndexes = function(startIndex) {
      var dataItems = this.mainDataSet.values;
      var length = dataItems.length;
      for (var i = startIndex; i < length; ++i) {
        dataItems[i]._index = i;
      }
    };
    Component2.prototype.handleDataItemAdded = function(event) {
      event.newValue.component = this;
      this._updateDataItemIndexes(event.index);
      if (!this.dataItemsInvalid) {
        this.invalidateDataItems();
      }
    };
    Component2.prototype.handleDataItemRemoved = function(event) {
      this._updateDataItemIndexes(event.index);
      if (!this.dataItemsInvalid) {
        this.invalidateDataItems();
      }
    };
    Component2.prototype.bindDataField = function(field, value) {
      this.dataFields[field] = value;
      this.invalidateDataRange();
    };
    Component2.prototype.invalidateProcessedData = function() {
      this.resetProcessedRange();
      this.invalidateDataRange();
    };
    Component2.prototype.resetProcessedRange = function() {
      this._prevEndIndex = null;
      this._prevStartIndex = null;
    };
    Object.defineProperty(Component2.prototype, "dataUsers", {
      /**
       * Returns all other [[Component]] objects that are using this element's
       * data.
       *
       * @ignore Exclude from docs
       * @todo Description (review)
       * @return [description]
       */
      get: function() {
        var _this = this;
        if (!this._dataUsers) {
          this._dataUsers = new List();
          this._disposers.push(new Disposer(function() {
            each3(_this._dataUsers.iterator(), function(x) {
              x.dispose();
            });
          }));
        }
        return this._dataUsers;
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype.clone = function() {
      var component = _super.prototype.clone.call(this);
      component.dataFields = copyProperties(this.dataFields, {});
      return component;
    };
    Component2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.data = source.data;
      this.sequencedInterpolation = source.sequencedInterpolation;
      this.sequencedInterpolationDelay = source.sequencedInterpolationDelay;
      this.interpolationDuration = source.interpolationDuration;
      this.interpolationEasing = source.interpolationEasing;
    };
    Component2.prototype.reinit = function() {
      this._inited = false;
      this.deepInvalidate();
    };
    Component2.prototype.getExporting = function() {
      var _export = _super.prototype.getExporting.call(this);
      if (!_export.adapter.has("data", this._exportData, -1, this)) {
        _export.adapter.add("data", this._exportData, -1, this);
        this.events.on("datavalidated", function(ev) {
          _export.handleDataUpdated();
        });
      }
      return _export;
    };
    Component2.prototype._exportData = function(arg) {
      arg.data = this.data;
      return arg;
    };
    Component2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (changed) {
        this.invalidateData();
      }
      return changed;
    };
    Component2.prototype.setShowOnInit = function(value) {
      if (value != this.getPropertyValue("showOnInit")) {
        if (value && !this.inited && !this.hidden) {
          this._showOnInitDisposer2 = this.events.once("dataitemsvalidated", this.hideInitially, this, false);
          this._disposers.push(this._showOnInitDisposer2);
        } else {
          if (this._showOnInitDisposer2) {
            this.removeDispose(this._showOnInitDisposer2);
          }
        }
      }
      _super.prototype.setShowOnInit.call(this, value);
    };
    Component2.prototype.setBaseId = function(value) {
      if (value != this._baseId) {
        if (this.dataInvalid) {
          this.dataInvalid = false;
          registry.removeFromInvalidComponents(this);
          this._baseId = value;
          this.invalidateData();
        }
      }
      _super.prototype.setBaseId.call(this, value);
    };
    Object.defineProperty(Component2.prototype, "minZoomCount", {
      /**
       * @return Min zoom count
       */
      get: function() {
        return this.getPropertyValue("minZoomCount");
      },
      /**
       * Use this for [[CategoryAxis]] or [[DateAxis]].
       *
       * Allows restricting zoom in beyond certain number of categories or base
       * intervals.
       *
       * @default 1
       * @param value  Min zoom count
       */
      set: function(value) {
        this.setPropertyValue("minZoomCount", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "maxZoomCount", {
      /**
       * @return Max zoom count
       */
      get: function() {
        return this.getPropertyValue("maxZoomCount");
      },
      /**
       * Use this for [[CategoryAxis]] or [[DateAxis]].
       *
       * Limits how many categories or base intervals can be shown at the same
       * time.
       *
       * If there are more items in the chart, the chart will auto-zoom.
       *
       * @default 0 (no limit)
       * @since 4.6.2
       * @param value  Max zoom count
       */
      set: function(value) {
        this.setPropertyValue("maxZoomCount", value);
      },
      enumerable: true,
      configurable: true
    });
    Component2.prototype._systemCheckIfValidate = function() {
      if (this.dataInvalid || this.dataProvider && this.dataProvider.dataInvalid) {
        return false;
      } else {
        return true;
      }
    };
    Component2.prototype.asFunction = function(field) {
      return field == "interpolationEasing" || field == "rangeChangeEasing" || _super.prototype.asIs.call(this, field);
    };
    return Component2;
  }(Container)
);
registry.registeredClasses["Component"] = Component;

// node_modules/@amcharts/amcharts4/.internal/core/elements/Label.js
var Label = (
  /** @class */
  function(_super) {
    __extends(Label2, _super);
    function Label2() {
      var _this = (
        // Execute super's constructor
        _super.call(this) || this
      );
      _this.isOversized = false;
      _this.className = "Label";
      _this.fill = new InterfaceColorSet().getFor("text");
      _this.wrap = false;
      _this.truncate = false;
      _this.fullWords = true;
      _this.ellipsis = "…";
      _this.textAlign = "start";
      _this.textValign = "top";
      _this.layout = "absolute";
      _this.baseLineRatio = -0.27;
      _this._positionPrecision = 1;
      _this.events.on("maxsizechanged", function() {
        if (_this.inited) {
          _this.handleMaxSize();
        }
      }, _this, false);
      _this.events.once("validated", _this.handleValidate, _this, false);
      _this.applyTheme();
      return _this;
    }
    Label2.prototype.afterDraw = function() {
      _super.prototype.afterDraw.call(this);
      this.validatePosition();
    };
    Label2.prototype.setPaper = function(paper) {
      var changed = _super.prototype.setPaper.call(this, paper);
      if (changed) {
        this.hardInvalidate();
      }
      return changed;
    };
    Label2.prototype.handleValidate = function() {
      if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {
        registry.events.once("exitframe", this.hardInvalidate, this);
      }
    };
    Label2.prototype.handleMaxSize = function() {
      if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {
        this.invalidate();
      } else {
      }
    };
    Label2.prototype.arrange = function() {
    };
    Label2.prototype.updateCurrentText = function() {
      var output, text;
      if (isNotEmpty(this.html) && this.paper.supportsForeignObject()) {
        output = "html";
        text = this.html;
      } else {
        output = "svg";
        text = this.text;
      }
      if (isObject(text)) {
        text = text.toString();
      }
      if (hasValue(text) && text !== "") {
        text = this.populateString(text, this.dataItem);
      }
      if (output == "html") {
        if (this._adapterO) {
          text = this._adapterO.apply("htmlOutput", text);
        }
      } else {
        if (this._adapterO) {
          text = this._adapterO.apply("textOutput", text);
        }
      }
      var changed = text != this.currentText || output != this._currentFormat;
      this.currentText = text;
      this._currentFormat = output;
      return changed;
    };
    Label2.prototype.hardInvalidate = function() {
      this._prevStatus = "";
      this.invalidate();
    };
    Label2.prototype.getLineBBox = function(lineInfo) {
      var element = lineInfo && lineInfo.element;
      var node = element && element.node;
      if (node && node.parentNode) {
        lineInfo.bbox = element.getBBox();
      }
    };
    Label2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var oldW = this.bbox.width;
      var oldH = this.bbox.height;
      var topParent = this.topParent;
      if (topParent) {
        if (!topParent.maxWidth || !topParent.maxHeight) {
          topParent.events.once("maxsizechanged", this.hardInvalidate, this, false);
          return;
        }
      }
      var maxWidth = max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);
      var maxHeight = max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);
      var status = maxHeight + "," + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;
      if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {
        return;
      }
      this._measuredWidth = 0;
      this._measuredHeight = 0;
      this.isOversized = false;
      var output = this._currentFormat;
      var text = this.currentText;
      if (!hasValue(text) || text == "") {
        this.element.attr({ display: "none" });
        return;
      }
      var lines = text.split("\n");
      this._prevStatus = status;
      this.textAlign = this.textAlign;
      var display = this.group.getAttr("display");
      if (display == "none") {
        this.group.removeAttr("display");
      }
      if (this.textPathElement) {
        this.textPathElement.removeChildren();
      }
      if (output === "svg") {
        this.element.removeAttr("display");
        var group = this.element;
        this.resetBBox();
        var currentHeight = 0;
        var currentFormat = "";
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          if (line == "") {
            var tempElement = this.getSVGLineElement("", 0);
            tempElement.add(this.getSvgElement(".", getTextFormatter().translateStyleShortcuts(currentFormat)));
            group.add(tempElement);
            var offset = Math.ceil(tempElement.getBBox().height);
            if (offset > 0) {
              currentHeight += offset;
            }
            group.removeElement(tempElement);
            var lineInfo_1 = this.getLineInfo(i);
            if (lineInfo_1) {
              lineInfo_1.text = "";
              lineInfo_1.element.textContent = "";
            }
            continue;
          }
          var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);
          var currentLineHeight = 0;
          var firstChunk = true;
          var skipTextChunks = false;
          var lineInfo = this.getLineInfo(i);
          if (lineInfo) {
            lineInfo.text = "";
            lineInfo.element.textContent = "";
          } else {
            lineInfo = {
              "text": "",
              "element": this.getSVGLineElement("", 0),
              "complex": false
            };
            group.add(lineInfo.element);
          }
          lineInfo.element.removeAttr("display");
          lineInfo.element.removeChildren();
          if (this.textPathElement) {
            lineInfo.element.add(this.textPathElement);
          }
          for (var x = 0; x < chunks.length; x++) {
            if (x) {
              lineInfo.complex = true;
            }
            var chunk = chunks[x];
            if (chunk.type === "format") {
              currentFormat = chunk.text;
            } else {
              if (skipTextChunks) {
                continue;
              }
              lineInfo.text = chunk.text;
              lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);
              if (this.textPathElement) {
                this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);
              } else {
                this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);
              }
              this.getLineBBox(lineInfo);
              lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);
              if (currentLineHeight < lineInfo.bbox.height) {
                currentLineHeight = lineInfo.bbox.height;
              }
              if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {
                this.isOversized = true;
                var lineText = lineInfo.element.textContent;
                var avgCharWidth = lineInfo.bbox.width / lineText.length;
                var excessChars = min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);
                if (this.truncate) {
                  var addEllipsis = false;
                  var node_1 = lineInfo.element.node;
                  if (node_1 && node_1.childNodes) {
                    for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {
                      var node_2 = lineInfo.element.node.childNodes[e];
                      if (addEllipsis && lineInfo.bbox.width <= maxWidth) {
                        node_2.textContent += " " + this.ellipsis;
                        lineInfo.bbox = lineInfo.element.getBBox();
                        lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);
                        if (lineInfo.bbox.width <= maxWidth) {
                          break;
                        }
                      }
                      addEllipsis = false;
                      var elementText = node_2.textContent;
                      lineText = lineInfo.element.textContent;
                      excessChars = min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);
                      while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {
                        var maxChars = max(lineText.length - excessChars - this.ellipsis.length, 1);
                        if (maxChars <= 1) {
                          excessChars = 0;
                          if (e > 0) {
                            addEllipsis = true;
                            lineInfo.element.node.removeChild(node_2);
                          }
                        }
                        elementText = truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);
                        if (elementText.length > maxChars && this.fullWords) {
                          elementText = truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);
                        }
                        node_2.textContent = elementText;
                        lineInfo.bbox = lineInfo.element.getBBox();
                        lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);
                        excessChars = Math.ceil(excessChars * 1.1);
                      }
                      skipTextChunks = true;
                    }
                  }
                } else {
                  var node_3 = lineInfo.element.node;
                  if (node_3) {
                    var lastNode = lineInfo.element.node.lastChild;
                    var splitLines = void 0;
                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {
                      var maxChars = max(chunk.text.length - excessChars, 1);
                      if (firstChunk) {
                        splitLines = splitTextByCharCount(chunk.text, maxChars, true, this.rtl);
                      } else {
                        splitLines = splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);
                        if (splitLines[0].length > maxChars || maxChars === 1) {
                          lineInfo.element.node.removeChild(lastNode);
                          excessChars = 0;
                        }
                      }
                      if (excessChars > 0) {
                        var lineText_1 = splitLines.shift();
                        if (firstChunk) {
                          lineText_1 = trim(lineText_1);
                        }
                        lastNode.textContent = getTextFormatter().cleanUp(lineText_1);
                      }
                      lineInfo.bbox = lineInfo.element.getBBox();
                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);
                      excessChars++;
                    }
                    if (splitLines.length > 0) {
                      var restOfLine = "";
                      if (hasValue(splitLines)) {
                        if (this.rtl) {
                          restOfLine += splitLines.join("") + currentFormat;
                        } else {
                          restOfLine += currentFormat + splitLines.join("").replace(/([\[\]]{1})/g, "$1$1");
                        }
                      }
                      for (var c = x + 1; c < chunks.length; c++) {
                        if (chunks[c].type == "value") {
                          restOfLine += chunks[c].text.replace(/([\[\]]{1})/g, "$1$1");
                        } else {
                          restOfLine += chunks[c].text;
                        }
                      }
                      lines.splice(i + 1, 0, restOfLine);
                    }
                    skipTextChunks = true;
                  }
                }
              }
              if (this.bbox.width < lineInfo.bbox.width) {
                this.bbox.width = lineInfo.bbox.width;
              }
              this.bbox.height = currentHeight + currentLineHeight;
              if (!this.textPathElement) {
                lineInfo.element.attr({
                  "x": "0",
                  "y": currentHeight + currentLineHeight,
                  "dy": round(this.baseLineRatio * currentLineHeight, 3).toString()
                });
              } else {
                lineInfo.element.attr({
                  "dy": -this.paddingBottom.toString()
                });
              }
              firstChunk = false;
            }
          }
          var node = lineInfo.element.node;
          if (node) {
            var lastNode = node.lastChild;
            if (lastNode) {
              lastNode.textContent = this.rtl ? ltrim(lastNode.textContent) : rtrim(lastNode.textContent);
            }
          }
          currentHeight += currentLineHeight;
          this.addLineInfo(lineInfo, i);
        }
        this.maybeHideOversized();
        this.measureFailed = false;
        if (this.bbox.width == 0 || this.bbox.height == 0) {
          this.measureFailed = true;
        }
        this._measuredWidth = round(max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));
        this._measuredHeight = round(max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));
        this.alignSVGText();
        this.bbox.width = this._measuredWidth;
        this.bbox.height = this._measuredHeight;
        if (oldH != this._measuredHeight || oldW != this._measuredWidth) {
          this.dispatch("transformed");
        }
        this.hideUnused(lines.length);
      } else {
        this.element.removeAttr("display");
        this.resetBBox();
        var group = this.element;
        group.removeChildren();
        this.setCache("lineInfo", [], 0);
        var fo = this.paper.foreignObject();
        group.add(fo);
        if (this.maxWidth) {
          fo.attr({
            width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight
          });
        }
        if (this.maxHeight) {
          fo.attr({
            height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom
          });
        }
        var lineElement = this.getHTMLLineElement(text);
        fo.node.appendChild(lineElement);
        lineElement.style.display = "inline-block";
        var clientWidth = lineElement.clientWidth;
        var clientHeight = lineElement.clientHeight;
        lineElement.style.display = "block";
        this._bbox = {
          x: 0,
          y: 0,
          width: clientWidth,
          height: clientHeight
        };
        fo.attr({
          width: clientWidth + 1,
          height: clientHeight
        });
        this.maybeHideOversized();
        this._measuredWidth = max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);
        this._measuredHeight = max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);
        this.bbox.width = this._measuredWidth;
        this.bbox.height = this._measuredHeight;
        if (this.truncate) {
          lineElement.style.overflow = "hidden";
        }
        if (clientWidth > maxWidth || clientHeight > maxHeight) {
          this.isOversized = true;
        }
      }
      this.setStyles();
      this.updateCenter();
      this.updateBackground();
      if (display == "none") {
        this.group.attr({ display: "none" });
      }
      if (this.pathElement) {
        this.paper.appendDef(this.pathElement);
      }
    };
    Label2.prototype.maybeHideOversized = function() {
      if (this.hideOversized) {
        if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {
          this.element.attr({ display: "none" });
          this.isOversized = true;
        } else {
          this.element.removeAttr("display");
          this.isOversized = false;
        }
      }
    };
    Label2.prototype.alignSVGText = function() {
      var group = this.element;
      var children = group.node.children || group.node.childNodes;
      if (!children || children && children.length == 0) {
        return;
      }
      var width2 = this._measuredWidth;
      var height2 = this._measuredHeight;
      used(this.pixelPaddingLeft);
      used(this.pixelPaddingRight);
      used(this.pixelPaddingTop);
      used(this.pixelPaddingBottom);
      if (this.rtl) {
        group.attr({
          "direction": "rtl"
        });
      } else {
        group.removeAttr("direction");
      }
      for (var i = children.length - 1; i >= 0; i--) {
        var node = children[i];
        node.setAttribute("text-anchor", this.textAlign);
        if (this.textPathElement) {
          node.removeAttribute("x");
          node.removeAttribute("y");
        } else {
          switch (this.textAlign) {
            case "middle":
              node.setAttribute("x", (width2 / 2).toString() + "px");
              break;
            case "end":
              if (this.rtl) {
              } else {
                node.setAttribute("x", width2.toString());
              }
              break;
            default:
              if (this.rtl) {
                node.setAttribute("x", width2.toString());
              } else {
                node.removeAttribute("text-anchor");
              }
              break;
          }
          var y = toNumber(node.getAttribute("y"));
          switch (this.textValign) {
            case "middle":
              node.setAttribute("y", ((y || 0) + (height2 - this.bbox.height) / 2).toString());
              break;
            case "bottom":
              node.setAttribute("y", ((y || 0) + height2 - this.bbox.height).toString());
              break;
            default:
              node.setAttribute("y", (y || 0).toString());
              break;
          }
        }
      }
    };
    Label2.prototype.getSVGLineElement = function(text, y) {
      var element = this.paper.addGroup("text");
      element.textContent = text;
      element.attr({
        "x": "0"
        //"alignment-baseline": "hanging",
        //"baseline-shift": "-20%",
        //"text-anchor": "center"
      });
      if (hasValue(y)) {
        element.attr({
          "y": y.toString()
        });
      }
      if (this.truncate || this.wrap) {
        element.attr({ "overflow": "hidden" });
      }
      return element;
    };
    Object.defineProperty(Label2.prototype, "rtl", {
      /**
       * @return RTL?
       */
      get: function() {
        if (hasValue(this._rtl)) {
          return this._rtl;
        } else if (this._topParent) {
          return this._topParent.rtl;
        }
        return false;
      },
      /**
       * An RTL (right-to-left) setting.
       *
       * RTL may affect alignment, text, and other visual properties.
       *
       * If you set this on a top-level chart object, it will be used for all
       * child elements, e.g. labels, unless they have their own `rtl` setting
       * set directly on them.
       *
       * @param value  `true` for to use RTL
       */
      set: function(value) {
        value = toBoolean(value);
        this._rtl = value;
        if (this.element) {
          this.alignSVGText();
        }
      },
      enumerable: true,
      configurable: true
    });
    Label2.prototype.resetBBox = function() {
      this._bbox = { x: 0, y: 0, width: 0, height: 0 };
    };
    Label2.prototype.getHTMLLineElement = function(text) {
      var div = document.createElement("div");
      div.innerHTML = text;
      switch (this.textAlign) {
        case "middle":
          div.style.textAlign = "center";
          break;
        case "end":
          div.style.textAlign = "right";
          break;
      }
      if (this.wrap) {
        div.style.wordWrap = "break-word";
      } else {
        div.style.whiteSpace = "nowrap";
      }
      if (this.rtl) {
        div.style.direction = "rtl";
      }
      if (hasValue(this.fill)) {
        div.style.color = this.fill.toString();
      }
      return div;
    };
    Label2.prototype.setStyles = function() {
      var group = this.element;
      if (!this.selectable || this.draggable || this.resizable || this.swipeable) {
        group.addStyle({
          "webkitUserSelect": "none",
          "msUserSelect": "none"
        });
      } else if (this.selectable) {
        group.removeStyle("webkitUserSelect");
        group.removeStyle("msUserSelect");
      }
    };
    Label2.prototype.hideUnused = function(index) {
      this.initLineCache();
      var lines = this.getCache("lineInfo");
      if (lines.length >= index) {
        for (var i = index; i < lines.length; i++) {
          var line = lines[i];
          if (line && line.element) {
            line.element.attr({ "display": "none" });
          }
        }
      }
    };
    Object.defineProperty(Label2.prototype, "text", {
      /**
       * @return SVG text
       */
      get: function() {
        return this.getPropertyValue("text");
      },
      /**
       * An SVG text.
       *
       * Please note that setting `html` will override this setting if browser
       * supports `foreignObject` in SGV, such as most modern browsers excluding
       * IEs.
       *
       * @param value  SVG Text
       */
      set: function(value) {
        this.setPropertyValue("text", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "path", {
      /**
       * @return Path
       */
      get: function() {
        return this.getPropertyValue("path");
      },
      /**
       * An SVG path string to position text along. If set, the text will follow
       * the curvature of the path.
       *
       * Location along the path can be set using `locationOnPath`.
       *
       * IMPORTANT: Only SVG text can be put on path. If you are using HTML text
       * this setting will be ignored.
       *
       * @since 4.1.2
       * @param  value  Path
       */
      set: function(value) {
        if (this.setPropertyValue("path", value, true)) {
          if (this.pathElement) {
            this.pathElement.dispose();
          }
          if (this.textPathElement) {
            this.textPathElement.dispose();
          }
          this.pathElement = this.paper.add("path");
          this.pathElement.attr({ "d": value });
          this.pathElement.attr({ "id": "text-path-" + this.uid });
          this._disposers.push(this.pathElement);
          this.textPathElement = this.paper.addGroup("textPath");
          this.textPathElement.attrNS(XLINK, "xlink:href", "#text-path-" + this.uid);
          this.textPathElement.attr({ "path": value });
          this._disposers.push(this.textPathElement);
          this.hardInvalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "locationOnPath", {
      /**
       * @return Relatvie location on path
       */
      get: function() {
        return this.getPropertyValue("locationOnPath");
      },
      /**
       * Relative label location on `path`. Value range is from 0 (beginning)
       * to 1 (end).
       *
       * Works only if you set `path` setting to an SVG path.
       *
       * @since 4.1.2
       * @default 0
       * @param  value  Relatvie location on path
       */
      set: function(value) {
        this.setPropertyValue("locationOnPath", value);
        if (this.textPathElement) {
          this.textPathElement.attr({ "startOffset": value * 100 + "%" });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "baseLineRatio", {
      /**
       * @return Base line ratio
       */
      get: function() {
        return this.getPropertyValue("baseLineRatio");
      },
      /**
       * A ratio to calculate text baseline. Ralative distance from the bottom of
       * the label.
       *
       * @since 4.4.2
       * @default -0.27
       * @param  value  Base line ratio
       */
      set: function(value) {
        this.setPropertyValue("baseLineRatio", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "wrap", {
      /**
       * @return Auto-wrap enabled or not
       */
      get: function() {
        return this.getPropertyValue("wrap");
      },
      /**
       * Enables or disables autowrapping of text.
       *
       * @param value  Auto-wrapping enabled
       */
      set: function(value) {
        this.resetBBox();
        this.setPropertyValue("wrap", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "truncate", {
      /**
       * @return Truncate text?
       */
      get: function() {
        return this.getPropertyValue("truncate");
      },
      /**
       * Indicates if text lines need to be truncated if they do not fit, using
       * configurable `ellipsis` string.
       *
       * `truncate` overrides `wrap` if both are set to `true`.
       *
       * NOTE: For HTML text, this setting **won't** trigger a parser and actual
       * line truncation with ellipsis. It will just hide everything that goes
       * outside the label.
       *
       * @param value  trincate text?
       */
      set: function(value) {
        this.resetBBox();
        this.setPropertyValue("truncate", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "fullWords", {
      /**
       * @return Truncate on full words?
       */
      get: function() {
        return this.getPropertyValue("fullWords");
      },
      /**
       * If `truncate` is enabled, should Label try to break only on full words
       * (`true`), or whenever needed, including middle of the word. (`false`)
       *
       * @default true
       * @param value  Truncate on full words?
       */
      set: function(value) {
        this.setPropertyValue("fullWords", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "ellipsis", {
      /**
       * @return Ellipsis string
       */
      get: function() {
        return this.getPropertyValue("ellipsis");
      },
      /**
       * Ellipsis character to use if `truncate` is enabled.
       *
       * @param value Ellipsis string
       * @default "..."
       */
      set: function(value) {
        this.setPropertyValue("ellipsis", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "selectable", {
      /**
       * @return Text selectable?
       */
      get: function() {
        return this.getPropertyValue("selectable");
      },
      /**
       * Forces the text to be selectable. This setting will be ignored if the
       * object has some kind of interaction attached to it, such as it is
       * `draggable`, `swipeable`, `resizable`.
       *
       * @param value  Text selectable?
       * @default false
       */
      set: function(value) {
        this.setPropertyValue("selectable", value, true);
        this.setStyles();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "textAlign", {
      /**
       * @return Alignment
       */
      get: function() {
        return this.getPropertyValue("textAlign");
      },
      /**
       * Horizontal text alignment.
       *
       * Available choices:
       * * "start"
       * * "middle"
       * * "end"
       *
       * @param value  Alignment
       */
      set: function(value) {
        this.setPropertyValue("textAlign", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "textValign", {
      /**
       * @ignore Exclude from docs (not used)
       * @return Alignment
       * @deprecated
       */
      get: function() {
        return this.getPropertyValue("textValign");
      },
      /**
       * Vertical text alignment.
       *
       * @ignore Exclude from docs (not used)
       * @param value  Alignment
       * @deprecated
       */
      set: function(value) {
        this.setPropertyValue("textValign", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "html", {
      /**
       * @return HTML content
       */
      get: function() {
        return this.getPropertyValue("html");
      },
      /**
       * Raw HTML to be used as text.
       *
       * NOTE: HTML text is subject to browser support. It relies on browsers
       * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not
       * support it. On those browsers, the text will fall back to basic SVG text,
       * striping out all HTML markup and styling that goes with it.
       *
       * For more information about `foreignObject` and its browser compatibility
       * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).
       *
       * @param value HTML text
       */
      set: function(value) {
        this.setPropertyValue("html", value, true);
        if (!hasValue(value)) {
          var group = this.element;
          group.removeChildrenByTag("foreignObject");
        }
      },
      enumerable: true,
      configurable: true
    });
    Label2.prototype.setFill = function(value) {
      _super.prototype.setFill.call(this, value);
      if (this.html) {
        var group = this.element;
        var divs = group.node.getElementsByTagName("div");
        for (var i = 0; i < divs.length; i++) {
          var div = divs[i];
          if (hasValue(this.fill)) {
            div.style.color = this.fill.toString();
          }
        }
      }
    };
    Object.defineProperty(Label2.prototype, "hideOversized", {
      /**
       * @return Hide if text does not fit?
       */
      get: function() {
        return this.getPropertyValue("hideOversized");
      },
      /**
       * Indicates whether the whole text should be hidden if it does not fit into
       * its allotted space.
       *
       * @param value  Hide if text does not fit?
       */
      set: function(value) {
        this.setPropertyValue("hideOversized", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "ignoreFormatting", {
      /**
       * @return Ignore formatting?
       */
      get: function() {
        return this.getPropertyValue("ignoreFormatting");
      },
      /**
       * If set to `true` square-bracket formatting blocks will be treated as
       * regular text.
       *
       * @default false
       * @param value  Ignore formatting?
       */
      set: function(value) {
        this.setPropertyValue("ignoreFormatting", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Label2.prototype.measureElement = function() {
    };
    Label2.prototype.getLineInfo = function(index) {
      this.initLineCache();
      var lines = this.getCache("lineInfo");
      return lines.length > index ? lines[index] : void 0;
    };
    Label2.prototype.addLineInfo = function(line, index) {
      this.initLineCache();
      this.getCache("lineInfo")[index] = line;
    };
    Label2.prototype.initLineCache = function() {
      if (!hasValue(this.getCache("lineInfo"))) {
        this.setCache("lineInfo", [], 0);
      }
    };
    Label2.prototype.setDataItem = function(dataItem) {
      if (this._sourceDataItemEvents) {
        this._sourceDataItemEvents.dispose();
      }
      if (dataItem) {
        this._sourceDataItemEvents = new MultiDisposer([
          dataItem.events.on("valuechanged", this.invalidate, this, false),
          dataItem.events.on("workingvaluechanged", this.invalidate, this, false),
          dataItem.events.on("calculatedvaluechanged", this.invalidate, this, false),
          dataItem.events.on("propertychanged", this.invalidate, this, false)
        ]);
      }
      _super.prototype.setDataItem.call(this, dataItem);
    };
    Object.defineProperty(Label2.prototype, "availableWidth", {
      /**
       * Returns available horizontal space.
       *
       * @ignore Exclude from docs
       * @return Available width (px)
       */
      get: function() {
        return hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Label2.prototype, "availableHeight", {
      /**
       * Returns available vertical space.
       *
       * @return Available height (px)
       */
      get: function() {
        return hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;
      },
      enumerable: true,
      configurable: true
    });
    Label2.prototype.getSvgElement = function(text, style, parent) {
      var element = this.paper.add("tspan");
      element.textContent = text;
      if (style) {
        if (options.nonce && parent) {
          var classid = "amcharts_element_style_" + btoa(style).replace(/[^\w]*/g, "");
          element.node.setAttribute("class", classid);
          var defs = document.createElementNS(SVGNS, "defs");
          parent.node.appendChild(defs);
          var e = document.createElement("style");
          e.type = "text/css";
          e.innerHTML = "." + classid + " { " + style + "}";
          e.setAttribute("nonce", options.nonce);
          defs.appendChild(e);
        } else {
          element.node.setAttribute("style", style);
        }
      }
      if (parent) {
        parent.add(element);
      }
      return element;
    };
    Label2.prototype.deepInvalidate = function() {
      _super.prototype.deepInvalidate.call(this);
      this.hardInvalidate();
    };
    Object.defineProperty(Label2.prototype, "readerTitle", {
      /**
       * @return Title
       */
      get: function() {
        var title = this.getPropertyValue("readerTitle");
        if (!title) {
          title = this.populateString(plainText(isNotEmpty(this.html) ? this.html : this.text));
        } else if (this.dataItem) {
          title = this.populateString(title);
        }
        return title;
      },
      /**
       * Screen reader title of the element.
       *
       * @param value Title
       */
      set: function(value) {
        value = toText(value);
        if (this.setPropertyValue("readerTitle", value)) {
          this.applyAccessibility();
        }
      },
      enumerable: true,
      configurable: true
    });
    return Label2;
  }(Container)
);
registry.registeredClasses["Label"] = Label;
defaultRules.push({
  relevant: ResponsiveBreakpoints.heightXS,
  state: function(target, stateId) {
    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {
      var state = target.states.create(stateId);
      state.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/core/elements/RoundedRectangle.js
var RoundedRectangle = (
  /** @class */
  function(_super) {
    __extends(RoundedRectangle2, _super);
    function RoundedRectangle2() {
      var _this = _super.call(this) || this;
      _this.className = "RoundedRectangle";
      _this.element = _this.paper.add("path");
      _this.cornerRadius(3, 3, 3, 3);
      _this.applyTheme();
      return _this;
    }
    RoundedRectangle2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var w = this.innerWidth;
      var h = this.innerHeight;
      if (isNumber(w) && isNumber(h)) {
        var minSide = min(w, h) / 2;
        var cornerRadiusTopLeft = relativeToValue(this.cornerRadiusTopLeft, minSide);
        var cornerRadiusTopRight = relativeToValue(this.cornerRadiusTopRight, minSide);
        var cornerRadiusBottomRight = relativeToValue(this.cornerRadiusBottomRight, minSide);
        var cornerRadiusBottomLeft = relativeToValue(this.cornerRadiusBottomLeft, minSide);
        var maxcr = min(Math.abs(w / 2), Math.abs(h / 2));
        var crtl = fitToRange(cornerRadiusTopLeft, 0, maxcr);
        var crtr = fitToRange(cornerRadiusTopRight, 0, maxcr);
        var crbr = fitToRange(cornerRadiusBottomRight, 0, maxcr);
        var crbl = fitToRange(cornerRadiusBottomLeft, 0, maxcr);
        var lineT = "M" + crtl + ",0 L" + (w - crtr) + ",0";
        var lineB = " L" + crbl + "," + h;
        var lineL = " L0," + crtl;
        var lineR = " L" + w + "," + (h - crbr);
        var arcTR = " a" + crtr + "," + crtr + " 0 0 1 " + crtr + "," + crtr;
        var arcBR = " a" + crbr + "," + crbr + " 0 0 1 -" + crbr + "," + crbr;
        var arcBL = " a" + crbl + "," + crbl + " 0 0 1 -" + crbl + ",-" + crbl;
        var arcTL = " a" + crtl + "," + crtl + " 0 0 1 " + crtl + ",-" + crtl;
        var path = lineT + arcTR + lineR + arcBR + lineB + arcBL + lineL + arcTL + " Z";
        this.path = path;
      }
    };
    RoundedRectangle2.prototype.cornerRadius = function(tl, tr, bl, br) {
      this.cornerRadiusTopLeft = tl;
      this.cornerRadiusTopRight = tr;
      this.cornerRadiusBottomLeft = bl;
      this.cornerRadiusBottomRight = br;
    };
    Object.defineProperty(RoundedRectangle2.prototype, "cornerRadiusTopLeft", {
      /**
       * @return Radius (px or Percent)
       */
      get: function() {
        return this.getPropertyValue("cornerRadiusTopLeft");
      },
      /**
       * Radius of the top-left corner in pixels.
       *
       * @default 3
       * @param value  Radius (px or Percent)
       */
      set: function(value) {
        this.setPercentProperty("cornerRadiusTopLeft", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RoundedRectangle2.prototype, "cornerRadiusTopRight", {
      /**
       * @return Radius (px or Percent)
       */
      get: function() {
        return this.getPropertyValue("cornerRadiusTopRight");
      },
      /**
       * Radius of the top-right corner in pixels.
       *
       * @default 3
       * @param value  Radius (px or Percent)
       */
      set: function(value) {
        this.setPercentProperty("cornerRadiusTopRight", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RoundedRectangle2.prototype, "cornerRadiusBottomRight", {
      /**
       * @return Radius (px or Percent)
       */
      get: function() {
        return this.getPropertyValue("cornerRadiusBottomRight");
      },
      /**
       * Radius of the bottom-right corner in pixels.
       *
       * @default 3
       * @param value  Radius (px or Percent)
       */
      set: function(value) {
        this.setPercentProperty("cornerRadiusBottomRight", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RoundedRectangle2.prototype, "cornerRadiusBottomLeft", {
      /**
       * @return Radius (px or Percent)
       */
      get: function() {
        return this.getPropertyValue("cornerRadiusBottomLeft");
      },
      /**
       * Radius of the bottom-left corner in pixels.
       *
       * @default 3
       * @param value  Radius (px or Percent)
       */
      set: function(value) {
        this.setPercentProperty("cornerRadiusBottomLeft", value, true);
      },
      enumerable: true,
      configurable: true
    });
    RoundedRectangle2.prototype.measureElement = function() {
    };
    Object.defineProperty(RoundedRectangle2.prototype, "bbox", {
      /**
       * Returns bounding box (square) for this element.
       *
       * @ignore Exclude from docs
       */
      get: function() {
        if (this.definedBBox) {
          return this.definedBBox;
        }
        if (this.isMeasured) {
          return {
            x: 0,
            y: 0,
            width: this.innerWidth,
            height: this.innerHeight
          };
        } else {
          return { x: 0, y: 0, width: 0, height: 0 };
        }
      },
      enumerable: true,
      configurable: true
    });
    return RoundedRectangle2;
  }(Sprite)
);
registry.registeredClasses["RoundedRectangle"] = RoundedRectangle;

// node_modules/@amcharts/amcharts4/.internal/core/elements/Button.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "Button";
      _this.tooltipY = 0;
      _this.iconPosition = "left";
      _this.layout = "horizontal";
      _this.contentAlign = "center";
      _this.contentValign = "middle";
      _this.padding(8, 16, 8, 16);
      _this.setStateOnChildren = true;
      var interfaceColors = new InterfaceColorSet();
      var background = _this.background;
      background.fill = interfaceColors.getFor("secondaryButton");
      background.stroke = interfaceColors.getFor("secondaryButtonStroke");
      background.fillOpacity = 1;
      background.strokeOpacity = 1;
      background.cornerRadius(3, 3, 3, 3);
      _this.label = new Label();
      _this.label.fill = interfaceColors.getFor("secondaryButtonText");
      ;
      _this.label.shouldClone = false;
      var hoverState = background.states.create("hover");
      hoverState.properties.fillOpacity = 1;
      hoverState.properties.fill = interfaceColors.getFor("secondaryButtonHover");
      var downState = background.states.create("down");
      downState.transitionDuration = 100;
      downState.properties.fill = interfaceColors.getFor("secondaryButtonDown");
      downState.properties.fillOpacity = 1;
      _this.role = "button";
      _this.focusable = true;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(Button2.prototype, "icon", {
      /**
       * @return Icon Sprite
       */
      get: function() {
        return this._icon;
      },
      /**
       * A [[Sprite]] to be used as an icon on button.
       *
       * @param icon Icon Sprite
       */
      set: function(icon) {
        var currentIcon = this._icon;
        if (currentIcon) {
          currentIcon.parent = void 0;
        }
        if (icon) {
          this._icon = icon;
          icon.parent = this;
          icon.interactionsEnabled = false;
          icon.shouldClone = false;
          this.iconPosition = this.iconPosition;
          this._disposers.push(icon);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "iconPosition", {
      /**
       * @return Icon position
       */
      get: function() {
        return this.getPropertyValue("iconPosition");
      },
      /**
       * Icon position: "left" or "right".
       *
       * @default "left"
       * @param position  Icon position
       */
      set: function(position) {
        this.setPropertyValue("iconPosition", position);
        if (this.icon) {
          if (position == "left") {
            this.icon.toBack();
          } else {
            this.icon.toFront();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "label", {
      /**
       * @return Label element
       */
      get: function() {
        return this._label;
      },
      /**
       * [[Label]] element to be used for text.
       *
       * @param label element
       */
      set: function(label) {
        if (this._label) {
          this.removeDispose(this._label);
        }
        this._label = label;
        if (label) {
          label.parent = this;
          label.interactionsEnabled = false;
          this._disposers.push(this._label);
        }
      },
      enumerable: true,
      configurable: true
    });
    Button2.prototype.createBackground = function() {
      return new RoundedRectangle();
    };
    Button2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (source.label) {
        this.label.copyFrom(source.label);
      }
      if (source.icon) {
        this.icon = source.icon.clone();
      }
    };
    return Button2;
  }(Container)
);
registry.registeredClasses["Button"] = Button;

// node_modules/@amcharts/amcharts4/.internal/core/elements/Circle.js
var Circle = (
  /** @class */
  function(_super) {
    __extends(Circle2, _super);
    function Circle2() {
      var _this = _super.call(this) || this;
      _this.className = "Circle";
      _this.element = _this.paper.add("circle");
      _this.setPercentProperty("radius", percent(100));
      _this.setPropertyValue("horizontalCenter", "middle");
      _this.setPropertyValue("verticalCenter", "middle");
      _this.applyTheme();
      return _this;
    }
    Circle2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      this.element.attr({ "r": this.pixelRadius });
    };
    Object.defineProperty(Circle2.prototype, "radius", {
      /**
       * @return Radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Radius of the circle.
       *
       * Can be either absolute (pixels) or relative ([Percent]).
       *
       * @param value  Radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Circle2.prototype, "pixelRadius", {
      /**
       * Radius of the circle in pixels.
       *
       * This is a read-only property. To set radius in pixels, use `radius`
       * property.
       *
       * @readonly
       * @return Radius (px)
       */
      get: function() {
        return relativeToValue(this.radius, min(this.innerWidth / 2, this.innerHeight / 2));
      },
      enumerable: true,
      configurable: true
    });
    Circle2.prototype.measureElement = function() {
      var pixelRadius = this.pixelRadius;
      this._bbox = {
        x: -pixelRadius,
        y: -pixelRadius,
        width: pixelRadius * 2,
        height: pixelRadius * 2
      };
    };
    return Circle2;
  }(Sprite)
);
registry.registeredClasses["Circle"] = Circle;

// node_modules/@amcharts/amcharts4/.internal/core/elements/PointedShape.js
var PointedShape = (
  /** @class */
  function(_super) {
    __extends(PointedShape2, _super);
    function PointedShape2() {
      var _this = _super.call(this) || this;
      _this.className = "PointedShape";
      _this.pointerBaseWidth = 15;
      _this.pointerLength = 10;
      _this.pointerY = 0;
      _this.pointerX = 0;
      _this.applyTheme();
      return _this;
    }
    PointedShape2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      if (!isNumber(this.pointerX)) {
        this.pointerX = this.pixelWidth / 2;
      }
      if (!isNumber(this.pointerY)) {
        this.pointerY = this.pixelHeight + 10;
      }
    };
    Object.defineProperty(PointedShape2.prototype, "pointerBaseWidth", {
      /**
       * @return Width (px)
       */
      get: function() {
        return this.getPropertyValue("pointerBaseWidth");
      },
      /**
       * A width of the pinter's (stem's) thick end (base) in pixels.
       *
       * @default 15
       * @param value  Width (px)
       */
      set: function(value) {
        this.setPropertyValue("pointerBaseWidth", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PointedShape2.prototype, "pointerLength", {
      /**
       * @return Length (px)
       */
      get: function() {
        return this.getPropertyValue("pointerLength");
      },
      /**
       * A length of the pinter (stem) in pixels.
       *
       * @default 10
       * @param value  Length (px)
       */
      set: function(value) {
        this.setPropertyValue("pointerLength", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PointedShape2.prototype, "pointerX", {
      /**
       * @return X
       */
      get: function() {
        return this.getPropertyValue("pointerX");
      },
      /**
       * X coordinate the shape is pointing to.
       *
       * @param value  X
       */
      set: function(value) {
        this.setPropertyValue("pointerX", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PointedShape2.prototype, "pointerY", {
      /**
       * @return Y
       */
      get: function() {
        return this.getPropertyValue("pointerY");
      },
      /**
       * Y coordinate the shape is pointing to.
       *
       * @param value  Y
       */
      set: function(value) {
        this.setPropertyValue("pointerY", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return PointedShape2;
  }(Sprite)
);

// node_modules/@amcharts/amcharts4/.internal/core/elements/PointedRectangle.js
var PointedRectangle = (
  /** @class */
  function(_super) {
    __extends(PointedRectangle2, _super);
    function PointedRectangle2() {
      var _this = _super.call(this) || this;
      _this.className = "PointedRectangle";
      _this.element = _this.paper.add("path");
      _this.cornerRadius = 6;
      _this.applyTheme();
      return _this;
    }
    PointedRectangle2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var cr = this.cornerRadius;
      var w = this.innerWidth;
      var h = this.innerHeight;
      if (w > 0 && h > 0) {
        var x = this.pointerX;
        var y = this.pointerY;
        var bwh = this.pointerBaseWidth / 2;
        var maxcr = min(w / 2, h / 2);
        var crtl = fitToRange(cr, 0, maxcr);
        var crtr = fitToRange(cr, 0, maxcr);
        var crbr = fitToRange(cr, 0, maxcr);
        var crbl = fitToRange(cr, 0, maxcr);
        var xtl = 0;
        var ytl = 0;
        var xtr = w;
        var ytr = 0;
        var xbr = w;
        var ybr = h;
        var xbl = 0;
        var ybl = h;
        var lineT = void 0;
        var lineR = void 0;
        var lineB = void 0;
        var lineL = void 0;
        var d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);
        var d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);
        if (d1 > 0 && d2 > 0) {
          var stemX = fitToRange(x, crtl + bwh, w - bwh - crtr);
          y = fitToRange(y, -Infinity, 0);
          lineT = "M" + crtl + ",0 L" + (stemX - bwh) + ",0 L" + x + "," + y + " L" + (stemX + bwh) + ",0 L" + (w - crtr) + ",0";
        } else {
          lineT = "M" + crtl + ",0 L" + (w - crtr) + ",0";
        }
        if (d1 < 0 && d2 < 0) {
          var stemX = fitToRange(x, crbl + bwh, w - bwh - crbr);
          y = fitToRange(y, h, Infinity);
          lineB = " L" + (w - crbr) + "," + h + " L" + (stemX + bwh) + "," + h + " L" + x + "," + y + " L" + (stemX - bwh) + "," + h + " L" + crbl + "," + h;
        } else {
          lineB = " L" + crbl + "," + h;
        }
        if (d1 < 0 && d2 > 0) {
          var stemY = fitToRange(y, crtl + bwh, h - crbl - bwh);
          x = fitToRange(x, -Infinity, 0);
          lineL = " L0," + (h - crbl) + " L0," + (stemY + bwh) + " L" + x + "," + y + " L0," + (stemY - bwh) + " L0," + crtl;
        } else {
          lineL = " L0," + crtl;
        }
        if (d1 > 0 && d2 < 0) {
          var stemY = fitToRange(y, crtr + bwh, h - bwh - crbr);
          x = fitToRange(x, w, Infinity);
          lineR = " L" + w + "," + crtr + " L" + w + "," + (stemY - bwh) + " L" + x + "," + y + " L" + w + "," + (stemY + bwh) + " L" + w + "," + (h - crbr);
        } else {
          lineR = " L" + w + "," + (h - crbr);
        }
        var arcTR = " a" + crtr + "," + crtr + " 0 0 1 " + crtr + "," + crtr;
        var arcBR = " a" + crbr + "," + crbr + " 0 0 1 -" + crbr + "," + crbr;
        var arcBL = " a" + crbl + "," + crbl + " 0 0 1 -" + crbl + ",-" + crbl;
        var arcTL = " a" + crtl + "," + crtl + " 0 0 1 " + crtl + ",-" + crtl;
        this.path = lineT + arcTR + lineR + arcBR + lineB + arcBL + lineL + arcTL;
      }
    };
    Object.defineProperty(PointedRectangle2.prototype, "cornerRadius", {
      /**
       * @return Corner radius (px)
       */
      get: function() {
        return this.getPropertyValue("cornerRadius");
      },
      /**
       * Radius of rectangle's border in pixels.
       *
       * @default 0
       * @param value  Corner radius (px)
       */
      set: function(value) {
        this.setPropertyValue("cornerRadius", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return PointedRectangle2;
  }(PointedShape)
);

// node_modules/@amcharts/amcharts4/.internal/core/rendering/Path.js
var Path_exports = {};
__export(Path_exports, {
  arc: () => arc,
  arcTo: () => arcTo,
  arcToPoint: () => arcToPoint,
  closePath: () => closePath,
  cubicCurveTo: () => cubicCurveTo,
  lineTo: () => lineTo,
  moveTo: () => moveTo,
  pathToPoints: () => pathToPoints,
  pointsToPath: () => pointsToPath,
  polyline: () => polyline,
  quadraticCurveTo: () => quadraticCurveTo,
  rectToPath: () => rectToPath,
  rectangle: () => rectangle,
  spiralPoints: () => spiralPoints
});
function polyline(points) {
  var path = lineTo(points[0]);
  var prevPoint = { x: 0, y: 0 };
  var minStep = options.minPolylineStep;
  if (!isNumber(minStep)) {
    minStep = 0.5;
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];
    if (getDistance(point, prevPoint) > minStep) {
      path += lineTo(point);
      prevPoint = point;
    }
  }
  return path;
}
function moveTo(point) {
  return " M" + round(point.x, 4) + "," + round(point.y, 4) + " ";
}
function lineTo(point) {
  return " L" + round(point.x, 4) + "," + round(point.y, 4) + " ";
}
function quadraticCurveTo(point, controlPoint) {
  return " Q" + round(controlPoint.x, 4) + "," + round(controlPoint.y, 4) + " " + round(point.x, 4) + "," + round(point.y, 4);
}
function cubicCurveTo(point, controlPointA, controlPointB) {
  return " C" + round(controlPointA.x, 4) + "," + round(controlPointA.y, 4) + " " + round(controlPointB.x, 4) + "," + round(controlPointB.y, 4) + " " + round(point.x, 4) + "," + round(point.y, 4);
}
function closePath() {
  return " Z";
}
function arcTo(startAngle, arc2, radius, radiusY) {
  if (arc2 == 0) {
    return "";
  }
  if (!isNumber(radiusY)) {
    radiusY = radius;
  }
  var path = "";
  var c = ",";
  var segments = Math.ceil(Math.abs(arc2) / 180);
  var l = 1;
  if (arc2 < 0) {
    l = 0;
  }
  var pax = 0;
  var pay = 0;
  var cx = -cos(startAngle) * radius;
  var cy = -sin(startAngle) * radiusY;
  if (arc2 < 0.5 && radius > 3e3) {
    var endAngle = startAngle + arc2;
    var ax = round(cos(endAngle) * radius, 4);
    var ay = round(sin(endAngle) * radiusY, 4);
    return lineTo({ x: ax, y: ay });
  }
  for (var i = 0; i < segments; i++) {
    var endAngle = startAngle + arc2 / segments * (i + 1);
    var ax = round(cos(endAngle) * radius + cx - pax, 4);
    var ay = round(sin(endAngle) * radiusY + cy - pay, 4);
    path += " a" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;
    pax = ax;
    pay = ay;
  }
  return path;
}
function arc(startAngle, arc2, radius, innerRadius, radiusY, cornerRadius, innerCornerRadius) {
  if (arc2 == 0) {
    return "";
  }
  if (!isNumber(innerRadius)) {
    innerRadius = 0;
  }
  if (radius == 0 && innerRadius <= 0) {
    return "";
  }
  if (radius < innerRadius) {
    var temp = radius;
    radius = innerRadius;
    innerRadius = temp;
    if (isNumber(radiusY)) {
      radiusY = radiusY / innerRadius * radius;
    }
  }
  arc2 = min(arc2, 360);
  if (arc2 == 360) {
    cornerRadius = 0;
    innerCornerRadius = 0;
  }
  var endAngle = startAngle + arc2;
  var crSin = sin(min(arc2, 45) / 2);
  radiusY = isNumber(radiusY) ? radiusY : radius;
  cornerRadius = cornerRadius || 0;
  innerCornerRadius = isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;
  var innerRadiusY = radiusY / radius * innerRadius;
  var cornerRadiusY = radiusY / radius * cornerRadius;
  var innerCornerRadiusY = radiusY / radius * innerCornerRadius;
  cornerRadius = fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);
  cornerRadiusY = fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);
  innerCornerRadius = fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);
  innerCornerRadiusY = fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);
  cornerRadius = round(fitToRange(cornerRadius, 0, radius * crSin), 4);
  cornerRadiusY = round(fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);
  innerCornerRadius = round(fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);
  innerCornerRadiusY = round(fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);
  var crAngle = Math.asin(cornerRadius / radius / 2) * DEGREES * 2;
  var crAngleY = Math.asin(cornerRadiusY / radiusY / 2) * DEGREES * 2;
  if (innerRadius < innerCornerRadius) {
    innerRadius = innerCornerRadius;
  }
  if (innerRadiusY < innerCornerRadiusY) {
    innerRadiusY = innerCornerRadiusY;
  }
  var crInnerAngle = Math.asin(innerCornerRadius / innerRadius / 2) * DEGREES * 2;
  var crInnerAngleY = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * DEGREES * 2;
  if (!isNumber(crInnerAngle)) {
    crInnerAngle = 0;
  }
  if (!isNumber(crInnerAngleY)) {
    crInnerAngleY = 0;
  }
  var middleAngle = startAngle + arc2 / 2;
  var mPoint = { x: round(cos(middleAngle) * innerRadius, 4), y: sin(middleAngle) * innerRadiusY };
  var a0 = { x: cos(startAngle) * (innerRadius + innerCornerRadius), y: sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };
  var b02 = { x: cos(startAngle) * (radius - cornerRadius), y: sin(startAngle) * (radiusY - cornerRadiusY) };
  var c0 = { x: cos(endAngle) * (radius - cornerRadius), y: sin(endAngle) * (radiusY - cornerRadiusY) };
  var d0 = { x: cos(endAngle) * (innerRadius + innerCornerRadius), y: sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };
  var b12 = { x: cos(startAngle + crAngle) * radius, y: sin(startAngle + crAngleY) * radiusY };
  var d1 = { x: cos(endAngle - crInnerAngle) * innerRadius, y: sin(endAngle - crInnerAngleY) * innerRadiusY };
  innerCornerRadius += innerCornerRadius * sin(crInnerAngle / 2);
  innerCornerRadiusY += innerCornerRadiusY * sin(crInnerAngleY / 2);
  if (crInnerAngle > (endAngle - startAngle) / 2) {
    d1 = mPoint;
  }
  var path = "";
  if (arc2 == 360) {
    path = moveTo(b02);
  } else {
    path = moveTo(a0);
    path += lineTo(b02);
    path += arcToPoint(b12, cornerRadius, cornerRadiusY, true);
  }
  path += arcTo(startAngle + crAngle, arc2 - 2 * crAngle, radius, radiusY);
  if (isNumber(innerRadius) && innerRadius != 0) {
    if (arc2 == 360 && cornerRadius == 0) {
      path += moveTo(d0);
    } else {
      path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);
      path += lineTo(d0);
      path += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);
    }
    path += arcTo(endAngle - crInnerAngle, -(arc2 - 2 * crInnerAngle), innerRadius, innerRadiusY);
    if (arc2 < 360 || cornerRadius > 0) {
      path += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);
    }
    path += lineTo(a0);
  } else {
    path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);
    if (arc2 < 360) {
      path += lineTo(a0);
    }
  }
  return path;
}
function arcToPoint(point, radius, radiusY, sweepFlag, largeArcFlag, xAxisRotation) {
  if (radius == 0) {
    return "";
  }
  xAxisRotation = xAxisRotation || 0;
  largeArcFlag = Boolean(largeArcFlag);
  sweepFlag = Boolean(sweepFlag);
  var c = ",";
  var sweepFlagValue = +sweepFlag;
  var largeArcFlagValue = +largeArcFlag;
  return " A" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + round(point.x, 4) + c + round(point.y, 4);
}
function rectangle(width2, height2, x, y) {
  if (!isNumber(x)) {
    x = 0;
  }
  if (!isNumber(y)) {
    y = 0;
  }
  return moveTo({ x, y }) + lineTo({ x: x + width2, y }) + lineTo({ x: x + width2, y: y + height2 }) + lineTo({ x, y: y + height2 }) + closePath();
}
function rectToPath(rect, ccw) {
  var c = ",";
  var L = " L";
  if (ccw) {
    return "M" + rect.x + c + rect.y + L + rect.x + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + rect.y + L + rect.x + c + rect.y;
  } else {
    return "M" + rect.x + c + rect.y + L + (rect.x + rect.width) + c + rect.y + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + rect.x + c + (rect.y + rect.height) + L + rect.x + c + rect.y;
  }
}
function pathToPoints(path, pointCount) {
  var paper = getGhostPaper();
  var svgPath = paper.add("path").node;
  svgPath.setAttribute("d", path);
  if (svgPath.getPointAtLength && svgPath.getTotalLength) {
    var length_1 = svgPath.getTotalLength();
    var toPoints = [];
    for (var i = 0; i < pointCount; i++) {
      var point = svgPath.getPointAtLength(i / pointCount * length_1);
      toPoints.push({ x: point.x, y: point.y });
    }
    return toPoints;
  }
  svgPath.remove();
}
function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {
  if (!isNumber(startAngle)) {
    startAngle = 0;
  }
  if (!isNumber(startAngle)) {
    endAngle = startAngle;
  }
  var r = innerRadius + 0.01;
  var angle = startAngle * RADIANS;
  var points = [];
  while (r < radius + radiusStep) {
    var stepSize = step;
    if (stepSize / 2 > r) {
      stepSize = 2 * r;
    }
    angle += 2 * Math.asin(stepSize / 2 / r);
    if (angle * DEGREES > endAngle + (radius - innerRadius) / radiusStep * 360) {
      break;
    }
    var degrees = angle * DEGREES;
    var point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };
    points.push(point);
    r = innerRadius + degrees / 360 * radiusStep;
  }
  points.shift();
  return points;
}
function pointsToPath(points) {
  if (!points || points.length == 0) {
    return "";
  }
  var path = moveTo(points[0]);
  if (points && points.length > 0) {
    for (var i = 1; i < points.length; i++) {
      path += lineTo(points[i]);
    }
  }
  return path;
}

// node_modules/@amcharts/amcharts4/.internal/core/elements/ResizeButton.js
var ResizeButton = (
  /** @class */
  function(_super) {
    __extends(ResizeButton2, _super);
    function ResizeButton2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "ResizeButton";
      _this.orientation = "horizontal";
      _this.layout = "absolute";
      _this.horizontalCenter = "middle";
      _this.verticalCenter = "middle";
      _this.draggable = true;
      _this.padding(8, 8, 8, 8);
      _this.background.cornerRadius(20, 20, 20, 20);
      var icon = new Sprite();
      icon.element = _this.paper.add("path");
      var path = moveTo({ x: -2, y: -6 });
      path += lineTo({ x: -2, y: 6 });
      path += moveTo({ x: 2, y: -6 });
      path += lineTo({ x: 2, y: 6 });
      icon.path = path;
      icon.pixelPerfect = true;
      icon.padding(0, 4, 0, 4);
      icon.stroke = new InterfaceColorSet().getFor("alternativeText");
      icon.strokeOpacity = 0.7;
      _this.icon = icon;
      _this.label.dispose();
      _this.label = void 0;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ResizeButton2.prototype, "orientation", {
      /**
       * Use for setting of direction (orientation) of the resize button.
       *
       * Available options: "horizontal", "vertical".
       *
       * @param value Orientation
       */
      set: function(value) {
        var icon = this.icon;
        if (icon) {
          if (value == "horizontal") {
            icon.rotation = 0;
          } else {
            icon.rotation = -90;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    return ResizeButton2;
  }(Button)
);
registry.registeredClasses["ResizeButton"] = ResizeButton;

// node_modules/@amcharts/amcharts4/.internal/core/elements/Scrollbar.js
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar2, _super);
    function Scrollbar2() {
      var _this = _super.call(this) || this;
      _this._previousStart = 0;
      _this._previousEnd = 1;
      _this._prevStart = 0;
      _this._prevEnd = 1;
      _this._isBusy = false;
      _this._skipRangeEvents = false;
      _this.updateWhileMoving = true;
      _this.className = "Scrollbar";
      _this.minHeight = 12;
      _this.minWidth = 12;
      _this.animationDuration = 0;
      _this.animationEasing = cubicOut;
      _this.margin(10, 10, 10, 10);
      var interfaceColors = new InterfaceColorSet();
      var background = _this.background;
      background.cornerRadius(10, 10, 10, 10);
      background.fill = interfaceColors.getFor("fill");
      background.fillOpacity = 0.5;
      _this.showSystemTooltip = true;
      _this.startGrip = new ResizeButton();
      _this.endGrip = new ResizeButton();
      _this.events.on("transformed", function() {
        _this.updateThumb();
      }, _this, false);
      _this.start = 0;
      _this.end = 1;
      _this.role = "scrollbar";
      _this.thumb.role = "slider";
      _this.thumb.readerLive = "polite";
      _this.startGrip.role = "slider";
      _this.endGrip.role = "slider";
      _this.events.once("inited", function() {
        _this._previousStart = void 0;
        _this.dispatchRangeChange();
      }, void 0, false);
      _this.hideGrips = false;
      _this.orientation = "horizontal";
      _this.setSVGAttribute({ "aria-valuemin": "0" });
      _this.setSVGAttribute({ "aria-valuemax": "100" });
      _this.applyTheme();
      return _this;
    }
    Scrollbar2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (this.orientation === "horizontal") {
        if (!hasValue(this.readerTitle)) {
          this.readerTitle = this.language.translate("Use TAB to select grip buttons or left and right arrows to change selection");
        }
        if (!hasValue(this.thumb.readerDescription)) {
          this.thumb.readerDescription = this.language.translate("Use left and right arrows to move selection");
        }
        if (!hasValue(this.startGrip.readerDescription)) {
          this.startGrip.readerDescription = this.language.translate("Use left and right arrows to move left selection");
        }
        if (!hasValue(this.endGrip.readerDescription)) {
          this.endGrip.readerDescription = this.language.translate("Use left and right arrows to move right selection");
        }
        this.readerOrientation = "horizontal";
      } else {
        if (!hasValue(this.readerTitle)) {
          this.readerTitle = this.language.translate("Use TAB select grip buttons or up and down arrows to change selection");
        }
        if (!hasValue(this.thumb.readerDescription)) {
          this.thumb.readerDescription = this.language.translate("Use up and down arrows to move selection");
        }
        if (!hasValue(this.startGrip.readerDescription)) {
          this.startGrip.readerDescription = this.language.translate("Use up and down arrows to move upper selection");
        }
        if (!hasValue(this.endGrip.readerDescription)) {
          this.endGrip.readerDescription = this.language.translate("Use up and down arrows to move lower selection");
        }
        this.readerOrientation = "vertical";
      }
      this.readerControls = this.baseSprite.uidAttr();
    };
    Scrollbar2.prototype.validateLayout = function() {
      this.updateSize();
      _super.prototype.validateLayout.call(this);
      this.updateExtremes();
    };
    Scrollbar2.prototype.processBackground = function() {
      _super.prototype.processBackground.call(this);
      var background = this.background;
      background.clickable = true;
      background.events.on("hit", this.handleBgHit, this, void 0);
    };
    Scrollbar2.prototype.handleBgHit = function(event) {
      this.makeBusy();
      var point = event.spritePoint;
      point = spritePointToSprite(point, this.background, this);
      var thumb = this.thumb;
      if (this.orientation == "horizontal") {
        var thumbX = point.x - thumb.pixelWidth / 2;
        thumbX = fitToRange(thumbX, 0, this.innerWidth - thumb.pixelWidth);
        this._thumbAnimation = thumb.animate({ property: "x", to: thumbX }, this.animationDuration, this.animationEasing);
      } else {
        var thumbY = point.y - thumb.pixelHeight / 2;
        thumbY = fitToRange(thumbY, 0, this.innerHeight - thumb.pixelHeight);
        this._thumbAnimation = thumb.animate({ property: "y", to: thumbY }, this.animationDuration, this.animationEasing);
      }
      if (this.animationDuration > 0) {
        this._thumbAnimation.events.on("animationended", this.makeUnbusy, this, false);
      } else {
        this._thumb.validate();
        this.makeUnbusy();
      }
    };
    Scrollbar2.prototype.makeBusy = function() {
      this._isBusy = true;
      this._skipRangeEvents = false;
      if (this._unbusyTimeout) {
        this.removeDispose(this._unbusyTimeout);
      }
      this._unbusyTimeout = void 0;
      this.stopAnimations();
    };
    Scrollbar2.prototype.stopAnimations = function() {
      if (this._thumbAnimation) {
        this._thumbAnimation.stop(true);
      }
      if (this._zoomAnimation) {
        this._zoomAnimation.stop(true);
      }
    };
    Scrollbar2.prototype.makeUnbusy = function() {
      this._unbusyTimeout = this.setTimeout(this.makeUnbusyReal.bind(this), this.animationDuration * 1.1);
    };
    Scrollbar2.prototype.makeUnbusyReal = function() {
      this._usingGrip = void 0;
      this._isBusy = false;
      if (!this.updateWhileMoving) {
        this.dispatchRangeChange();
      }
    };
    Scrollbar2.prototype.dispatchRangeChange = function() {
      if (this._previousEnd != this.end || this._previousStart != this.start) {
        this._previousStart = this.start;
        this._previousEnd = this.end;
        this.dispatch("rangechanged");
      }
    };
    Scrollbar2.prototype.updateThumb = function(dispatchEvents) {
      if (dispatchEvents === void 0) {
        dispatchEvents = true;
      }
      if (!this.parent) {
        return;
      }
      var thumb = this.thumb;
      var start = this.start;
      var end = this.end;
      var startGrip = this.startGrip;
      var endGrip = this.endGrip;
      var directionFlipped = this.adapter.apply("positionValueDirection", {
        flipped: false
      }).flipped;
      var fromName = directionFlipped ? "To %1" : "From %1";
      var toName = directionFlipped ? "From %1" : "To %1";
      var fromValue;
      var toValue;
      if (this.orientation == "horizontal") {
        var innerWidth_1 = this.innerWidth;
        thumb.width = innerWidth_1 * (end - start);
        thumb.maxX = innerWidth_1 - thumb.pixelWidth;
        thumb.x = start * innerWidth_1;
        startGrip.moveTo({ x: thumb.pixelX, y: 0 }, void 0, void 0, true);
        endGrip.moveTo({ x: thumb.pixelX + thumb.pixelWidth, y: 0 }, void 0, void 0, true);
        fromValue = this.adapter.apply("positionValue", {
          value: Math.round(start * 100) + "%",
          position: start
        }).value;
        toValue = this.adapter.apply("positionValue", {
          value: Math.round(end * 100) + "%",
          position: end
        }).value;
        startGrip.readerTitle = this.language.translate(fromName, void 0, fromValue);
        startGrip.readerValueNow = "" + Math.round(start * 100);
        startGrip.readerValueText = startGrip.readerTitle;
        endGrip.readerTitle = this.language.translate(toName, void 0, toValue);
        endGrip.readerValueNow = "" + Math.round(end * 100);
        endGrip.readerValueText = endGrip.readerTitle;
      } else {
        var innerHeight_1 = this.innerHeight;
        thumb.height = innerHeight_1 * (end - start);
        thumb.maxY = innerHeight_1 - thumb.pixelHeight;
        thumb.y = (1 - end) * innerHeight_1;
        startGrip.moveTo({ x: 0, y: thumb.pixelY + thumb.pixelHeight }, void 0, void 0, true);
        endGrip.moveTo({ x: 0, y: thumb.pixelY }, void 0, void 0, true);
        fromValue = this.adapter.apply("positionValue", {
          value: Math.round((1 - start) * 100) + "%",
          position: 1 - start
        }).value;
        toValue = this.adapter.apply("positionValue", {
          value: Math.round((1 - end) * 100) + "%",
          position: 1 - end
        }).value;
        startGrip.readerTitle = this.language.translate(toName, void 0, fromValue);
        startGrip.readerValueNow = "" + Math.round(start * 100);
        startGrip.readerValueText = startGrip.readerTitle;
        endGrip.readerTitle = this.language.translate(fromName, void 0, toValue);
        endGrip.readerValueNow = "" + Math.round(end * 100);
        endGrip.readerValueText = endGrip.readerTitle;
      }
      thumb.readerTitle = this.language.translate("From %1 to %2", void 0, fromValue, toValue);
      thumb.readerValueNow = "" + Math.round(start * 100);
      thumb.readerValueText = thumb.readerTitle;
      this.readerValueNow = "" + Math.round(start * 100);
      this.readerValueText = thumb.readerTitle;
      if (!this._skipRangeEvents && this.updateWhileMoving && dispatchEvents) {
        this.dispatchRangeChange();
      }
    };
    Scrollbar2.prototype.updateExtremes = function() {
      var orientation = this.orientation;
      var minX = 0;
      var minY = 0;
      var maxX = 0;
      var maxY = 0;
      if (orientation == "horizontal") {
        maxX = this.innerWidth;
        minY = maxY = this.innerHeight / 2;
      } else {
        maxY = this.innerHeight;
        minX = maxX = this.innerWidth / 2;
      }
      var startGrip = this.startGrip;
      startGrip.minX = minX;
      startGrip.maxX = maxX;
      startGrip.minY = minY;
      startGrip.maxY = maxY;
      var endGrip = this.endGrip;
      endGrip.minX = minX;
      endGrip.maxX = maxX;
      endGrip.minY = minY;
      endGrip.maxY = maxY;
      var thumb = this.thumb;
      thumb.minX = minX;
      thumb.maxX = maxX;
      thumb.minY = minY;
      thumb.maxY = maxY;
    };
    Scrollbar2.prototype.updateSize = function() {
      var orientation = this.orientation;
      var startGrip = this.startGrip;
      if (startGrip) {
        startGrip.orientation = orientation;
      }
      if (this.endGrip) {
        this.endGrip.orientation = orientation;
      }
      var thumb = this.thumb;
      if (thumb) {
        if (orientation == "horizontal") {
          if (!isNumber(this._pixelWidth)) {
            if (!(this.width instanceof Percent)) {
              this.width = percent(100);
            }
          }
          if (hasValue(this.percentHeight)) {
            this.height = this.minHeight;
          }
          thumb.height = this.innerHeight;
          thumb.verticalCenter = "middle";
          thumb.horizontalCenter = "left";
        } else {
          if (!isNumber(this._pixelHeight)) {
            if (!(this.height instanceof Percent)) {
              this.height = percent(100);
            }
          }
          if (hasValue(this.percentWidth)) {
            this.width = this.minWidth;
          }
          thumb.width = this.innerWidth;
          thumb.verticalCenter = "top";
          thumb.horizontalCenter = "middle";
        }
      }
    };
    Object.defineProperty(Scrollbar2.prototype, "isBusy", {
      /**
       * Indicates if the Scrollbar is currently "busy" (animating and or
       * performing zoom by user interaction).
       * @return boolean
       */
      get: function() {
        return this._isBusy;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "start", {
      /**
       * @return Position (0-1)
       */
      get: function() {
        return Math.min(this.getPosition(this._start), this.getPosition(this._end));
      },
      /**
       * ==========================================================================
       * POSITIONS
       * ==========================================================================
       * @hidden
       */
      /**
       * Relative position (0-1) of the start grip.
       *
       * @param position  Position (0-1)
       */
      set: function(position) {
        if (!this._isBusy) {
          this.__start = position;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "__start", {
      /**
       * @return [description]
       */
      get: function() {
        return this._start;
      },
      /**
       * [__start description]
       *
       * @todo Description
       * @param position [description]
       */
      set: function(position) {
        this._start = this.getPosition(position);
        this.updateThumb();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "end", {
      /**
       * @return Position (0-1)
       */
      get: function() {
        return Math.max(this.getPosition(this._start), this.getPosition(this._end));
      },
      /**
       * Relative position (0-1) of the end grip.
       *
       * @param position  Position (0-1)
       */
      set: function(position) {
        if (!this._isBusy) {
          this.__end = position;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "__end", {
      /**
       * @return [description]
       */
      get: function() {
        return this._end;
      },
      /**
       * [__end description]
       *
       * @todo Description
       * @param position [description]
       */
      set: function(position) {
        this._end = this.getPosition(position);
        this.updateThumb();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "range", {
      /**
       * Current selection range.
       *
       * @readonly
       * @return Range
       */
      get: function() {
        return { start: this.start, end: this.end, priority: this._usingGrip };
      },
      enumerable: true,
      configurable: true
    });
    Scrollbar2.prototype.skipRangeEvents = function() {
      if (!this._isBusy) {
        this._skipRangeEvents = true;
      }
    };
    Scrollbar2.prototype.fixRange = function(range) {
      if (range.start != round(this._start, 2) || range.end != round(this._end, 2)) {
        this._start = range.start;
        this._end = range.end;
        this._skipRangeEvents = true;
        this.updateThumb();
        this._skipRangeEvents = false;
        this.thumb.validate();
        this.thumb.background.validate();
      }
    };
    Scrollbar2.prototype.getPosition = function(position) {
      return fitToRange(round(position, 4), 0, 1);
    };
    Object.defineProperty(Scrollbar2.prototype, "orientation", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("orientation");
      },
      /**
       * ==========================================================================
       * MISC
       * ==========================================================================
       * @hidden
       */
      /**
       * Orientation of the scrollbar.
       *
       * Available options: "horizontal" (default) and "vertical".
       *
       * @default "horizontal"
       * @param value  Orientation
       */
      set: function(value) {
        if (this.setPropertyValue("orientation", value)) {
          if (value === "horizontal") {
            this.startGrip.cursorOverStyle = MouseCursorStyle.horizontalResize;
            this.endGrip.cursorOverStyle = MouseCursorStyle.horizontalResize;
          } else {
            this.startGrip.cursorOverStyle = MouseCursorStyle.verticalResize;
            this.endGrip.cursorOverStyle = MouseCursorStyle.verticalResize;
          }
          this.updateByOrientation();
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Scrollbar2.prototype.updateByOrientation = function() {
    };
    Object.defineProperty(Scrollbar2.prototype, "startGrip", {
      /**
       * @return Grip element
       */
      get: function() {
        return this._startGrip;
      },
      /**
       * ==========================================================================
       * GRIPS
       * ==========================================================================
       * @hidden
       */
      /**
       * Start grip element. (button)
       *
       * @param button  Grip element
       */
      set: function(button) {
        if (this._startGrip) {
          this.removeDispose(this._startGrip);
        }
        this._startGrip = button;
        this.processGrip(button);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "endGrip", {
      /**
       * @return Grip element
       */
      get: function() {
        return this._endGrip;
      },
      /**
       * End grip element. (button)
       *
       * @param button  Grip element
       */
      set: function(button) {
        if (this._endGrip) {
          this.removeDispose(this._endGrip);
        }
        this._endGrip = button;
        this.processGrip(button);
      },
      enumerable: true,
      configurable: true
    });
    Scrollbar2.prototype.processGrip = function(button) {
      button.parent = this;
      button.isMeasured = false;
      button.focusable = true;
      button.shouldClone = false;
      button.zIndex = 100;
      button.events.on("drag", this.handleGripDrag, this, false);
      button.events.on("dragstop", this.makeUnbusy, this, false);
      button.events.on("down", this.makeBusy, this, false);
      button.events.on("up", this.makeUnbusy, this, false);
      this._disposers.push(button);
    };
    Scrollbar2.prototype.handleGripDrag = function(event) {
      this.makeBusy();
      if (event.target === this._startGrip) {
        this._usingGrip = "start";
      } else {
        this._usingGrip = "end";
      }
      if (this.orientation == "horizontal") {
        this._start = this.startGrip.pixelX / this.innerWidth;
        this._end = this.endGrip.pixelX / this.innerWidth;
      } else {
        this._start = 1 - this.startGrip.pixelY / this.innerHeight;
        this._end = 1 - this.endGrip.pixelY / this.innerHeight;
      }
      this.updateThumb();
    };
    Object.defineProperty(Scrollbar2.prototype, "thumb", {
      /**
       * @return Thumb element
       */
      get: function() {
        if (!this._thumb) {
          var thumb = new Button();
          thumb.background.cornerRadius(10, 10, 10, 10);
          thumb.padding(0, 0, 0, 0);
          this.thumb = thumb;
        }
        return this._thumb;
      },
      /**
       * A "thumb" element.
       *
       * It's a draggable square space between the grips, that can be used to
       * pan the selection.
       *
       * @param thumb  Thumb element
       */
      set: function(thumb) {
        var _this = this;
        if (thumb) {
          if (this._thumb) {
            this.removeDispose(this._thumb);
          }
          this._thumb = thumb;
          thumb.parent = this;
          thumb.isMeasured = false;
          thumb.inert = true;
          thumb.draggable = true;
          thumb.clickable = true;
          thumb.hoverable = true;
          thumb.focusable = true;
          thumb.shouldClone = false;
          thumb.zIndex = 0;
          thumb.cursorOverStyle = MouseCursorStyle.grab;
          thumb.cursorDownStyle = MouseCursorStyle.grabbing;
          thumb.events.on("dragstart", this.makeBusy, this, false);
          thumb.events.on("dragstop", this.makeUnbusy, this, false);
          thumb.events.on("positionchanged", this.handleThumbPosition, this, false);
          thumb.events.on("sizechanged", this.handleThumbPosition, this, false);
          thumb.events.on("doublehit", this.handleDoubleClick, this, false);
          this._disposers.push(getInteraction().body.events.on("keyup", function(ev) {
            if (keyboard.isKey(ev.event, ["space", "enter"]) && _this.thumb.isFocused) {
              ev.event.preventDefault();
              _this.handleDoubleClick();
            }
          }));
          this._disposers.push(this._thumb);
        }
      },
      enumerable: true,
      configurable: true
    });
    Scrollbar2.prototype.handleDoubleClick = function() {
      this.makeBusy();
      var newStart = 0;
      var newEnd = 1;
      if (this.start != 0 || this.end != 1) {
        this._prevStart = this.start;
        this._prevEnd = this.end;
      } else {
        newStart = this._prevStart;
        newEnd = this._prevEnd;
      }
      var zoomAnimation = this.animate([{ property: "__start", to: newStart }, { property: "__end", to: newEnd }], this.animationDuration, this.animationEasing);
      if (zoomAnimation && !zoomAnimation.isFinished()) {
        zoomAnimation.events.on("animationended", this.makeUnbusy, this, false);
        this._zoomAnimation = zoomAnimation;
      } else {
        this.makeUnbusy();
      }
    };
    Scrollbar2.prototype.handleThumbPosition = function() {
      var thumb = this.thumb;
      if (this.orientation == "horizontal") {
        var innerWidth_2 = this.innerWidth;
        var w = thumb.innerWidth;
        var x = thumb.pixelX;
        this._start = x / innerWidth_2;
        this._end = (x + w) / innerWidth_2;
        this.updateThumb();
      } else {
        var innerHeight_2 = this.innerHeight;
        var h = thumb.innerHeight;
        var y = thumb.pixelY;
        if (y + h > innerHeight_2) {
          y = innerHeight_2 - h;
          thumb.y = y;
        }
        this._start = 1 - (y + h) / innerHeight_2;
        this._end = 1 - y / innerHeight_2;
        this.updateThumb();
      }
    };
    Scrollbar2.prototype.createBackground = function() {
      return new RoundedRectangle();
    };
    Object.defineProperty(Scrollbar2.prototype, "hideGrips", {
      /**
       * @return Show only on hover?
       */
      get: function() {
        return this._hideGrips;
      },
      /**
       * Use this property to set whether grips should be always visible (`false`),
       * or they should just appear on scrollbar hover (`true`).
       *
       * @param value  Show only on hover?
       */
      set: function(value) {
        var _this = this;
        this._hideGrips = value;
        if (this._overDisposer) {
          this.removeDispose(this._overDisposer);
        }
        if (this._outDisposer) {
          this.removeDispose(this._outDisposer);
        }
        if (value) {
          this._overDisposer = this.events.on("over", function() {
            _this.startGrip.show();
            _this.endGrip.show();
          }, void 0, false);
          this._outDisposer = this.events.on("out", function() {
            _this.startGrip.hide();
            _this.endGrip.hide();
          }, void 0, false);
          this.startGrip.hide();
          this.endGrip.hide();
        } else {
          this.startGrip.show();
          this.endGrip.show();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "animationDuration", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("animationDuration");
      },
      /**
       * Duration in milliseconds of scrollbar animation (happens when user clicks on a background of a scrollbar)
       * @default 0
       * @param value number
       */
      set: function(value) {
        this.setPropertyValue("animationDuration", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "animationEasing", {
      /**
       * @return {Function}
       */
      get: function() {
        return this.getPropertyValue("animationEasing");
      },
      /**
       * Animation easing function.
       * @todo: review description and default
       * @default $ease.cubicOut
       * @param value (value: number) => number
       */
      set: function(value) {
        this.setPropertyValue("animationEasing", value);
      },
      enumerable: true,
      configurable: true
    });
    Scrollbar2.prototype.asFunction = function(field) {
      return field == "animationEasing" || _super.prototype.asIs.call(this, field);
    };
    return Scrollbar2;
  }(Container)
);
registry.registeredClasses["Scrollbar"] = Scrollbar;

// node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/Filter.js
var Filter = (
  /** @class */
  function(_super) {
    __extends(Filter2, _super);
    function Filter2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.properties = {};
      _this.isTemplate = false;
      _this._scale = 1;
      _this._nonScaling = true;
      _this.className = "Filter";
      _this.filterPrimitives = new List();
      _this.properties.filterUnits = "objectBoundingBox";
      _this.filterPrimitives.events.on("inserted", function(ev) {
        _this._disposers.push(ev.newValue);
      });
      _this.width = 120;
      _this.height = 120;
      _this.applyTheme();
      return _this;
    }
    Filter2.prototype.appendPrimitives = function(filterElement) {
      each3(this.filterPrimitives.iterator(), function(filterPrimitive) {
        filterElement.add(filterPrimitive);
      });
    };
    Filter2.prototype.animate = function(animationOptions, duration, easing) {
      var animation = new Animation(this, animationOptions, duration, easing).start();
      return animation;
    };
    Object.defineProperty(Filter2.prototype, "width", {
      /**
       * @return Width (%)
       */
      get: function() {
        return this.properties["width"];
      },
      /**
       * Width of the filter element in percent.
       *
       * If the filter is designed to "bleed out" of the original target element,
       * like for example a shadow, you need this bigger than 100, or the
       * non-fitting parts will be clipped.
       *
       * @default 120
       * @param value Width (px)
       */
      set: function(value) {
        this.properties["width"] = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "height", {
      /**
       * @return Height
       */
      get: function() {
        return this.properties["height"];
      },
      /**
       * Height of the filter element in percent.
       *
       * If the filter is designed to "bleed out" of the original target element,
       * like for example a shadow, you need this bigger than 100, or the
       * non-fitting parts will be clipped.
       *
       * @default 120
       * @param value Height (%)
       */
      set: function(value) {
        this.properties["height"] = value;
      },
      enumerable: true,
      configurable: true
    });
    Filter2.prototype.copyFrom = function(filter) {
      var _this = this;
      _super.prototype.copyFrom.call(this, filter);
      each2(filter.properties, function(key, value) {
        _this[key] = value;
      });
    };
    Object.defineProperty(Filter2.prototype, "paper", {
      /**
       * @return Paper
       */
      get: function() {
        if (this._paper) {
          return this._paper;
        }
        return getGhostPaper();
      },
      /**
       * Sets [[Paper]] instance to create filter's elements in.
       *
       * @ignore Exclude from docs
       * @param paper  Paper
       */
      set: function(paper) {
        if (this._paper != paper) {
          this._paper = paper;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "animations", {
      /**
       * All animations currently in play.
       *
       * @ignore Exclude from docs
       * @return List of animations
       */
      get: function() {
        if (!this._animations) {
          this._animations = [];
          this._disposers.push(new AnimationDisposer(this._animations));
        }
        return this._animations;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "scale", {
      /**
       * @ignore Exclude from docs
       */
      get: function() {
        return this._scale;
      },
      /**
       * [[Sprite]] uses this method to inform filter about it's scale.
       *
       * @ignore Exclude from docs
       */
      set: function(value) {
        this._scale = value;
        this.updateScale();
      },
      enumerable: true,
      configurable: true
    });
    Filter2.prototype.updateScale = function() {
    };
    Object.defineProperty(Filter2.prototype, "filterUnits", {
      /**
       * @return Filter units
       */
      get: function() {
        return this.properties.filterUnits;
      },
      /**
       * Which units are used when drawing filter.
       *
       * Use `"userSpaceOnUse"` when applying filters on a perfectly straight line.
       *
       * @since 4.9.17
       * @default objectBoundingBox
       * @param value Filter units
       */
      set: function(value) {
        this.properties.filterUnits = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "nonScaling", {
      /**
       * @return Non scaling?
       */
      get: function() {
        return this._nonScaling;
      },
      /**
       * If a filter is non scaling, it will look the same even if the sprite is
       * scaled, otherwise filter will scale together with a [[Sprite]].
       *
       * @default false
       * @param value  Non scaling?
       */
      set: function(value) {
        this._nonScaling = value;
        if (!value) {
          this._scale = 1;
        }
        this.updateScale();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "sprite", {
      /**
       * A target element this filter is currently attached to.
       *
       * We need to keep track of it because one filter can be used for just one
       * element, so we have to remove it from the old "parent" when attaching to
       * the new one.
       *
       * @ignore Exclude from docs
       * @param value  Target element
       */
      set: function(value) {
        this.setSprite(value);
      },
      enumerable: true,
      configurable: true
    });
    Filter2.prototype.setSprite = function(value) {
      if (this._sprite && this._sprite != value) {
        this._sprite.filters.removeValue(this);
      }
      this._sprite = value;
    };
    return Filter2;
  }(BaseObject)
);

// node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/DropShadowFilter.js
var DropShadowFilter = (
  /** @class */
  function(_super) {
    __extends(DropShadowFilter2, _super);
    function DropShadowFilter2() {
      var _this = _super.call(this) || this;
      _this.className = "DropShadowFilter";
      _this.color = color("#000");
      _this.feGaussianBlur = _this.paper.add("feGaussianBlur");
      _this.feGaussianBlur.attr({ "result": "blurOut", "in": "SourceGraphic" });
      _this.filterPrimitives.push(_this.feGaussianBlur);
      _this.feOffset = _this.paper.add("feOffset");
      _this.feOffset.attr({ "result": "offsetBlur" });
      _this.filterPrimitives.push(_this.feOffset);
      _this.feFlood = _this.paper.add("feFlood");
      _this.feFlood.attr({ "flood-color": _this.color });
      _this.filterPrimitives.push(_this.feFlood);
      _this.feComposite = _this.paper.add("feComposite");
      _this.feComposite.attr({ "in2": "offsetBlur", operator: "in" });
      _this.filterPrimitives.push(_this.feComposite);
      _this.feMerge = _this.paper.addGroup("feMerge");
      _this.feMerge.add(_this.paper.add("feMergeNode"));
      _this.feMerge.add(_this.paper.add("feMergeNode").attr({ "in": "SourceGraphic" }));
      _this.filterPrimitives.push(_this.feMerge);
      _this.width = 200;
      _this.height = 200;
      _this.blur = 1.5;
      _this.dx = 3;
      _this.dy = 3;
      _this.opacity = 0.5;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(DropShadowFilter2.prototype, "color", {
      /**
       * @return Color
       */
      get: function() {
        return this.properties.color;
      },
      /**
       * Shadow color.
       *
       * @param value  Color
       */
      set: function(value) {
        this.properties.color = value;
        if (this.feFlood) {
          this.feFlood.attr({ "flood-color": value });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DropShadowFilter2.prototype, "opacity", {
      /**
       * @return Opacity (0-1)
       */
      get: function() {
        return this.properties.opacity;
      },
      /**
       * Opacity of the shadow. (0-1)
       *
       * @param value  Opacity (0-1)
       */
      set: function(value) {
        this.properties.opacity = value;
        this.feFlood.attr({ "flood-opacity": value });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DropShadowFilter2.prototype, "dx", {
      /**
       * @return Horizontal offset (px)
       */
      get: function() {
        return this.properties.dx;
      },
      /**
       * Horizontal offset in pixels.
       *
       * @param value  Horizontal offset (px)
       */
      set: function(value) {
        this.properties.dx = value;
        this.feOffset.attr({ "dx": value / this.scale });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DropShadowFilter2.prototype, "dy", {
      /**
       * @return Vertical offset (px)
       */
      get: function() {
        return this.properties.dy;
      },
      /**
       * Vertical offset in pixels.
       *
       * @param value Vertical offset (px)
       */
      set: function(value) {
        this.properties.dy = value;
        this.feOffset.attr({ "dy": value / this.scale });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DropShadowFilter2.prototype, "blur", {
      /**
       * @return Blur
       */
      get: function() {
        return this.properties.blur;
      },
      /**
       * Blur.
       *
       * @param value  Blur
       */
      set: function(value) {
        this.properties.blur = value;
        this.feGaussianBlur.attr({ "stdDeviation": value / this.scale });
      },
      enumerable: true,
      configurable: true
    });
    DropShadowFilter2.prototype.updateScale = function() {
      this.dx = this.dx;
      this.dy = this.dy;
      this.blur = this.blur;
    };
    return DropShadowFilter2;
  }(Filter)
);
registry.registeredClasses["DropShadowFilter"] = DropShadowFilter;

// node_modules/@amcharts/amcharts4/.internal/core/elements/Tooltip.js
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip2, _super);
    function Tooltip2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._boundingRect = { x: -4e4, y: -4e4, width: 8e4, height: 8e4 };
      _this._pointTo = { x: 0, y: 0 };
      _this.fitPointerToBounds = false;
      _this._verticalOrientation = "up";
      _this.fixDoc = true;
      _this.className = "Tooltip";
      _this.isMeasured = false;
      _this.getFillFromObject = true;
      _this.margin(5, 5, 5, 5);
      _this.defaultState.transitionDuration = 1;
      _this.hiddenState.transitionDuration = 1;
      var background = _this.background;
      background.interactionsEnabled = false;
      background.fillOpacity = 0.9;
      background.strokeWidth = 1;
      background.strokeOpacity = 1;
      background.stroke = color("#ffffff");
      background.cornerRadius = 3;
      background.pointerLength = 6;
      background.pointerBaseWidth = 10;
      var dropShadow = new DropShadowFilter();
      dropShadow.dy = 1;
      dropShadow.dx = 1;
      dropShadow.opacity = 0.5;
      background.filters.push(dropShadow);
      _this.autoTextColor = true;
      var label = _this.createChild(Label);
      label.shouldClone = false;
      _this.label = label;
      label.padding(7, 12, 4, 12);
      label.interactionsEnabled = false;
      label.horizontalCenter = "middle";
      label.fill = color("#ffffff");
      _this._disposers.push(label);
      _this.label.events.on("sizechanged", _this.drawBackground, _this);
      _this.label.zIndex = 1;
      _this.pointerOrientation = "vertical";
      _this.animationDuration = 0;
      _this.animationEasing = cubicOut;
      _this.setPropertyValue("showInViewport", false);
      _this.role = "tooltip";
      _this.visible = false;
      _this.opacity = 0;
      _this.x = 0;
      _this.y = 0;
      _this.events.on("visibilitychanged", _this.handleVisibility, _this);
      _this.applyTheme();
      return _this;
    }
    Tooltip2.prototype.handleVisibility = function() {
      if (this.visible) {
        this.label.invalidate();
      }
    };
    Object.defineProperty(Tooltip2.prototype, "getStrokeFromObject", {
      /**
       * Specifies if tooltip background should get stroke color from the sprite it is pointing to.
       *
       * @return {boolean}
       * @default false
       */
      get: function() {
        return this.getPropertyValue("getStrokeFromObject");
      },
      /**
       * Specifies if tooltip background should get stroke color from the sprite it is pointing to.
       *
       * @param value boolean
       */
      set: function(value) {
        this.setPropertyValue("getStrokeFromObject", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "autoTextColor", {
      /**
       * @return {boolean}
       */
      get: function() {
        return this.getPropertyValue("autoTextColor");
      },
      /**
       * Specifies if text color should be chosen automatically for a better
       * readability.
       *
       * IMPORTANT: this feature is generally ignored, if `getFillFromObject = false`.
       *
       * If inheriting of `fill` color from object tooltip is displayed for is
       * disabled, this feature will not work. If you are explicitly setting a
       * color for tooltip background, you may set a color for its label as well
       * using `tooltip.label.fill` property.
       *
       *
       * @param value boolean
       */
      set: function(value) {
        this.setPropertyValue("autoTextColor", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "keepTargetHover", {
      /**
       * @return Keep target hovered?
       */
      get: function() {
        return this.getPropertyValue("keepTargetHover");
      },
      /**
       * If this tooltip is displayed on hover on some other object, keep that
       * element hovered if hovering on the tooltip.
       *
       * @default false
       * @since 4.1.13
       * @param  value  Keep target hovered?
       */
      set: function(value) {
        var _this = this;
        if (this.setPropertyValue("keepTargetHover", value, true)) {
          if (value) {
            this.hoverable = true;
            this.background.interactionsEnabled = true;
            this._disposers.push(this.events.on("over", function(ev) {
              if (_this.targetSprite && _this.targetSprite.hoverable) {
                _this.targetSprite.isHover = true;
              }
            }));
            this._disposers.push(this.events.on("out", function(ev) {
              if (_this.targetSprite && _this.targetSprite.hoverable) {
                _this.targetSprite.isHover = false;
              }
            }));
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "showInViewport", {
      /**
       * @return Force showing tooltip?
       */
      get: function() {
        return this.getPropertyValue("showInViewport");
      },
      /**
       * Normally, a tooltip will hide itself if it is pointing to a coordinate
       * that is outside viewport.
       *
       * Setting this setting to `true` will override that and make tooltip
       * appear next to the viewport edge closest to the target point.
       *
       * @default false
       * @since 4.5.7
       * @param  value  Force showing tooltip?
       */
      set: function(value) {
        this.setPropertyValue("showInViewport", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "getFillFromObject", {
      /**
       * Specifies if tooltip background should get fill color from the sprite it is pointing to.
       *
       * @return {boolean}
       * @default true
       */
      get: function() {
        return this.getPropertyValue("getFillFromObject");
      },
      /**
       * @param value boolean
       */
      set: function(value) {
        this.setPropertyValue("getFillFromObject", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Tooltip2.prototype.createBackground = function() {
      return new PointedRectangle();
    };
    Object.defineProperty(Tooltip2.prototype, "pointerOrientation", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("pointerOrientation");
      },
      /**
       * Pointer orientation: `"horizontal"`, `"vertical"`, `"up"`, `"down"`,
       * `"right"`, or `"left"`.
       *
       * Options`"horizontal"` or `"vertical"` are location-aware, meaning they
       * will change position of the Tooltip based on the target point's position
       * in relation to chart center.
       *
       * Options `"up"`, `"down"`, `"right"`, `"left"` are static and will point
       * in the specified direction regardless of the position, even if that means
       * going out of chart/screen bounds.
       *
       * IMPORTANT: in some situations, like having multiple tooltips stacked for
       * multiple series, the `"up"` and `"down"` values might be ignored in order
       * to make tooltip overlap algorithm work.
       *
       * @default "vertical"
       * @param  value  Orientation
       */
      set: function(value) {
        this.setPropertyValue("pointerOrientation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "animationDuration", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("animationDuration");
      },
      /**
       * Duration in milliseconds for the animation to take place when the tooltip
       * is moving from one place to another.
       *
       * @default 0
       * @param value  number
       */
      set: function(value) {
        this.setPropertyValue("animationDuration", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "animationEasing", {
      /**
       * @return {Function}
       */
      get: function() {
        return this.getPropertyValue("animationEasing");
      },
      /**
       * Tooltip animation (moving from one place to another) easing function.
       *
       * @default $ease.cubicOut
       * @param value (value: number) => number
       */
      set: function(value) {
        this.setPropertyValue("animationEasing", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "html", {
      /**
       * @return HTML content
       */
      get: function() {
        return this.label.html;
      },
      /**
       * HTML content for the Tooltip.
       *
       * Provided value will be used as is, without applying any further
       * formatting to it.
       *
       * @param value  HTML content
       */
      set: function(value) {
        if (this.label.html != value) {
          this.label.html = value;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "text", {
      /**
       * @return SVG text
       */
      get: function() {
        return this.label.text;
      },
      /**
       * SVG text content for the Tooltip.
       *
       * Text can have a number of formatting options supported by
       * [[TextFormatter]].
       *
       * @param value  SVG text
       */
      set: function(value) {
        if (this.label.text != value) {
          this.label.text = value;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Tooltip2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var label = this.label;
      if (label.invalid) {
        label.validate();
      }
      var x = this._pointTo.x;
      var y = this._pointTo.y;
      var boundingRect = this._boundingRect;
      var textW = label.measuredWidth;
      var textH = label.measuredHeight;
      var pointerLength = this.background.pointerLength;
      var textX;
      var textY;
      if (this.ignoreBounds) {
        boundingRect = void 0;
      }
      if (boundingRect && this.fixDoc && textW > boundingRect.width) {
        spritePointToDocument({ x: boundingRect.x, y: boundingRect.y }, this.parent);
        var p1 = spritePointToDocument({ x: boundingRect.x + boundingRect.width, y: boundingRect.y + boundingRect.height }, this.parent);
        var documentWidth = document.body.offsetWidth;
        used(document.body.offsetHeight);
        if (p1.x > documentWidth / 2) {
          boundingRect.x = boundingRect.width - textW;
        } else {
          boundingRect.width = boundingRect.x + textW;
        }
      }
      var pointerOrientation = this.pointerOrientation;
      if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {
        textY = -textH / 2;
        if (pointerOrientation == "horizontal") {
          if (boundingRect && x > boundingRect.x + boundingRect.width / 2) {
            textX = -textW / 2 - pointerLength;
          } else {
            textX = textW / 2 + pointerLength;
          }
        } else if (pointerOrientation == "left") {
          textX = textW / 2 + pointerLength;
        } else {
          textX = -textW / 2 - pointerLength;
        }
      } else {
        if (boundingRect) {
          textX = fitToRange(0, boundingRect.x - x + textW / 2, boundingRect.x - x + boundingRect.width - textW / 2);
        }
        if (pointerOrientation == "vertical") {
          if (boundingRect && y > boundingRect.y + textH + pointerLength) {
            textY = -textH - pointerLength;
            this._verticalOrientation = "up";
          } else {
            textY = pointerLength;
            this._verticalOrientation = "down";
          }
        } else if (pointerOrientation == "down") {
          textY = -textH - pointerLength;
          this._verticalOrientation = "up";
        } else {
          textY = pointerLength;
          this._verticalOrientation = "down";
        }
      }
      if (boundingRect) {
        textY = fitToRange(textY, boundingRect.y - y, boundingRect.y + boundingRect.height - textH - y);
      }
      label.x = textX;
      label.y = textY;
      this.drawBackground();
    };
    Tooltip2.prototype.updateBackground = function() {
      this.group.addToBack(this.background.group);
    };
    Tooltip2.prototype.drawBackground = function() {
      var label = this.label;
      var background = this.background;
      var textWidth = label.measuredWidth;
      var textHeight = label.measuredHeight;
      var boundingRect = this._boundingRect;
      var bgWidth = textWidth;
      var bgX = label.pixelX - textWidth / 2;
      var bgHeight = textHeight;
      var bgY = label.pixelY;
      var x = this._pointTo.x;
      var y = this._pointTo.y;
      var boundX1 = boundingRect.x - x;
      var boundX2 = boundX1 + boundingRect.width;
      var boundY1 = boundingRect.y - y;
      var boundY2 = boundY1 + boundingRect.height;
      background.x = bgX;
      background.y = bgY;
      background.width = bgWidth;
      background.height = bgHeight;
      if (this.fitPointerToBounds) {
        background.pointerX = fitToRange(-background.x, boundX1 - background.x, boundX2 - background.x);
        background.pointerY = fitToRange(-background.y, boundY1 - background.y, boundY2 - background.y);
      } else {
        background.pointerX = -background.x;
        background.pointerY = -background.y;
      }
      background.validate();
    };
    Tooltip2.prototype.delayedPointTo = function(point, instantly) {
      var _this = this;
      if (this._pointToDisposer) {
        this._pointToDisposer.dispose();
      }
      this._pointToDisposer = registry.events.once("exitframe", function() {
        _this.pointTo(point, instantly);
      });
      this.addDisposer(this._pointToDisposer);
    };
    Tooltip2.prototype.pointTo = function(point, instantly) {
      if (this._pointTo.x != point.x || this._pointTo.y != point.y) {
        this._pointTo = point;
        this.invalidate();
        if (!this.visible || instantly) {
          this.moveTo(this._pointTo);
          if (this._animation) {
            this._animation.kill();
          }
        } else {
          if (this.pixelX == 0 && this.pixelY == 0) {
            this.moveTo(this._pointTo);
          } else {
            if (this._animation) {
              this._animation.kill();
            }
            this._animation = new Animation(this, [{ property: "x", to: point.x, from: this.pixelX }, { property: "y", to: point.y, from: this.pixelY }], this.animationDuration, this.animationEasing).start();
          }
        }
      }
    };
    Tooltip2.prototype.setBounds = function(rectangle2) {
      var oldRect = this._boundingRect;
      if (oldRect.x != rectangle2.x || oldRect.y != rectangle2.y || oldRect.width != rectangle2.width || oldRect.height != rectangle2.height) {
        this._boundingRect = rectangle2;
        this.invalidate();
      }
    };
    Object.defineProperty(Tooltip2.prototype, "boundingContainer", {
      /**
       * Sets a [[Container]] instance to be used when calculating numeric
       * boundaries for the Tooltip.
       *
       * @ignore Exclude from docs
       * @param container  Boundary container
       */
      set: function(container) {
        this._boundingContainer = container;
        container.events.on("sizechanged", this.updateBounds, this);
        container.events.on("positionchanged", this.updateBounds, this);
      },
      enumerable: true,
      configurable: true
    });
    Tooltip2.prototype.updateBounds = function() {
      var boundingContainer = this._boundingContainer;
      var rect = spriteRectToSvg({
        x: boundingContainer.pixelX,
        y: boundingContainer.pixelY,
        width: boundingContainer.maxWidth,
        height: boundingContainer.maxHeight
      }, boundingContainer);
      this.setBounds(rect);
    };
    Object.defineProperty(Tooltip2.prototype, "ignoreBounds", {
      /**
       * @return Ignore chart bounds?
       */
      get: function() {
        return this.getPropertyValue("ignoreBounds");
      },
      /**
       * Normally, a tooltip's position will be adjusted so it always fits into
       * chart's coundaries.
       *
       * Setting this to `false` will disable such checks and will allow tooltip
       * to "bleed over" the edge of the chart.
       *
       * @default false
       * @since 4.10.8
       * @param  value  Ignore chart bounds?
       */
      set: function(value) {
        this.setPropertyValue("ignoreBounds", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "verticalOrientation", {
      /**
       * If tooltipOrientation is vertical, it can be drawn below or above point.
       * We need to know this when solving overlapping.
       *
       * @ignore Exclude from docs
       * @return "up" | "down"
       */
      get: function() {
        return this._verticalOrientation;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "tooltip", {
      /**
       * To avoid stackoverflow
       * @ignore
       */
      get: function() {
        return void 0;
      },
      enumerable: true,
      configurable: true
    });
    Tooltip2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.label.copyFrom(source.label);
      if (source._boundingRect) {
        this._boundingRect = source._boundingRect;
      }
    };
    Tooltip2.prototype.asFunction = function(field) {
      return field == "animationEasing" || _super.prototype.asIs.call(this, field);
    };
    return Tooltip2;
  }(Container)
);
registry.registeredClasses["Tooltip"] = Tooltip;

// node_modules/@amcharts/amcharts4/.internal/core/elements/ZoomOutButton.js
var ZoomOutButton = (
  /** @class */
  function(_super) {
    __extends(ZoomOutButton2, _super);
    function ZoomOutButton2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "ZoomOutButton";
      _this.padding(9, 9, 9, 9);
      _this.showSystemTooltip = true;
      var interfaceColors = new InterfaceColorSet();
      var background = _this.background;
      background.cornerRadius(20, 20, 20, 20);
      background.fill = interfaceColors.getFor("primaryButton");
      background.stroke = interfaceColors.getFor("primaryButtonStroke");
      background.strokeOpacity = 0;
      background.states.getKey("hover").properties.fill = interfaceColors.getFor("primaryButtonHover");
      background.states.getKey("down").properties.fill = interfaceColors.getFor("primaryButtonActive");
      var icon = new Sprite();
      icon.element = _this.paper.add("path");
      var path = moveTo({ x: 0, y: 0 });
      path += lineTo({ x: 11, y: 0 });
      icon.path = path;
      icon.pixelPerfect = true;
      icon.padding(8, 3, 8, 3);
      icon.stroke = interfaceColors.getFor("primaryButtonText");
      _this.icon = icon;
      _this.applyTheme();
      return _this;
    }
    ZoomOutButton2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Zoom Out");
      }
    };
    return ZoomOutButton2;
  }(Button)
);
registry.registeredClasses["ZoomOutButton"] = ZoomOutButton;

// node_modules/@amcharts/amcharts4/.internal/core/utils/ColorSet.js
var ColorSet = (
  /** @class */
  function(_super) {
    __extends(ColorSet2, _super);
    function ColorSet2() {
      var _this = _super.call(this) || this;
      _this._list = [];
      _this._currentStep = 0;
      _this._startIndex = 0;
      _this._currentPass = 0;
      _this.baseColor = new Color({
        r: 103,
        g: 183,
        b: 220
      });
      _this.stepOptions = {};
      _this.passOptions = {
        brighten: -0.2
      };
      _this.step = 1;
      _this.minColors = 20;
      _this.minLightness = 0.2;
      _this.maxLightness = 0.9;
      _this.shuffle = false;
      _this.wrap = true;
      _this.reuse = false;
      _this.saturation = 1;
      _this.className = "ColorSet";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ColorSet2.prototype, "list", {
      /**
       * Returns current list of colors.
       *
       * If there are none, a new list of colors is generated, based on various
       * ColorSet settings.
       *
       * @return Color list
       */
      get: function() {
        if (!this._list) {
          this.generate(this.minColors);
        }
        return this._list;
      },
      /**
       * Sets a list of pre-defined colors to use for the iterator.
       *
       * @param value Color list
       */
      set: function(value) {
        this._list = value;
        this.reset();
      },
      enumerable: true,
      configurable: true
    });
    ColorSet2.prototype.getReusableColor = function(index) {
      if (this._list.length == 0) {
        this.generate(1);
        return this.list[0];
      } else {
        var tmpstep = index - Math.floor(index / this._list.length) * this.list.length;
        return this.list[tmpstep];
      }
    };
    ColorSet2.prototype.next = function() {
      var color2;
      if (this.list.length <= this._currentStep) {
        if (this.reuse) {
          color2 = this.getReusableColor(this._currentStep);
        } else {
          this.generate(max(this.minColors, this._currentStep + 1));
          color2 = this.list[this._currentStep];
        }
      } else {
        color2 = this.list[this._currentStep];
      }
      this._currentStep += this.step;
      return color2.saturate(this.saturation);
    };
    ColorSet2.prototype.getIndex = function(i) {
      var color2;
      if (this.list.length <= i) {
        if (this.reuse) {
          color2 = this.getReusableColor(i);
        } else {
          this.generate(this.minColors);
          color2 = this.getIndex(i);
        }
      } else {
        color2 = this.list[i];
      }
      return color2.saturate(this.saturation);
    };
    ColorSet2.prototype.reset = function() {
      this._currentStep = this._startIndex;
    };
    Object.defineProperty(ColorSet2.prototype, "currentStep", {
      /**
       * @return Step
       */
      get: function() {
        return this._currentStep;
      },
      /**
       * Sets current color iteration. You can use this property to skip some
       * colors from iteration. E.g. setting it to `10` will skip first ten
       * colors.
       *
       * Please note that the number is zero-based.
       *
       * @param value  Step
       */
      set: function(value) {
        this._currentStep = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColorSet2.prototype, "startIndex", {
      /**
       * @return Index
       */
      get: function() {
        return this._startIndex;
      },
      /**
       * If set to non-zero value, the ColorSet will start iterating colors from
       * that particular index, not the first color in the list.
       *
       * @default 0
       * @since 4.4.9
       * @param  value  Index
       */
      set: function(value) {
        this._startIndex = value;
        this.reset();
      },
      enumerable: true,
      configurable: true
    });
    ColorSet2.prototype.generate = function(count) {
      var curColor = this.currentColor;
      var hsl = rgbToHsl(getValue(curColor.rgb));
      var hueStep = hasValue(this.stepOptions.hue) ? this.stepOptions.hue : 1 / count;
      var mods = {
        brighten: 0,
        lighten: 0,
        hue: hsl.h,
        lightness: hsl.l,
        saturation: hsl.s
      };
      var hues = [];
      var startIndex = this.list.length == 0 ? 0 : 1;
      if (this.reuse) {
        for (var i = startIndex; i <= count; i++) {
          hues.push(rgbToHsl(getValue(this._list[i].rgb)).h);
        }
      } else {
        for (var i = startIndex; i <= count; i++) {
          var h = hsl.h + hueStep * i;
          if (this.wrap && h > 1) {
            h -= 1;
          }
          hues.push(h);
        }
      }
      if (this.shuffle) {
        hues.sort(function(a, b) {
          return Math.random() - 0.5;
        });
      }
      for (var i = 0; i < count; i++) {
        if (this.reuse) {
          hsl = rgbToHsl(getValue(this._list[i].rgb));
        } else {
          hsl.h = hues.shift();
        }
        this.applyStepOptions(hsl, mods, i, this._currentPass);
        var c = color(hslToRgb(hsl));
        var brighten2 = (this.stepOptions.brighten || 0) * i + (this.passOptions.brighten || 0) * this._currentPass;
        if (brighten2 != 0) {
          if (this.wrap) {
            brighten2 = fitNumberRelative(brighten2, this.minLightness, this.maxLightness);
          } else {
            brighten2 = fitNumber(brighten2, this.minLightness, this.maxLightness);
          }
          c = c.brighten(brighten2);
        }
        var lighten2 = (this.stepOptions.lighten || 0) * i + (this.passOptions.lighten || 0) * this._currentPass;
        if (lighten2 != 0) {
          if (this.wrap) {
            lighten2 = fitNumberRelative(lighten2, this.minLightness, this.maxLightness);
          } else {
            lighten2 = fitNumber(lighten2, this.minLightness, this.maxLightness);
          }
          c = c.lighten(lighten2);
        }
        this._list.push(c);
      }
      this._currentPass++;
    };
    Object.defineProperty(ColorSet2.prototype, "currentColor", {
      /**
       * Returns current last color. It's either the last color in the list of
       * colors, or `baseColor` if list is empty.
       *
       * @return Color
       */
      get: function() {
        if (this._list.length == 0) {
          return this.baseColor.saturate(this.saturation);
        } else {
          return this._list[this._list.length - 1].saturate(this.saturation);
        }
      },
      enumerable: true,
      configurable: true
    });
    ColorSet2.prototype.applyStepOptions = function(hsl, base, step, pass) {
      hsl.l = base.lightness + (this.stepOptions.lightness || 0) * step + (this.passOptions.lightness || 0) * pass;
      if (this.wrap) {
        if (hsl.l > 1) {
          hsl.l = hsl.l - Math.floor(hsl.l);
        } else if (hsl.l < 0) {
          hsl.l = -(hsl.l - Math.floor(hsl.l));
        }
        hsl.l = fitNumberRelative(hsl.l, this.minLightness, this.maxLightness);
      } else {
        if (hsl.l > 1) {
          hsl.l = 1;
        } else if (hsl.l < 0) {
          hsl.l = 0;
        }
        hsl.l = fitNumber(hsl.l, this.minLightness, this.maxLightness);
      }
    };
    ColorSet2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.list) && isArray(config.list)) {
          for (var i = 0, len = config.list.length; i < len; i++) {
            if (!(config.list[i] instanceof Color)) {
              config.list[i] = color(config.list[i]);
            }
          }
        }
        if (hasValue(config.baseColor) && !(config.baseColor instanceof Color)) {
          config.baseColor = color(config.baseColor);
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    return ColorSet2;
  }(BaseObject)
);
registry.registeredClasses["ColorSet"] = ColorSet;

export {
  IndexedIterable,
  ListGrouper,
  ListDisposer,
  List,
  ListTemplate,
  OrderedList,
  SortedList,
  OrderedListTemplate,
  SortedListTemplate,
  Number_exports,
  reverse,
  or,
  GlobalAdapter,
  globalAdapter,
  Adapter,
  interpolate,
  Colors_exports,
  Color,
  color,
  isColor,
  castColor,
  toColor,
  BaseObject,
  BaseObjectEvents,
  PX,
  STRING,
  NUMBER,
  DATE,
  DURATION,
  PLACEHOLDER,
  PLACEHOLDER2,
  used,
  relativeToValue,
  stringify,
  plainText,
  spritePointToSvg,
  documentPointToSvg,
  documentPointToSprite,
  isIE,
  Utils_exports,
  cubicIn,
  cubicOut,
  Ease_exports,
  SpriteState,
  SpriteEventDispatcher,
  SVGDefaults,
  options,
  animate,
  AnimationDisposer,
  Animation,
  XLINK,
  addEventListener,
  getElement,
  addClass,
  removeClass,
  blur,
  focus,
  outerHTML,
  isElement,
  getRoot,
  copyAttributes,
  fixPixelPerfect,
  StyleRule,
  StyleClass,
  ready,
  isElementInViewport,
  AMElement,
  Group,
  InterfaceColorSet,
  InteractionObjectEventDispatcher,
  InteractionObject,
  InteractionKeyboardObject,
  Inertia,
  Keyboard,
  keyboard,
  Time_exports,
  Interaction,
  getInteraction,
  Popup,
  Modal,
  warn,
  svgContainers,
  SVGContainer,
  Paper,
  Pattern,
  LinearGradient,
  RadialGradient,
  MouseCursorStyle,
  Language,
  TextFormatter,
  getTextFormatter,
  NumberFormatter,
  DateFormatter,
  DurationFormatter,
  Validatable,
  ExportMenu,
  Net_exports,
  Export,
  visualProperties,
  Sprite,
  Rectangle,
  Container,
  System,
  system,
  DataParser,
  CSVParser,
  JSONParser,
  DataLoader,
  dataLoader,
  DataSource,
  Responsive,
  defaultRules,
  ResponsiveBreakpoints,
  DataItem,
  Component,
  Label,
  RoundedRectangle,
  Button,
  Circle,
  PointedShape,
  PointedRectangle,
  polyline,
  moveTo,
  lineTo,
  cubicCurveTo,
  closePath,
  arcTo,
  arc,
  arcToPoint,
  Path_exports,
  ResizeButton,
  Scrollbar,
  Filter,
  DropShadowFilter,
  Tooltip,
  ZoomOutButton,
  ColorSet
};
//# sourceMappingURL=chunk-CXEJRZF7.js.map
